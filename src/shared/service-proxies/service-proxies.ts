//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AbsenceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AbsenceDto> {
        let url_ = this.baseUrl + "/api/services/app/Absence/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AbsenceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AbsenceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AbsenceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AbsenceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbsenceDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isPayable (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isPayable: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AbsenceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Absence/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isPayable !== undefined && isPayable !== null)
            url_ += "IsPayable=" + encodeURIComponent("" + isPayable) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AbsenceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AbsenceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AbsenceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AbsenceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbsenceDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAbsenceDto | undefined): Observable<AbsenceDto> {
        let url_ = this.baseUrl + "/api/services/app/Absence/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AbsenceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AbsenceDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AbsenceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AbsenceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbsenceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAbsenceDto | undefined): Observable<AbsenceDto> {
        let url_ = this.baseUrl + "/api/services/app/Absence/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AbsenceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AbsenceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AbsenceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AbsenceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbsenceDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Absence/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllAbsenceType(): Observable<AbsenceTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Absence/GetAllAbsenceType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAbsenceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAbsenceType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AbsenceTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AbsenceTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAllAbsenceType(response: HttpResponseBase): Observable<AbsenceTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AbsenceTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbsenceTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class AcademicDegreeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAcademicDegreeDto | undefined): Observable<AcademicDegreeDto> {
        let url_ = this.baseUrl + "/api/services/app/AcademicDegree/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicDegreeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicDegreeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AcademicDegreeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicDegreeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicDegreeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAcademicDegreeDto | undefined): Observable<AcademicDegreeDto> {
        let url_ = this.baseUrl + "/api/services/app/AcademicDegree/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicDegreeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicDegreeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AcademicDegreeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicDegreeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicDegreeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcademicDegree/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AcademicDegreeDto> {
        let url_ = this.baseUrl + "/api/services/app/AcademicDegree/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicDegreeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicDegreeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AcademicDegreeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicDegreeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicDegreeDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<AcademicDegreeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AcademicDegree/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicDegreeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicDegreeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AcademicDegreeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicDegreeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicDegreeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class AcademicInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AcademicInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/AcademicInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AcademicInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<AcademicInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AcademicInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AcademicInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAcademicInfoDto | undefined): Observable<AcademicInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/AcademicInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AcademicInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAcademicInfoDto | undefined): Observable<AcademicInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/AcademicInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AcademicInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AcademicInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AcademicInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AcademicInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AcademicInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AcademicInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param code (optional) 
     * @return Success
     */
    confirmUser(tenantId: number | null | undefined, userId: number | undefined, code: string | null | undefined): Observable<IdentityResult> {
        let url_ = this.baseUrl + "/api/services/app/Account/ConfirmUser?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityResult>;
        }));
    }

    protected processConfirmUser(response: HttpResponseBase): Observable<IdentityResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentityResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAccountDto | undefined): Observable<AccountDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateAccountDto | undefined): Observable<AccountDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AccountDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<AccountDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AccountDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class AccountingDataingDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAccountingDataDto | undefined): Observable<AccountingDataDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountingDataingData/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountingDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountingDataDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AccountingDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountingDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountingDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateAccountingDataDto | undefined): Observable<AccountingDataDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountingDataingData/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountingDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountingDataDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AccountingDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountingDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountingDataDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AccountingDataDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountingDataingData/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountingDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountingDataDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AccountingDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountingDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountingDataDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountingDataingData/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<AccountingDataDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountingDataingData/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountingDataDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountingDataDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AccountingDataDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountingDataDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountingDataDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class AccountSubFamilyTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAccountSubFamilyTypeDto | undefined): Observable<AccountSubFamilyTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubFamilyType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountSubFamilyTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountSubFamilyTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AccountSubFamilyTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountSubFamilyTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountSubFamilyTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateAccountSubFamilyTypeDto | undefined): Observable<AccountSubFamilyTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubFamilyType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountSubFamilyTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountSubFamilyTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AccountSubFamilyTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountSubFamilyTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountSubFamilyTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AccountSubFamilyTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubFamilyType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountSubFamilyTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountSubFamilyTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AccountSubFamilyTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountSubFamilyTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountSubFamilyTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubFamilyType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<AccountSubFamilyTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubFamilyType/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountSubFamilyTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountSubFamilyTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AccountSubFamilyTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountSubFamilyTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountSubFamilyTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class AccountTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAccountTypeDto | undefined): Observable<AccountTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AccountTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateAccountTypeDto | undefined): Observable<AccountTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AccountTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AccountTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AccountTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<AccountTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountType/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AccountTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ActionTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ActionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ActionType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ActionTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionTypeDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ActionTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ActionType/GetAll?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ActionTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateActionTypeDto | undefined): Observable<ActionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ActionType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ActionTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateActionTypeDto | undefined): Observable<ActionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ActionType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ActionTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActionType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ActiveIngredientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateActiveIngredientDto | undefined): Observable<ActiveIngredientDto> {
        let url_ = this.baseUrl + "/api/services/app/ActiveIngredient/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveIngredientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveIngredientDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ActiveIngredientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActiveIngredientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActiveIngredientDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateActiveIngredientDto | undefined): Observable<ActiveIngredientDto> {
        let url_ = this.baseUrl + "/api/services/app/ActiveIngredient/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveIngredientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveIngredientDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ActiveIngredientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActiveIngredientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActiveIngredientDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ActiveIngredientDto> {
        let url_ = this.baseUrl + "/api/services/app/ActiveIngredient/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveIngredientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveIngredientDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ActiveIngredientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActiveIngredientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActiveIngredientDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActiveIngredient/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ActiveIngredientDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ActiveIngredient/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveIngredientDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveIngredientDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ActiveIngredientDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActiveIngredientDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActiveIngredientDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateActivityDto | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateActivityDto | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param macroActivity (optional) 
     * @param farmIds (optional) 
     * @param activitiesId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, macroActivity: string | null | undefined, farmIds: string[] | null | undefined, activitiesId: string[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ActivityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (macroActivity !== undefined && macroActivity !== null)
            url_ += "MacroActivity=" + encodeURIComponent("" + macroActivity) + "&";
        if (farmIds !== undefined && farmIds !== null)
            farmIds && farmIds.forEach(item => { url_ += "FarmIds=" + encodeURIComponent("" + item) + "&"; });
        if (activitiesId !== undefined && activitiesId !== null)
            activitiesId && activitiesId.forEach(item => { url_ += "ActivitiesId=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ActivityDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AddressServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AddressDto> {
        let url_ = this.baseUrl + "/api/services/app/Address/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AddressDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Address/GetAll?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AddressDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAddressDto | undefined): Observable<AddressDto> {
        let url_ = this.baseUrl + "/api/services/app/Address/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAddressDto | undefined): Observable<AddressDto> {
        let url_ = this.baseUrl + "/api/services/app/Address/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Address/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AFCInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AFCInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/AFCInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AFCInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AFCInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AFCInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AFCInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AFCInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<AFCInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AFCInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AFCInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AFCInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AFCInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AFCInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AFCInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAFCInfoDto | undefined): Observable<AFCInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/AFCInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AFCInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AFCInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AFCInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AFCInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AFCInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAFCInfoDto | undefined): Observable<AFCInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/AFCInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AFCInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AFCInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AFCInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AFCInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AFCInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AFCInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AppProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AppProductDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProduct/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AppProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AppProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProduct/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AppProductDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: AppProductDto | undefined): Observable<AppProductDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProduct/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AppProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AppProductDto | undefined): Observable<AppProductDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProduct/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AppProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppProduct/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AppProductSessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAppProductSessionDto | undefined): Observable<AppProductSessionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProductSession/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductSessionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AppProductSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductSessionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAppProductSessionDto | undefined): Observable<AppProductSessionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProductSession/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductSessionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AppProductSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductSessionDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAll(userId: number | undefined): Observable<AppProductSessionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProductSession/GetAll?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductSessionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductSessionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AppProductSessionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductSessionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductSessionDtoPagedResultDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param code (optional) 
     * @return Success
     */
    getCheckExistAppProductSession(userId: number | undefined, code: string | null | undefined): Observable<AppProductSessionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProductSession/GetCheckExistAppProductSession?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckExistAppProductSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckExistAppProductSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductSessionDto>;
        }));
    }

    protected processGetCheckExistAppProductSession(response: HttpResponseBase): Observable<AppProductSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductSessionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AppProductSessionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppProductSession/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppProductSessionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppProductSessionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AppProductSessionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppProductSessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppProductSessionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppProductSession/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ApprovalOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApprovalOrderDto | undefined): Observable<ApprovalOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalOrder/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalOrderDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApprovalOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalOrderDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateApprovalOrderDto | undefined): Observable<ApprovalOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalOrder/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalOrderDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApprovalOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalOrderDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApprovalOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalOrder/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalOrderDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApprovalOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalOrderDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalOrder/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param authorizationMethodId (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, authorizationMethodId: number | undefined): Observable<ApprovalOrderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalOrder/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (authorizationMethodId === null)
            throw new Error("The parameter 'authorizationMethodId' cannot be null.");
        else if (authorizationMethodId !== undefined)
            url_ += "AuthorizationMethodId=" + encodeURIComponent("" + authorizationMethodId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalOrderDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalOrderDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApprovalOrderDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalOrderDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalOrderDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ApprovalTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApprovalTypeDto | undefined): Observable<ApprovalTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApprovalTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateApprovalTypeDto | undefined): Observable<ApprovalTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApprovalTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApprovalTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApprovalTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param approverEntityId (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, approverEntityId: number | null | undefined): Observable<ApprovalTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalType/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (approverEntityId !== undefined && approverEntityId !== null)
            url_ += "ApproverEntityId=" + encodeURIComponent("" + approverEntityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApprovalTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ApproverEntityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApproverEntityDto | undefined): Observable<ApproverEntityDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntity/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverEntityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverEntityDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApproverEntityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverEntityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverEntityDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateApproverEntityDto | undefined): Observable<ApproverEntityDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverEntityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverEntityDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApproverEntityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverEntityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverEntityDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApproverEntityDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntity/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverEntityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverEntityDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApproverEntityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverEntityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverEntityDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntity/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ApproverEntityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntity/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverEntityDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverEntityDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApproverEntityDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverEntityDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverEntityDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ApproverEntityConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApproverEntityConfigDto | undefined): Observable<ApproverEntityConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntityConfig/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverEntityConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverEntityConfigDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApproverEntityConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverEntityConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverEntityConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateApproverEntityConfigDto | undefined): Observable<ApproverEntityConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntityConfig/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverEntityConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverEntityConfigDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApproverEntityConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverEntityConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverEntityConfigDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApproverEntityConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntityConfig/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverEntityConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverEntityConfigDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApproverEntityConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverEntityConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverEntityConfigDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntityConfig/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param farmId (optional) 
     * @param approverEntityId (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, farmId: string | null | undefined, approverEntityId: number | null | undefined, isActive: boolean | null | undefined): Observable<ApproverEntityConfigDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverEntityConfig/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (farmId !== undefined && farmId !== null)
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (approverEntityId !== undefined && approverEntityId !== null)
            url_ += "ApproverEntityId=" + encodeURIComponent("" + approverEntityId) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverEntityConfigDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverEntityConfigDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApproverEntityConfigDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverEntityConfigDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverEntityConfigDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ApproverModuleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApproverModuleDto | undefined): Observable<ApproverModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverModule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverModuleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApproverModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverModuleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateApproverModuleDto | undefined): Observable<ApproverModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverModule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverModuleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApproverModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverModuleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ApproverModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverModule/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverModuleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApproverModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverModuleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApproverModule/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ApproverModuleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApproverModule/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverModuleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverModuleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApproverModuleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverModuleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverModuleDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class AprroverConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAprroverConfigDto | undefined): Observable<AprroverConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AprroverConfig/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AprroverConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AprroverConfigDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AprroverConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AprroverConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AprroverConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateAprroverConfigDto | undefined): Observable<AprroverConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AprroverConfig/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AprroverConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AprroverConfigDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AprroverConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AprroverConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AprroverConfigDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AprroverConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AprroverConfig/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AprroverConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AprroverConfigDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AprroverConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AprroverConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AprroverConfigDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AprroverConfig/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<AprroverConfigDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AprroverConfig/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AprroverConfigDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AprroverConfigDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AprroverConfigDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AprroverConfigDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AprroverConfigDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class AprroverFamilyConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAprroverFamilyConfigDto | undefined): Observable<AprroverFamilyConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AprroverFamilyConfig/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AprroverFamilyConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AprroverFamilyConfigDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AprroverFamilyConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AprroverFamilyConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AprroverFamilyConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateAprroverFamilyConfigDto | undefined): Observable<AprroverFamilyConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AprroverFamilyConfig/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AprroverFamilyConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AprroverFamilyConfigDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AprroverFamilyConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AprroverFamilyConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AprroverFamilyConfigDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AprroverFamilyConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/AprroverFamilyConfig/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AprroverFamilyConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AprroverFamilyConfigDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AprroverFamilyConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AprroverFamilyConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AprroverFamilyConfigDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AprroverFamilyConfig/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<AprroverFamilyConfigDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AprroverFamilyConfig/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AprroverFamilyConfigDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AprroverFamilyConfigDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AprroverFamilyConfigDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AprroverFamilyConfigDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AprroverFamilyConfigDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class AttendanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createByVehicle(body: CreateVehicleEntranceDto | undefined): Observable<VehicleEntranceDto> {
        let url_ = this.baseUrl + "/Attendance/CreateByVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateByVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateByVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleEntranceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleEntranceDto>;
        }));
    }

    protected processCreateByVehicle(response: HttpResponseBase): Observable<VehicleEntranceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleEntranceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleEntranceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createByWorker(body: CreateAttendanceDto | undefined): Observable<AttendanceDto> {
        let url_ = this.baseUrl + "/Attendance/CreateByWorker";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateByWorker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateByWorker(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttendanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttendanceDto>;
        }));
    }

    protected processCreateByWorker(response: HttpResponseBase): Observable<AttendanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttendanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttendanceDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AttendanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttendanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttendanceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AttendanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttendanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttendanceDto>(null as any);
    }

    /**
     * @param from (optional) 
     * @param to (optional) 
     * @param farmsId (optional) 
     * @param workersId (optional) 
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(from: moment.Moment | undefined, to: moment.Moment | undefined, farmsId: string[] | null | undefined, workersId: string[] | null | undefined, keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AttendanceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/GetAll?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (farmsId !== undefined && farmsId !== null)
            farmsId && farmsId.forEach(item => { url_ += "FarmsId=" + encodeURIComponent("" + item) + "&"; });
        if (workersId !== undefined && workersId !== null)
            workersId && workersId.forEach(item => { url_ += "WorkersId=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttendanceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttendanceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AttendanceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttendanceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttendanceDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAttendanceDto | undefined): Observable<AttendanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttendanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttendanceDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AttendanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttendanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttendanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createVehicleEntrance(body: CreateVehicleEntranceDto | undefined): Observable<VehicleEntranceDto> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/CreateVehicleEntrance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVehicleEntrance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVehicleEntrance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleEntranceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleEntranceDto>;
        }));
    }

    protected processCreateVehicleEntrance(response: HttpResponseBase): Observable<VehicleEntranceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleEntranceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VehicleEntranceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAttendanceDto | undefined): Observable<AttendanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttendanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttendanceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AttendanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttendanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttendanceDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    multipleDeleteByIds(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/MultipleDeleteByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMultipleDeleteByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMultipleDeleteByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMultipleDeleteByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLogs(id: string | undefined): Observable<AttendanceLogDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/GetLogs?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttendanceLogDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttendanceLogDto[]>;
        }));
    }

    protected processGetLogs(response: HttpResponseBase): Observable<AttendanceLogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AttendanceLogDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttendanceLogDto[]>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: GuidEntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attendance/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AuthorizationMethodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAuthorizationMethodDto | undefined): Observable<AuthorizationMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMethod/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorizationMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorizationMethodDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AuthorizationMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorizationMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthorizationMethodDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateAuthorizationMethodDto | undefined): Observable<AuthorizationMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMethod/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorizationMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorizationMethodDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AuthorizationMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorizationMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthorizationMethodDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<AuthorizationMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMethod/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorizationMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorizationMethodDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AuthorizationMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorizationMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthorizationMethodDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMethod/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param approvalTypeId (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, approvalTypeId: number | undefined): Observable<AuthorizationMethodDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuthorizationMethod/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (approvalTypeId === null)
            throw new Error("The parameter 'approvalTypeId' cannot be null.");
        else if (approvalTypeId !== undefined)
            url_ += "ApprovalTypeId=" + encodeURIComponent("" + approvalTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthorizationMethodDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthorizationMethodDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AuthorizationMethodDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorizationMethodDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthorizationMethodDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class BankServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateBankDto | undefined): Observable<BankDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateBankDto | undefined): Observable<BankDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<BankDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param countryId (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, countryId: number | null | undefined): Observable<BankDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (countryId !== undefined && countryId !== null)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BankDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class BankAccountTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateBankAccountTypeAccountTypeDto | undefined): Observable<BankAccountTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/BankAccountType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankAccountTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankAccountTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BankAccountTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankAccountTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateBankAccountTypeAccountTypeDto | undefined): Observable<BankAccountTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/BankAccountType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankAccountTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankAccountTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BankAccountTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankAccountTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BankAccountType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<BankAccountTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/BankAccountType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankAccountTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankAccountTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BankAccountTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankAccountTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountTypeDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param bankId (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, bankId: number | null | undefined): Observable<BankAccountTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BankAccountType/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (bankId !== undefined && bankId !== null)
            url_ += "BankId=" + encodeURIComponent("" + bankId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankAccountTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankAccountTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BankAccountTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankAccountTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class BankaryInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<BankaryInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/BankaryInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankaryInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankaryInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BankaryInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankaryInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankaryInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<BankaryInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BankaryInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankaryInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankaryInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BankaryInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankaryInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankaryInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateBankaryInfoDto | undefined): Observable<BankaryInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/BankaryInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankaryInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankaryInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BankaryInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankaryInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankaryInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBankaryInfoDto | undefined): Observable<BankaryInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/BankaryInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankaryInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankaryInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BankaryInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankaryInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankaryInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BankaryInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BreakServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<BreakDto> {
        let url_ = this.baseUrl + "/api/services/app/Break/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BreakDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BreakDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BreakDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BreakDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BreakDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BreakDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Break/GetAll?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BreakDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BreakDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BreakDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BreakDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BreakDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateBreakDto | undefined): Observable<BreakDto> {
        let url_ = this.baseUrl + "/api/services/app/Break/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BreakDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BreakDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BreakDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BreakDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BreakDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBreakDto | undefined): Observable<BreakDto> {
        let url_ = this.baseUrl + "/api/services/app/Break/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BreakDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BreakDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BreakDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BreakDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BreakDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Break/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BusinessAreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateBusinessAreaInput | undefined): Observable<BusinessAreaDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessArea/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessAreaDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessAreaDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BusinessAreaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessAreaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessAreaDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateBusinessAreaInput | undefined): Observable<BusinessAreaDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessArea/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessAreaDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessAreaDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BusinessAreaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessAreaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessAreaDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessArea/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<BusinessAreaDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessArea/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessAreaDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessAreaDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BusinessAreaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessAreaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessAreaDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BusinessAreaDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessArea/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessAreaDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessAreaDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BusinessAreaDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessAreaDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessAreaDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class CommentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCommentDto | undefined): Observable<CommentDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CommentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCommentDto | undefined): Observable<CommentDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CommentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<CommentDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CommentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CommentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CommentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class CompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param companiesId (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, companiesId: string[] | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CompanyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (companiesId !== undefined && companiesId !== null)
            companiesId && companiesId.forEach(item => { url_ += "CompaniesId=" + encodeURIComponent("" + item) + "&"; });
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompanyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMainInfo(body: UpdateCompanyMainInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/UpdateMainInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMainInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMainInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateMainInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMainInfo(id: string | undefined): Observable<UpdateCompanyMainInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetMainInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMainInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMainInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCompanyMainInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCompanyMainInfoDto>;
        }));
    }

    protected processGetMainInfo(response: HttpResponseBase): Observable<UpdateCompanyMainInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCompanyMainInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateCompanyMainInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLogo(body: UpdateCompanyLogoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/UpdateLogo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLogo(id: string | undefined): Observable<UpdateCompanyLogoDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetLogo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCompanyLogoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCompanyLogoDto>;
        }));
    }

    protected processGetLogo(response: HttpResponseBase): Observable<UpdateCompanyLogoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCompanyLogoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateCompanyLogoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactAddressInfo(body: UpdateCompanyContactAddressInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/UpdateContactAddressInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactAddressInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactAddressInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateContactAddressInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContactAddressInfo(id: string | undefined): Observable<CompanyContactAddressInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetContactAddressInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactAddressInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactAddressInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyContactAddressInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyContactAddressInfoDto>;
        }));
    }

    protected processGetContactAddressInfo(response: HttpResponseBase): Observable<CompanyContactAddressInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyContactAddressInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyContactAddressInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLegalFiscalInfo(body: UpdateLegalFiscalInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/UpdateLegalFiscalInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLegalFiscalInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLegalFiscalInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLegalFiscalInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLegalFiscalInfo(id: string | undefined): Observable<UpdateLegalFiscalInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetLegalFiscalInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLegalFiscalInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLegalFiscalInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateLegalFiscalInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateLegalFiscalInfoDto>;
        }));
    }

    protected processGetLegalFiscalInfo(response: HttpResponseBase): Observable<UpdateLegalFiscalInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateLegalFiscalInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateLegalFiscalInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCompanyTags(body: UpdateCompanyTagsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/UpdateCompanyTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompanyTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompanyTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCompanyTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCompanyTags(id: string | undefined): Observable<UpdateCompanyTagsDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetCompanyTags?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCompanyTagsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCompanyTagsDto>;
        }));
    }

    protected processGetCompanyTags(response: HttpResponseBase): Observable<UpdateCompanyTagsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCompanyTagsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateCompanyTagsDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getCompaniesFilter(): Observable<CompanyFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetCompaniesFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompaniesFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompaniesFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyFilterDtoPagedResultDto>;
        }));
    }

    protected processGetCompaniesFilter(response: HttpResponseBase): Observable<CompanyFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyFilterDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFinancialInfo(body: UpdateFinancialInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/UpdateFinancialInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFinancialInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFinancialInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateFinancialInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFinancialInfo(id: string | undefined): Observable<UpdateFinancialInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetFinancialInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinancialInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinancialInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateFinancialInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateFinancialInfoDto>;
        }));
    }

    protected processGetFinancialInfo(response: HttpResponseBase): Observable<UpdateFinancialInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateFinancialInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateFinancialInfoDto>(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContactInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateContactInfoDto | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ContactInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ContactInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateContactInfoDto | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContractServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto>(null as any);
    }

    /**
     * @param name (optional) 
     * @param jobTitleIds (optional) 
     * @param supervisorIds (optional) 
     * @param departmentIds (optional) 
     * @param paymentTypeIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(farmId: string, name: string | null | undefined, jobTitleIds: string[] | null | undefined, supervisorIds: string[] | null | undefined, departmentIds: string[] | null | undefined, paymentTypeIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ContractDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetAll?";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (jobTitleIds !== undefined && jobTitleIds !== null)
            jobTitleIds && jobTitleIds.forEach(item => { url_ += "JobTitleIds=" + encodeURIComponent("" + item) + "&"; });
        if (supervisorIds !== undefined && supervisorIds !== null)
            supervisorIds && supervisorIds.forEach(item => { url_ += "SupervisorIds=" + encodeURIComponent("" + item) + "&"; });
        if (departmentIds !== undefined && departmentIds !== null)
            departmentIds && departmentIds.forEach(item => { url_ += "DepartmentIds=" + encodeURIComponent("" + item) + "&"; });
        if (paymentTypeIds !== undefined && paymentTypeIds !== null)
            paymentTypeIds && paymentTypeIds.forEach(item => { url_ += "PaymentTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ContractDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateContractDto | undefined): Observable<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContracAnnex(body: CreateContractAnnexDto | undefined): Observable<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/CreateContracAnnex";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContracAnnex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContracAnnex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto>;
        }));
    }

    protected processCreateContracAnnex(response: HttpResponseBase): Observable<ContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateContractDto | undefined): Observable<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contract/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authorizeContract(body: AuthorizeContractDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Contract/AuthorizeContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthorizeContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthorizeContract(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAuthorizeContract(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    companyContractSign(body: ContractCompanySignDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Contract/CompanyContractSign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompanyContractSign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompanyContractSign(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCompanyContractSign(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    workerContractSign(body: ContractCompanySignDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Contract/WorkerContractSign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkerContractSign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkerContractSign(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processWorkerContractSign(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getContractDocTypes(): Observable<CorrelativeTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetContractDocTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractDocTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractDocTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorrelativeTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorrelativeTypeDtoPagedResultDto>;
        }));
    }

    protected processGetContractDocTypes(response: HttpResponseBase): Observable<CorrelativeTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorrelativeTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorrelativeTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectContract(body: RejectContractDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Contract/RejectContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectContract(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRejectContract(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: GuidEntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contract/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGeneralInfo(id: string | undefined): Observable<ContractGeneralInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetGeneralInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractGeneralInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractGeneralInfoDto>;
        }));
    }

    protected processGetGeneralInfo(response: HttpResponseBase): Observable<ContractGeneralInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractGeneralInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractGeneralInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGeneralInfo(body: ContractGeneralInfoDto | undefined): Observable<ContractGeneralInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/UpdateGeneralInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractGeneralInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractGeneralInfoDto>;
        }));
    }

    protected processUpdateGeneralInfo(response: HttpResponseBase): Observable<ContractGeneralInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractGeneralInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractGeneralInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkPermitInfo(id: string | undefined): Observable<WorkPermitInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetWorkPermitInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkPermitInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkPermitInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkPermitInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkPermitInfoDto>;
        }));
    }

    protected processGetWorkPermitInfo(response: HttpResponseBase): Observable<WorkPermitInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkPermitInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkPermitInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateWorkPermitInfo(body: UpdateWorkPermitInfoDto | undefined): Observable<WorkPermitInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/UpdateWorkPermitInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWorkPermitInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWorkPermitInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkPermitInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkPermitInfoDto>;
        }));
    }

    protected processUpdateWorkPermitInfo(response: HttpResponseBase): Observable<WorkPermitInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkPermitInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkPermitInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSalaryAllowances(id: string | undefined): Observable<ContractSalaryAllowanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetSalaryAllowances?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalaryAllowances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAllowances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractSalaryAllowanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractSalaryAllowanceDto>;
        }));
    }

    protected processGetSalaryAllowances(response: HttpResponseBase): Observable<ContractSalaryAllowanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractSalaryAllowanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractSalaryAllowanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSalaryAllowances(body: ContractSalaryAllowanceDto | undefined): Observable<ContractSalaryAllowanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/UpdateSalaryAllowances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSalaryAllowances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSalaryAllowances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractSalaryAllowanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractSalaryAllowanceDto>;
        }));
    }

    protected processUpdateSalaryAllowances(response: HttpResponseBase): Observable<ContractSalaryAllowanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractSalaryAllowanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractSalaryAllowanceDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSalaryInfo(id: string | undefined): Observable<ContractSalaryInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetSalaryInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalaryInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractSalaryInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractSalaryInfoDto>;
        }));
    }

    protected processGetSalaryInfo(response: HttpResponseBase): Observable<ContractSalaryInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractSalaryInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractSalaryInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSalaryInfo(body: ContractSalaryInfoDto | undefined): Observable<ContractGeneralInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/UpdateSalaryInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSalaryInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSalaryInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractGeneralInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractGeneralInfoDto>;
        }));
    }

    protected processUpdateSalaryInfo(response: HttpResponseBase): Observable<ContractGeneralInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractGeneralInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractGeneralInfoDto>(null as any);
    }
}

@Injectable()
export class ContractLayoutServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(companyId: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ContractLayoutDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractLayout/GetAll?";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined and cannot be null.");
        else
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractLayoutDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractLayoutDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ContractLayoutDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractLayoutDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractLayoutDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ContractLayoutDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractLayout/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractLayoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractLayoutDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContractLayoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractLayoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractLayoutDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateContractLayoutDto | undefined): Observable<ContractLayoutDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractLayout/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractLayoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractLayoutDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContractLayoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractLayoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractLayoutDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateContractLayoutDto | undefined): Observable<ContractLayoutDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractLayout/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractLayoutDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractLayoutDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContractLayoutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractLayoutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractLayoutDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContractLayout/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContractorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ContractorDto> {
        let url_ = this.baseUrl + "/api/services/app/Contractor/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractorDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContractorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractorDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ContractorDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Contractor/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractorDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractorDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ContractorDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractorDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateContractorDto | undefined): Observable<ContractorDto> {
        let url_ = this.baseUrl + "/api/services/app/Contractor/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractorDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContractorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateContractorDto | undefined): Observable<ContractorDto> {
        let url_ = this.baseUrl + "/api/services/app/Contractor/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractorDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContractorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractorDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contractor/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContractTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ContractTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractType/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ContractTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ContractTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContractTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateContractTypeDto | undefined): Observable<ContractTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContractTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateContractTypeDto | undefined): Observable<ContractTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContractTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContractType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CorrelativeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param correlativeTypeId (optional) 
     * @return Success
     */
    next(correlativeTypeId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Correlative/next?";
        if (correlativeTypeId === null)
            throw new Error("The parameter 'correlativeTypeId' cannot be null.");
        else if (correlativeTypeId !== undefined)
            url_ += "correlativeTypeId=" + encodeURIComponent("" + correlativeTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNext(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNext(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processNext(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getNext(correlativeTypeId: number): Observable<CorrelativeDto> {
        let url_ = this.baseUrl + "/api/services/app/Correlative/GetNext?";
        if (correlativeTypeId === undefined || correlativeTypeId === null)
            throw new Error("The parameter 'correlativeTypeId' must be defined and cannot be null.");
        else
            url_ += "CorrelativeTypeId=" + encodeURIComponent("" + correlativeTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNext(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNext(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorrelativeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorrelativeDto>;
        }));
    }

    protected processGetNext(response: HttpResponseBase): Observable<CorrelativeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorrelativeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorrelativeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<CorrelativeDto> {
        let url_ = this.baseUrl + "/api/services/app/Correlative/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorrelativeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorrelativeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CorrelativeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorrelativeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorrelativeDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CorrelativeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Correlative/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorrelativeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorrelativeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CorrelativeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorrelativeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorrelativeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CorrelativeDto | undefined): Observable<CorrelativeDto> {
        let url_ = this.baseUrl + "/api/services/app/Correlative/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorrelativeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorrelativeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CorrelativeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorrelativeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorrelativeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CorrelativeDto | undefined): Observable<CorrelativeDto> {
        let url_ = this.baseUrl + "/api/services/app/Correlative/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorrelativeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorrelativeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CorrelativeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorrelativeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorrelativeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Correlative/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CostCenterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCostCenterDto | undefined): Observable<CostCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CostCenterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCostCenterDto | undefined): Observable<CostCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CostCenterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param isInvestment (optional) 
     * @param isDistributable (optional) 
     * @param costCentersId (optional) 
     * @param costCenterTypesId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, farmId: string, isInvestment: boolean | null | undefined, isDistributable: boolean | null | undefined, costCentersId: string[] | null | undefined, costCenterTypesId: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CostCenterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (isInvestment !== undefined && isInvestment !== null)
            url_ += "IsInvestment=" + encodeURIComponent("" + isInvestment) + "&";
        if (isDistributable !== undefined && isDistributable !== null)
            url_ += "IsDistributable=" + encodeURIComponent("" + isDistributable) + "&";
        if (costCentersId !== undefined && costCentersId !== null)
            costCentersId && costCentersId.forEach(item => { url_ += "CostCentersId=" + encodeURIComponent("" + item) + "&"; });
        if (costCenterTypesId !== undefined && costCenterTypesId !== null)
            costCenterTypesId && costCenterTypesId.forEach(item => { url_ += "CostCenterTypesId=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CostCenterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<CostCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CostCenterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllCostCenterBussinesLine(): Observable<BussinesLineDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/GetAllCostCenterBussinesLine";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCostCenterBussinesLine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCostCenterBussinesLine(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BussinesLineDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BussinesLineDtoPagedResultDto>;
        }));
    }

    protected processGetAllCostCenterBussinesLine(response: HttpResponseBase): Observable<BussinesLineDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BussinesLineDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BussinesLineDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllCostCenterStage(): Observable<StageDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/GetAllCostCenterStage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCostCenterStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCostCenterStage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StageDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StageDtoPagedResultDto>;
        }));
    }

    protected processGetAllCostCenterStage(response: HttpResponseBase): Observable<StageDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StageDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StageDtoPagedResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getCostCentersFilter(): Observable<CostCenterFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenter/GetCostCentersFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCostCentersFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCostCentersFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterFilterDtoPagedResultDto>;
        }));
    }

    protected processGetCostCentersFilter(response: HttpResponseBase): Observable<CostCenterFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterFilterDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class CostCenterTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCostCenterTypeDto | undefined): Observable<CostCenterTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenterType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CostCenterTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateCostCenterTypeDto | undefined): Observable<CostCenterTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenterType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CostCenterTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CostCenterTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenterType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CostCenterTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CostCenterType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<CostCenterTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenterType/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CostCenterTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getCostCenterTypesFilter(): Observable<CostCenterTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenterType/GetCostCenterTypesFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCostCenterTypesFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCostCenterTypesFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CostCenterTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CostCenterTypeDtoPagedResultDto>;
        }));
    }

    protected processGetCostCenterTypesFilter(response: HttpResponseBase): Observable<CostCenterTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CostCenterTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CostCenterTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCountryDto | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateCountryDto | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<CountryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CountryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class CurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCurrencyDto | undefined): Observable<CurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateCurrencyDto | undefined): Observable<CurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CurrencyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CurrencyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class DepartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param companyId (optional) 
     * @return Success
     */
    getDepartmentsFilter(companyId: string | null | undefined): Observable<DepartmentFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/GetDepartmentsFilter?";
        if (companyId !== undefined && companyId !== null)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentsFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentsFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentFilterDtoPagedResultDto>;
        }));
    }

    protected processGetDepartmentsFilter(response: HttpResponseBase): Observable<DepartmentFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentFilterDtoPagedResultDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param departmentsId (optional) 
     * @param supervisorsId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, departmentsId: string[] | null | undefined, supervisorsId: string[] | null | undefined, companyId: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DepartmentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (departmentsId !== undefined && departmentsId !== null)
            departmentsId && departmentsId.forEach(item => { url_ += "DepartmentsId=" + encodeURIComponent("" + item) + "&"; });
        if (supervisorsId !== undefined && supervisorsId !== null)
            supervisorsId && supervisorsId.forEach(item => { url_ += "SupervisorsId=" + encodeURIComponent("" + item) + "&"; });
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined and cannot be null.");
        else
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DepartmentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDepartmentDto | undefined): Observable<DepartmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Department/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Department/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<DepartmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDepartmentDto | undefined): Observable<DepartmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Department/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DepartmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentDto>(null as any);
    }
}

@Injectable()
export class DocumentStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDocumentStatusDto | undefined): Observable<DocumentStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatus/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentStatusDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DocumentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentStatusDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDocumentStatusDto | undefined): Observable<DocumentStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatus/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentStatusDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DocumentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentStatusDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatus/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<DocumentStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatus/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentStatusDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DocumentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentStatusDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DocumentStatusDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentStatus/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentStatusDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentStatusDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DocumentStatusDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentStatusDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentStatusDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class DriverLicenseInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<DriverLicenseInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenseInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenseInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DriverLicenseInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenseInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLicenseInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDriverLicenseInfoDto | undefined): Observable<DriverLicenseInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenseInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenseInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DriverLicenseInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenseInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLicenseInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<DriverLicenseInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenseInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenseInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DriverLicenseInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenseInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLicenseInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDriverLicenseInfoDto | undefined): Observable<DriverLicenseInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenseInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenseInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DriverLicenseInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenseInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLicenseInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DriverLicenseTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDriverLicenseTypeDto | undefined): Observable<DriverLicenceTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenceTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenceTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DriverLicenceTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenceTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLicenceTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDriverLicenseTypeDto | undefined): Observable<DriverLicenceTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenceTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenceTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DriverLicenceTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenceTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLicenceTypeDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DriverLicenceTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenceTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenceTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DriverLicenceTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenceTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLicenceTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DriverLicenceTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenceTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenceTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DriverLicenceTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenceTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DriverLicenceTypeDto>(null as any);
    }
}

@Injectable()
export class EconomicActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EconomicActivity/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateEconomicActivityInput | undefined): Observable<EconomicActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/EconomicActivity/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EconomicActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EconomicActivityDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EconomicActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EconomicActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EconomicActivityDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEconomicActivityInput | undefined): Observable<EconomicActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/EconomicActivity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EconomicActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EconomicActivityDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EconomicActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EconomicActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EconomicActivityDto>(null as any);
    }

    /**
     * @param businessAreaId (optional) 
     * @param countryCode (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(businessAreaId: number | null | undefined, countryCode: string | null | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<EconomicActivityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EconomicActivity/GetAll?";
        if (businessAreaId !== undefined && businessAreaId !== null)
            url_ += "BusinessAreaId=" + encodeURIComponent("" + businessAreaId) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EconomicActivityDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EconomicActivityDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EconomicActivityDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EconomicActivityDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EconomicActivityDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<EconomicActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/EconomicActivity/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EconomicActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EconomicActivityDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EconomicActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EconomicActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EconomicActivityDto>(null as any);
    }
}

@Injectable()
export class EntranceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<EntranceDto> {
        let url_ = this.baseUrl + "/api/services/app/Entrance/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntranceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntranceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EntranceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntranceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntranceDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(farmId: string, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<EntranceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Entrance/GetAll?";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntranceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntranceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EntranceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntranceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntranceDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateEntranceDto | undefined): Observable<EntranceDto> {
        let url_ = this.baseUrl + "/api/services/app/Entrance/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntranceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntranceDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EntranceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntranceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntranceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEntranceDto | undefined): Observable<EntranceDto> {
        let url_ = this.baseUrl + "/api/services/app/Entrance/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntranceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntranceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EntranceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntranceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntranceDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Entrance/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FamilyDependentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateFamilyDependentDto | undefined): Observable<FamilyDependentDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependent/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FamilyDependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateFamilyDependentDto | undefined): Observable<FamilyDependentDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependent/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FamilyDependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<FamilyDependentDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependent/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FamilyDependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependent/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<FamilyDependentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependent/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FamilyDependentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class FamilyDependentInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<FamilyDependentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FamilyDependentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<FamilyDependentInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FamilyDependentInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateFamilyDependentInfoDto | undefined): Observable<FamilyDependentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FamilyDependentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateFamilyDependentInfoDto | undefined): Observable<FamilyDependentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FamilyDependentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FamilyDependentTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateFamilyDependentTypeDto | undefined): Observable<FamilyDependentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FamilyDependentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateFamilyDependentTypeDto | undefined): Observable<FamilyDependentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FamilyDependentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentTypeDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FamilyDependentTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentType/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FamilyDependentTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<FamilyDependentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilyDependentType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilyDependentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilyDependentTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FamilyDependentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilyDependentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilyDependentTypeDto>(null as any);
    }
}

@Injectable()
export class FamilySectionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<FamilySectionDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilySection/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilySectionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilySectionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FamilySectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilySectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilySectionDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FamilySectionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilySection/GetAll?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilySectionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilySectionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FamilySectionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilySectionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilySectionDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: FamilySectionDto | undefined): Observable<FamilySectionDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilySection/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilySectionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilySectionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FamilySectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilySectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilySectionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: FamilySectionDto | undefined): Observable<FamilySectionDto> {
        let url_ = this.baseUrl + "/api/services/app/FamilySection/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FamilySectionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FamilySectionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FamilySectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FamilySectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FamilySectionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FamilySection/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FarmServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateFarmDto | undefined): Observable<FarmDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FarmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param farmsId (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(companyId: string, keyword: string | null | undefined, farmsId: string[] | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FarmDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/GetAll?";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined and cannot be null.");
        else
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (farmsId !== undefined && farmsId !== null)
            farmsId && farmsId.forEach(item => { url_ += "FarmsId=" + encodeURIComponent("" + item) + "&"; });
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FarmDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmDtoPagedResultDto>(null as any);
    }

    /**
     * @param companyId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSimple(companyId: string | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FarmSimpleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/GetAllSimple?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSimple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSimple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmSimpleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmSimpleDtoPagedResultDto>;
        }));
    }

    protected processGetAllSimple(response: HttpResponseBase): Observable<FarmSimpleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmSimpleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmSimpleDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllByUserId(id: number | undefined): Observable<FarmDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/GetAllByUserId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmDtoPagedResultDto>;
        }));
    }

    protected processGetAllByUserId(response: HttpResponseBase): Observable<FarmDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<FarmDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FarmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Farm/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Farm/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAddressContactInfo(body: UpdateFarmContactDto | undefined): Observable<FarmDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/UpdateAddressContactInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAddressContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAddressContactInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmDto>;
        }));
    }

    protected processUpdateAddressContactInfo(response: HttpResponseBase): Observable<FarmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMainInfo(body: UpdateFarmMainDto | undefined): Observable<FarmDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/UpdateMainInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMainInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMainInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmDto>;
        }));
    }

    protected processUpdateMainInfo(response: HttpResponseBase): Observable<FarmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMainInfo(id: string | undefined): Observable<FarmMainDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/GetMainInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMainInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMainInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmMainDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmMainDto>;
        }));
    }

    protected processGetMainInfo(response: HttpResponseBase): Observable<FarmMainDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmMainDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmMainDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAddressContactInfo(id: string | undefined): Observable<FarmContactDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/GetAddressContactInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressContactInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmContactDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmContactDto>;
        }));
    }

    protected processGetAddressContactInfo(response: HttpResponseBase): Observable<FarmContactDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmContactDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmContactDto>(null as any);
    }

    /**
     * @param companyId (optional) 
     * @return Success
     */
    getFarmsFilter(companyId: string | null | undefined): Observable<FarmFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/GetFarmsFilter?";
        if (companyId !== undefined && companyId !== null)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFarmsFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFarmsFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmFilterDtoPagedResultDto>;
        }));
    }

    protected processGetFarmsFilter(response: HttpResponseBase): Observable<FarmFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmFilterDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateFarmDto | undefined): Observable<FarmDto> {
        let url_ = this.baseUrl + "/api/services/app/Farm/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FarmDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FarmDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FarmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FarmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FarmDto>(null as any);
    }
}

@Injectable()
export class FeatureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateFeatureDto | undefined): Observable<FeatureDto> {
        let url_ = this.baseUrl + "/api/services/app/Feature/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeatureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeatureDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FeatureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeatureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeatureDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateFeatureDto | undefined): Observable<FeatureDto> {
        let url_ = this.baseUrl + "/api/services/app/Feature/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeatureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeatureDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FeatureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeatureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeatureDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Feature/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<FeatureDto> {
        let url_ = this.baseUrl + "/api/services/app/Feature/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeatureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeatureDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FeatureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeatureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeatureDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, mainProductId: number, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<FeatureDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Feature/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (mainProductId === undefined || mainProductId === null)
            throw new Error("The parameter 'mainProductId' must be defined and cannot be null.");
        else
            url_ += "MainProductId=" + encodeURIComponent("" + mainProductId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeatureDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeatureDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FeatureDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeatureDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FeatureDtoPagedResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Feature/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllModulePermissions(id: string | undefined): Observable<ModulePermissionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Feature/GetAllModulePermissions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModulePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModulePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModulePermissionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModulePermissionDtoPagedResultDto>;
        }));
    }

    protected processGetAllModulePermissions(response: HttpResponseBase): Observable<ModulePermissionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModulePermissionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModulePermissionDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class GenreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateGenreDto | undefined): Observable<GenreDto> {
        let url_ = this.baseUrl + "/api/services/app/Genre/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GenreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GenreDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Genre/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateGenreDto | undefined): Observable<GenreDto> {
        let url_ = this.baseUrl + "/api/services/app/Genre/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GenreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GenreDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<GenreDto> {
        let url_ = this.baseUrl + "/api/services/app/Genre/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GenreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GenreDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<GenreDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Genre/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GenreDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenreDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GenreDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class HealthAgreementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateHealthAgreementDto | undefined): Observable<HealthAgreementDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthAgreement/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthAgreementDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthAgreementDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HealthAgreementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthAgreementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthAgreementDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HealthAgreement/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateHealthAgreementDto | undefined): Observable<HealthAgreementDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthAgreement/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthAgreementDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthAgreementDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HealthAgreementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthAgreementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthAgreementDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<HealthAgreementDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthAgreement/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthAgreementDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthAgreementDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HealthAgreementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthAgreementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthAgreementDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HealthAgreementDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthAgreement/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthAgreementDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthAgreementDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HealthAgreementDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthAgreementDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthAgreementDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class HealthInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<HealthInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HealthInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<HealthInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HealthInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateHealthInfoDto | undefined): Observable<HealthInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HealthInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateHealthInfoDto | undefined): Observable<HealthInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HealthInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HealthInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class HealthInstitutionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateHealthInstitutionDto | undefined): Observable<HealthInstitutionDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthInstitution/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthInstitutionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthInstitutionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HealthInstitutionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthInstitutionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthInstitutionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HealthInstitution/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<HealthInstitutionDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthInstitution/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthInstitutionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthInstitutionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HealthInstitutionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthInstitutionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthInstitutionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateHealthInstitutionDto | undefined): Observable<HealthInstitutionDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthInstitution/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthInstitutionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthInstitutionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HealthInstitutionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthInstitutionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthInstitutionDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HealthInstitutionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HealthInstitution/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthInstitutionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthInstitutionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HealthInstitutionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthInstitutionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthInstitutionDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class HeavyweightWorkTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<HeavyweightWorkTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/HeavyweightWorkType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HeavyweightWorkTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HeavyweightWorkTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HeavyweightWorkTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HeavyweightWorkTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeavyweightWorkTypeDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HeavyweightWorkTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HeavyweightWorkType/GetAll?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HeavyweightWorkTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HeavyweightWorkTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HeavyweightWorkTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HeavyweightWorkTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeavyweightWorkTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: HeavyweightWorkTypeDto | undefined): Observable<HeavyweightWorkTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/HeavyweightWorkType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HeavyweightWorkTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HeavyweightWorkTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HeavyweightWorkTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HeavyweightWorkTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeavyweightWorkTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: HeavyweightWorkTypeDto | undefined): Observable<HeavyweightWorkTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/HeavyweightWorkType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HeavyweightWorkTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HeavyweightWorkTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HeavyweightWorkTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HeavyweightWorkTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeavyweightWorkTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HeavyweightWorkType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class IdentificationTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<IdentificationTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/IdentificationType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentificationTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentificationTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IdentificationTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentificationTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentificationTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<IdentificationTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/IdentificationType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentificationTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentificationTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IdentificationTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentificationTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentificationTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: IdentificationTypeDto | undefined): Observable<IdentificationTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/IdentificationType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentificationTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentificationTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IdentificationTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentificationTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentificationTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: IdentificationTypeDto | undefined): Observable<IdentificationTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/IdentificationType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentificationTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentificationTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IdentificationTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentificationTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentificationTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IdentificationType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class InsertMethodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<InsertMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/InsertMethod/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertMethodDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InsertMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertMethodDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<InsertMethodDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/InsertMethod/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertMethodDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertMethodDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<InsertMethodDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertMethodDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertMethodDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: InsertMethodDto | undefined): Observable<InsertMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/InsertMethod/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertMethodDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<InsertMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertMethodDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: InsertMethodDto | undefined): Observable<InsertMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/InsertMethod/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertMethodDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InsertMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertMethodDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InsertMethod/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class InstitutionTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateInstitutionTypeDto | undefined): Observable<InstitutionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/InstitutionType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<InstitutionTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateInstitutionTypeDto | undefined): Observable<InstitutionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/InstitutionType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InstitutionTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<InstitutionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/InstitutionType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InstitutionTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InstitutionType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<InstitutionTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/InstitutionType/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<InstitutionTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class JobTitleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateJobTitleDto | undefined): Observable<JobTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobTitleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobTitleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<JobTitleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobTitleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobTitleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateJobTitleDto | undefined): Observable<JobTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobTitleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobTitleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<JobTitleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobTitleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobTitleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<JobTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobTitleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobTitleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobTitleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobTitleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobTitleDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param jobtitlesId (optional) 
     * @param supervisorsId (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, companyId: string, jobtitlesId: string[] | null | undefined, supervisorsId: string[] | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<JobTitleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined and cannot be null.");
        else
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (jobtitlesId !== undefined && jobtitlesId !== null)
            jobtitlesId && jobtitlesId.forEach(item => { url_ += "JobtitlesId=" + encodeURIComponent("" + item) + "&"; });
        if (supervisorsId !== undefined && supervisorsId !== null)
            supervisorsId && supervisorsId.forEach(item => { url_ += "SupervisorsId=" + encodeURIComponent("" + item) + "&"; });
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobTitleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobTitleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<JobTitleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobTitleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobTitleDtoPagedResultDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param jobtitlesId (optional) 
     * @param supervisorsId (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTennant(keyword: string | null | undefined, companyId: string, jobtitlesId: string[] | null | undefined, supervisorsId: string[] | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<JobTitleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetAllTennant?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined and cannot be null.");
        else
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (jobtitlesId !== undefined && jobtitlesId !== null)
            jobtitlesId && jobtitlesId.forEach(item => { url_ += "JobtitlesId=" + encodeURIComponent("" + item) + "&"; });
        if (supervisorsId !== undefined && supervisorsId !== null)
            supervisorsId && supervisorsId.forEach(item => { url_ += "SupervisorsId=" + encodeURIComponent("" + item) + "&"; });
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTennant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTennant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobTitleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobTitleDtoPagedResultDto>;
        }));
    }

    protected processGetAllTennant(response: HttpResponseBase): Observable<JobTitleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobTitleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobTitleDtoPagedResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LaborServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLaborDto | undefined): Observable<LaborDto> {
        let url_ = this.baseUrl + "/api/services/app/Labor/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LaborDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LaborDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LaborDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LaborDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LaborDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLaborDto | undefined): Observable<LaborDto> {
        let url_ = this.baseUrl + "/api/services/app/Labor/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LaborDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LaborDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LaborDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LaborDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LaborDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Labor/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param laborsId (optional) 
     * @param activity (optional) 
     * @param farmIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, laborsId: string[] | null | undefined, activity: string | null | undefined, farmIds: string[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LaborDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Labor/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (laborsId !== undefined && laborsId !== null)
            laborsId && laborsId.forEach(item => { url_ += "LaborsId=" + encodeURIComponent("" + item) + "&"; });
        if (activity !== undefined && activity !== null)
            url_ += "Activity=" + encodeURIComponent("" + activity) + "&";
        if (farmIds !== undefined && farmIds !== null)
            farmIds && farmIds.forEach(item => { url_ += "FarmIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LaborDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LaborDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LaborDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LaborDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LaborDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<LaborDto> {
        let url_ = this.baseUrl + "/api/services/app/Labor/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LaborDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LaborDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LaborDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LaborDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LaborDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Labor/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LegalRepresentativeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLegalRepresentativeDto | undefined): Observable<LegalRepresentativeDto> {
        let url_ = this.baseUrl + "/api/services/app/LegalRepresentative/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalRepresentativeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalRepresentativeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LegalRepresentativeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LegalRepresentativeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LegalRepresentativeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateLegalRepresentativeDto | undefined): Observable<LegalRepresentativeDto> {
        let url_ = this.baseUrl + "/api/services/app/LegalRepresentative/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalRepresentativeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalRepresentativeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LegalRepresentativeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LegalRepresentativeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LegalRepresentativeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<LegalRepresentativeDto> {
        let url_ = this.baseUrl + "/api/services/app/LegalRepresentative/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalRepresentativeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalRepresentativeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LegalRepresentativeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LegalRepresentativeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LegalRepresentativeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LegalRepresentative/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined): Observable<LegalRepresentativeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LegalRepresentative/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalRepresentativeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalRepresentativeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LegalRepresentativeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LegalRepresentativeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LegalRepresentativeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class MacroActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMacroActivityDto | undefined): Observable<MacroActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/MacroActivity/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MacroActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MacroActivityDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MacroActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MacroActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MacroActivityDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMacroActivityDto | undefined): Observable<MacroActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/MacroActivity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MacroActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MacroActivityDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MacroActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MacroActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MacroActivityDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MacroActivity/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param macroActivitiesId (optional) 
     * @param activitiesId (optional) 
     * @param farmIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, macroActivitiesId: string[] | null | undefined, activitiesId: string[] | null | undefined, farmIds: string[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MacroActivityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MacroActivity/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (macroActivitiesId !== undefined && macroActivitiesId !== null)
            macroActivitiesId && macroActivitiesId.forEach(item => { url_ += "MacroActivitiesId=" + encodeURIComponent("" + item) + "&"; });
        if (activitiesId !== undefined && activitiesId !== null)
            activitiesId && activitiesId.forEach(item => { url_ += "ActivitiesId=" + encodeURIComponent("" + item) + "&"; });
        if (farmIds !== undefined && farmIds !== null)
            farmIds && farmIds.forEach(item => { url_ += "FarmIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MacroActivityDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MacroActivityDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MacroActivityDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MacroActivityDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MacroActivityDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<MacroActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/MacroActivity/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MacroActivityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MacroActivityDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MacroActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MacroActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MacroActivityDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MacroActivity/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MainProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllByTenant(): Observable<MainProductDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MainProduct/GetAllByTenant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainProductDto[]>;
        }));
    }

    protected processGetAllByTenant(response: HttpResponseBase): Observable<MainProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MainProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainProductDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<MainProductDto> {
        let url_ = this.baseUrl + "/api/services/app/MainProduct/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainProductDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MainProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainProductDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<MainProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MainProduct/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainProductDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainProductDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MainProductDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainProductDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainProductDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMainProductDto | undefined): Observable<MainProductDto> {
        let url_ = this.baseUrl + "/api/services/app/MainProduct/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainProductDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MainProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainProductDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMainProductDto | undefined): Observable<MainProductDto> {
        let url_ = this.baseUrl + "/api/services/app/MainProduct/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainProductDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MainProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainProductDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MainProduct/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MaritalStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMaritalStatusDto | undefined): Observable<MaritalStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/MaritalStatus/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaritalStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaritalStatusDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MaritalStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaritalStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaritalStatusDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaritalStatus/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<MaritalStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/MaritalStatus/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaritalStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaritalStatusDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MaritalStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaritalStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaritalStatusDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMaritalStatusDto | undefined): Observable<MaritalStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/MaritalStatus/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaritalStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaritalStatusDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MaritalStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaritalStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaritalStatusDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<MaritalStatusDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MaritalStatus/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaritalStatusDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaritalStatusDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MaritalStatusDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaritalStatusDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaritalStatusDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class MeasureUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMeasureUnitDto | undefined): Observable<MeasureUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/MeasureUnit/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeasureUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeasureUnitDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MeasureUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeasureUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MeasureUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateMeasureUnitDto | undefined): Observable<MeasureUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/MeasureUnit/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeasureUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeasureUnitDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MeasureUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeasureUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MeasureUnitDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<MeasureUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/MeasureUnit/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeasureUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeasureUnitDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MeasureUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeasureUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MeasureUnitDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MeasureUnit/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<MeasureUnitDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MeasureUnit/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeasureUnitDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeasureUnitDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MeasureUnitDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeasureUnitDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MeasureUnitDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ModuleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateModuleDto | undefined): Observable<ModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateModuleDto | undefined): Observable<ModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePermission(body: UpdatePermissionModuleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Module/UpdatePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Module/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, featureId: string, isActive: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ModuleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (featureId === undefined || featureId === null)
            throw new Error("The parameter 'featureId' must be defined and cannot be null.");
        else
            url_ += "FeatureId=" + encodeURIComponent("" + featureId) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ModuleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ModuleDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ModuleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllRequiredModule(id: string | undefined): Observable<ModuleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetAllRequiredModule?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRequiredModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRequiredModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleDtoPagedResultDto>;
        }));
    }

    protected processGetAllRequiredModule(response: HttpResponseBase): Observable<ModuleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllModulePermissions(id: string | undefined): Observable<ModulePermissionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetAllModulePermissions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModulePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModulePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModulePermissionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModulePermissionDtoPagedResultDto>;
        }));
    }

    protected processGetAllModulePermissions(response: HttpResponseBase): Observable<ModulePermissionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModulePermissionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModulePermissionDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllModulePaths(id: string | undefined): Observable<PathDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetAllModulePaths?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModulePaths(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModulePaths(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PathDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PathDtoPagedResultDto>;
        }));
    }

    protected processGetAllModulePaths(response: HttpResponseBase): Observable<PathDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PathDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PathDtoPagedResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Module/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getModulesSimple(): Observable<ModuleSimpleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetModulesSimple";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModulesSimple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModulesSimple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleSimpleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleSimpleDtoPagedResultDto>;
        }));
    }

    protected processGetModulesSimple(response: HttpResponseBase): Observable<ModuleSimpleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleSimpleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleSimpleDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class NoticeTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateNoticeTypeAccountTypeDto | undefined): Observable<NoticeTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/NoticeType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<NoticeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateNoticeTypeAccountTypeDto | undefined): Observable<NoticeTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/NoticeType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<NoticeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NoticeType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<NoticeTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/NoticeType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<NoticeTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeTypeDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<NoticeTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NoticeType/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NoticeTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoticeTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoticeTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class PathServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePathDto | undefined): Observable<PathDto> {
        let url_ = this.baseUrl + "/api/services/app/Path/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PathDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PathDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PathDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PathDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PathDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Path/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: GuidEntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Path/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePathDto | undefined): Observable<PathDto> {
        let url_ = this.baseUrl + "/api/services/app/Path/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PathDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PathDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PathDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PathDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PathDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PathDto> {
        let url_ = this.baseUrl + "/api/services/app/Path/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PathDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PathDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PathDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PathDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PathDto>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(moduleId: string, isActive: boolean | null | undefined, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PathDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Path/GetAll?";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined and cannot be null.");
        else
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PathDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PathDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PathDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PathDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PathDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyParent(id: string | undefined): Observable<PathDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Path/GetbyParent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyParent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyParent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PathDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PathDtoPagedResultDto>;
        }));
    }

    protected processGetbyParent(response: HttpResponseBase): Observable<PathDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PathDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PathDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class PaymentConceptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePaymentConceptDto | undefined): Observable<PaymentConceptDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentConcept/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentConceptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentConceptDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PaymentConceptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentConceptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentConceptDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentConcept/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PaymentConceptDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentConcept/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentConceptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentConceptDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentConceptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentConceptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentConceptDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePaymentConceptDto | undefined): Observable<PaymentConceptDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentConcept/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentConceptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentConceptDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaymentConceptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentConceptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentConceptDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PaymentConceptDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentConcept/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentConceptDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentConceptDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaymentConceptDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentConceptDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentConceptDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class PaymentMethodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePaymentMethodAccountTypeDto | undefined): Observable<PaymentMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentMethodDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PaymentMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMethodDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreatePaymentMethodAccountTypeDto | undefined): Observable<PaymentMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentMethodDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaymentMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMethodDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PaymentMethodDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentMethodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentMethodDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentMethodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMethodDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<PaymentMethodDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentMethod/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentMethodDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentMethodDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaymentMethodDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethodDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMethodDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class PaymentTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<PaymentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentTypeDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PaymentTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentType/GetAll?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaymentTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: PaymentTypeDto | undefined): Observable<PaymentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PaymentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PaymentTypeDto | undefined): Observable<PaymentTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaymentTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PayrollConceptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePayrollConceptDto | undefined): Observable<PayrollConceptDto> {
        let url_ = this.baseUrl + "/api/services/app/PayrollConcept/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayrollConceptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayrollConceptDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PayrollConceptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollConceptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollConceptDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayrollConcept/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayrollConcept/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param payrollConceptsId (optional) 
     * @param payrollConceptTypesId (optional) 
     * @param payrollConceptCalculationMethodsId (optional) 
     * @param currenciesId (optional) 
     * @param payrollConceptPeriodicitiesId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, payrollConceptsId: string[] | null | undefined, payrollConceptTypesId: number[] | null | undefined, payrollConceptCalculationMethodsId: number[] | null | undefined, currenciesId: number[] | null | undefined, payrollConceptPeriodicitiesId: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PayrollConceptDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PayrollConcept/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (payrollConceptsId !== undefined && payrollConceptsId !== null)
            payrollConceptsId && payrollConceptsId.forEach(item => { url_ += "PayrollConceptsId=" + encodeURIComponent("" + item) + "&"; });
        if (payrollConceptTypesId !== undefined && payrollConceptTypesId !== null)
            payrollConceptTypesId && payrollConceptTypesId.forEach(item => { url_ += "PayrollConceptTypesId=" + encodeURIComponent("" + item) + "&"; });
        if (payrollConceptCalculationMethodsId !== undefined && payrollConceptCalculationMethodsId !== null)
            payrollConceptCalculationMethodsId && payrollConceptCalculationMethodsId.forEach(item => { url_ += "PayrollConceptCalculationMethodsId=" + encodeURIComponent("" + item) + "&"; });
        if (currenciesId !== undefined && currenciesId !== null)
            currenciesId && currenciesId.forEach(item => { url_ += "CurrenciesId=" + encodeURIComponent("" + item) + "&"; });
        if (payrollConceptPeriodicitiesId !== undefined && payrollConceptPeriodicitiesId !== null)
            payrollConceptPeriodicitiesId && payrollConceptPeriodicitiesId.forEach(item => { url_ += "PayrollConceptPeriodicitiesId=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayrollConceptDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayrollConceptDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PayrollConceptDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollConceptDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollConceptDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PayrollConceptDto> {
        let url_ = this.baseUrl + "/api/services/app/PayrollConcept/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayrollConceptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayrollConceptDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PayrollConceptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollConceptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollConceptDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePayrollConceptDto | undefined): Observable<PayrollConceptDto> {
        let url_ = this.baseUrl + "/api/services/app/PayrollConcept/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayrollConceptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayrollConceptDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PayrollConceptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollConceptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollConceptDto>(null as any);
    }

    /**
     * @return Success
     */
    getPayrollConceptsFilter(): Observable<PayrollConceptFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PayrollConcept/GetPayrollConceptsFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayrollConceptsFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayrollConceptsFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayrollConceptFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayrollConceptFilterDtoPagedResultDto>;
        }));
    }

    protected processGetPayrollConceptsFilter(response: HttpResponseBase): Observable<PayrollConceptFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayrollConceptFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayrollConceptFilterDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProductDto | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateProductDto | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ProductCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProductCategoryDto | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateProductCategoryDto | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductCategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductCategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllByTennant(): Observable<ProductCategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetAllByTennant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByTennant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByTennant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryDtoPagedResultDto>;
        }));
    }

    protected processGetAllByTennant(response: HttpResponseBase): Observable<ProductCategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ProductCategoryHoldingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProductCategoryHoldingDto | undefined): Observable<ProductCategoryHoldingDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategoryHolding/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryHoldingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryHoldingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductCategoryHoldingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryHoldingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryHoldingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateProductCategoryHoldingDto | undefined): Observable<ProductCategoryHoldingDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategoryHolding/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryHoldingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryHoldingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductCategoryHoldingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryHoldingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryHoldingDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategoryHolding/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ProductCategoryHoldingDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategoryHolding/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryHoldingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryHoldingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductCategoryHoldingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryHoldingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryHoldingDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductCategoryHoldingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategoryHolding/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryHoldingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryHoldingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductCategoryHoldingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryHoldingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryHoldingDtoPagedResultDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAllTennant(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductCategoryHoldingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategoryHolding/GetAllTennant?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTennant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTennant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCategoryHoldingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCategoryHoldingDtoPagedResultDto>;
        }));
    }

    protected processGetAllTennant(response: HttpResponseBase): Observable<ProductCategoryHoldingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryHoldingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryHoldingDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    associateCategoriesToHolding(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategoryHolding/AssociateCategoriesToHolding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssociateCategoriesToHolding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssociateCategoriesToHolding(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssociateCategoriesToHolding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ProductClassificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProductClassificationTypeDto | undefined): Observable<ProductClassificationDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductClassification/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductClassificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductClassificationDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductClassificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassificationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateProductClassificationTypeDto | undefined): Observable<ProductClassificationDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductClassification/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductClassificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductClassificationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductClassificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassificationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ProductClassificationDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductClassification/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductClassificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductClassificationDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductClassificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassificationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductClassification/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductClassificationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductClassification/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductClassificationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductClassificationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductClassificationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassificationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassificationDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ProductFamilyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProductFamilyDto | undefined): Observable<ProductFamilyDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamily/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductFamilyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateProductFamilyDto | undefined): Observable<ProductFamilyDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamily/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductFamilyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamily/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ProductFamilyDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamily/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductFamilyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductFamilyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamily/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductFamilyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllByTennant(): Observable<ProductFamilyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamily/GetAllByTennant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByTennant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByTennant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyDtoPagedResultDto>;
        }));
    }

    protected processGetAllByTennant(response: HttpResponseBase): Observable<ProductFamilyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    associateHolding(body: string[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamily/AssociateHolding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssociateHolding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssociateHolding(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAssociateHolding(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCompanies(id: string | undefined): Observable<SimpleCompanyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamily/GetCompanies?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleCompanyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleCompanyDto[]>;
        }));
    }

    protected processGetCompanies(response: HttpResponseBase): Observable<SimpleCompanyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SimpleCompanyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleCompanyDto[]>(null as any);
    }
}

@Injectable()
export class ProductFamilyHoldingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProductFamilyHoldingDto | undefined): Observable<ProductFamilyHoldingDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamilyHolding/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyHoldingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyHoldingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductFamilyHoldingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyHoldingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyHoldingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateProductFamilyHoldingDto | undefined): Observable<ProductFamilyHoldingDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamilyHolding/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyHoldingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyHoldingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductFamilyHoldingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyHoldingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyHoldingDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamilyHolding/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ProductFamilyHoldingDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamilyHolding/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyHoldingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyHoldingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductFamilyHoldingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyHoldingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyHoldingDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductFamilyHoldingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamilyHolding/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyHoldingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyHoldingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductFamilyHoldingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyHoldingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyHoldingDtoPagedResultDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAllTennant(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductFamilyHoldingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamilyHolding/GetAllTennant?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTennant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTennant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFamilyHoldingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFamilyHoldingDtoPagedResultDto>;
        }));
    }

    protected processGetAllTennant(response: HttpResponseBase): Observable<ProductFamilyHoldingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFamilyHoldingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFamilyHoldingDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    associateFamiliesToHolding(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductFamilyHolding/AssociateFamiliesToHolding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssociateFamiliesToHolding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssociateFamiliesToHolding(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssociateFamiliesToHolding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ProductFeatureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProductFeatureTypeDto | undefined): Observable<ProductFeatureDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFeature/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFeatureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFeatureDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductFeatureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFeatureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFeatureDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateProductFeatureTypeDto | undefined): Observable<ProductFeatureDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFeature/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFeatureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFeatureDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductFeatureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFeatureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFeatureDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<ProductFeatureDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFeature/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFeatureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFeatureDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductFeatureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFeatureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFeatureDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductFeature/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductFeatureDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductFeature/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductFeatureDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductFeatureDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductFeatureDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFeatureDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductFeatureDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ProductStockServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateProductStockDto | undefined): Observable<ProductStockDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductStock/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStockDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductStockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductStockDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateProductStockDto | undefined): Observable<ProductStockDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductStock/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStockDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductStockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductStockDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductStock/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ProductStockDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductStock/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStockDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductStockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductStockDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<ProductStockDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductStock/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStockDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStockDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProductStockDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductStockDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class PurchaseDocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePurchaseDocumentDto | undefined): Observable<PurchaseDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PurchaseDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePurchaseDocumentDto | undefined): Observable<PurchaseDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PurchaseDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reopenAndUpdateDocumentStatus(body: ReopenDocumentStatusDto | undefined): Observable<PurchaseDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/ReopenAndUpdateDocumentStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReopenAndUpdateDocumentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReopenAndUpdateDocumentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDto>;
        }));
    }

    protected processReopenAndUpdateDocumentStatus(response: HttpResponseBase): Observable<PurchaseDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    closeAndUpdateDocumentStatus(body: ReopenDocumentStatusDto | undefined): Observable<PurchaseDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/CloseAndUpdateDocumentStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCloseAndUpdateDocumentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloseAndUpdateDocumentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDto>;
        }));
    }

    protected processCloseAndUpdateDocumentStatus(response: HttpResponseBase): Observable<PurchaseDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentStatus(body: UpdateLocalDocumentStatus | undefined): Observable<PurchaseDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/UpdateDocumentStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDto>;
        }));
    }

    protected processUpdateDocumentStatus(response: HttpResponseBase): Observable<PurchaseDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentForum(body: UpdatePurchaseDocumentForumDto | undefined): Observable<PurchaseDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/UpdateDocumentForum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentForum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentForum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDto>;
        }));
    }

    protected processUpdateDocumentForum(response: HttpResponseBase): Observable<PurchaseDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentProduct(body: UpdatePurchaseDocumentProductDto | undefined): Observable<PurchaseDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/UpdateDocumentProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDto>;
        }));
    }

    protected processUpdateDocumentProduct(response: HttpResponseBase): Observable<PurchaseDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSingleDocumentForum(body: UpdatePurchaseDocumentSingleForumDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/UpdateSingleDocumentForum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSingleDocumentForum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSingleDocumentForum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSingleDocumentForum(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentSingleProduct(body: UpdatePurchaseDocumentSingleProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/UpdateDocumentSingleProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentSingleProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentSingleProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDocumentSingleProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentForum(id: string | undefined): Observable<PurchaseDocumentForumDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/GetDocumentForum?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentForum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentForum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentForumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentForumDto>;
        }));
    }

    protected processGetDocumentForum(response: HttpResponseBase): Observable<PurchaseDocumentForumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentForumDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentForumDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentProduct(id: string | undefined): Observable<PurchaseDocumentProductDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/GetDocumentProduct?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentProductDto>;
        }));
    }

    protected processGetDocumentProduct(response: HttpResponseBase): Observable<PurchaseDocumentProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentProductDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentStatus(id: string | undefined): Observable<PurchaseDocumentStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/GetDocumentStatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentStatusDto>;
        }));
    }

    protected processGetDocumentStatus(response: HttpResponseBase): Observable<PurchaseDocumentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentStatusDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PurchaseDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurchaseDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param farmId (optional) 
     * @param stateId (optional) 
     * @param activeState (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, farmId: string | null | undefined, stateId: number | null | undefined, activeState: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PurchaseDocumentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocument/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (farmId !== undefined && farmId !== null)
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (stateId !== undefined && stateId !== null)
            url_ += "stateId=" + encodeURIComponent("" + stateId) + "&";
        if (activeState !== undefined && activeState !== null)
            url_ += "activeState=" + encodeURIComponent("" + activeState) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PurchaseDocumentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class PurchaseDocumentLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePurchaseDocumentLogDetailDto | undefined): Observable<PurchaseDocumentLogDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentLog/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentLogDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentLogDetailDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PurchaseDocumentLogDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentLogDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentLogDetailDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePurchaseDocumentLogDetailDto | undefined): Observable<PurchaseDocumentLogDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentLog/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentLogDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentLogDetailDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PurchaseDocumentLogDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentLogDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentLogDetailDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentLog/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PurchaseDocumentLogDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentLog/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentLogDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentLogDetailDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurchaseDocumentLogDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentLogDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentLogDetailDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PurchaseDocumentLogDetailDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentLog/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentLogDetailDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentLogDetailDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PurchaseDocumentLogDetailDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentLogDetailDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentLogDetailDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class PurchaseDocumentQuoteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePurchaseDocumentQuoteDto | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePurchaseDocumentQuoteDto | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reopenAndUpdateDocumentStatus(body: ReopenDocumentStatusDto | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/ReopenAndUpdateDocumentStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReopenAndUpdateDocumentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReopenAndUpdateDocumentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processReopenAndUpdateDocumentStatus(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    closeAndUpdateDocumentStatus(body: ReopenDocumentStatusDto | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/CloseAndUpdateDocumentStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCloseAndUpdateDocumentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloseAndUpdateDocumentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processCloseAndUpdateDocumentStatus(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentStatus(body: UpdateLocalDocumentStatus | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/UpdateDocumentStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processUpdateDocumentStatus(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentForum(body: UpdatePurchaseDocumentForumDto | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/UpdateDocumentForum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentForum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentForum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processUpdateDocumentForum(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentProduct(body: UpdatePurchaseDocumentProductDto | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/UpdateDocumentProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processUpdateDocumentProduct(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePurchaseDocumentSuppliers(body: UpdatePurchaseDocumentQuoteSuppliersDto | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/UpdatePurchaseDocumentSuppliers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePurchaseDocumentSuppliers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePurchaseDocumentSuppliers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processUpdatePurchaseDocumentSuppliers(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSingleDocumentForum(body: UpdatePurchaseDocumentSingleForumDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/UpdateSingleDocumentForum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSingleDocumentForum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSingleDocumentForum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSingleDocumentForum(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentSingleProduct(body: UpdatePurchaseDocumentSingleProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/UpdateDocumentSingleProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentSingleProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentSingleProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDocumentSingleProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentForum(id: string | undefined): Observable<PurchaseDocumentForumDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/GetDocumentForum?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentForum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentForum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentForumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentForumDto>;
        }));
    }

    protected processGetDocumentForum(response: HttpResponseBase): Observable<PurchaseDocumentForumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentForumDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentForumDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentProduct(id: string | undefined): Observable<PurchaseDocumentProductDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/GetDocumentProduct?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentProductDto>;
        }));
    }

    protected processGetDocumentProduct(response: HttpResponseBase): Observable<PurchaseDocumentProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentProductDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentStatus(id: string | undefined): Observable<PurchaseDocumentStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/GetDocumentStatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentStatusDto>;
        }));
    }

    protected processGetDocumentStatus(response: HttpResponseBase): Observable<PurchaseDocumentStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentStatusDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PurchaseDocumentQuoteDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param farmId (optional) 
     * @param stateId (optional) 
     * @param activeState (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, farmId: string | null | undefined, stateId: number | null | undefined, activeState: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PurchaseDocumentQuoteDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseDocumentQuote/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (farmId !== undefined && farmId !== null)
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (stateId !== undefined && stateId !== null)
            url_ += "stateId=" + encodeURIComponent("" + stateId) + "&";
        if (activeState !== undefined && activeState !== null)
            url_ += "activeState=" + encodeURIComponent("" + activeState) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseDocumentQuoteDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseDocumentQuoteDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PurchaseDocumentQuoteDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseDocumentQuoteDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseDocumentQuoteDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class RelationshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRelationshipDto | undefined): Observable<RelationshipDto> {
        let url_ = this.baseUrl + "/api/services/app/Relationship/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RelationshipDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RelationshipDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RelationshipDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RelationshipDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RelationshipDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Relationship/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RelationshipDto> {
        let url_ = this.baseUrl + "/api/services/app/Relationship/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RelationshipDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RelationshipDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RelationshipDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RelationshipDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RelationshipDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRelationshipDto | undefined): Observable<RelationshipDto> {
        let url_ = this.baseUrl + "/api/services/app/Relationship/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RelationshipDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RelationshipDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RelationshipDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RelationshipDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RelationshipDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RelationshipDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Relationship/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RelationshipDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RelationshipDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RelationshipDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RelationshipDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RelationshipDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class RetirementInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<RetirementInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RetirementInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<RetirementInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RetirementInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRetirementInfoDto | undefined): Observable<RetirementInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RetirementInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRetirementInfoDto | undefined): Observable<RetirementInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RetirementInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RetirementInstitutionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRetirementInstitutionDto | undefined): Observable<RetirementInstitutionDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInstitution/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementInstitutionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementInstitutionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RetirementInstitutionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementInstitutionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementInstitutionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInstitution/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RetirementInstitutionDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInstitution/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementInstitutionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementInstitutionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RetirementInstitutionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementInstitutionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementInstitutionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRetirementInstitutionDto | undefined): Observable<RetirementInstitutionDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInstitution/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementInstitutionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementInstitutionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RetirementInstitutionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementInstitutionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementInstitutionDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RetirementInstitutionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementInstitution/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementInstitutionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementInstitutionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RetirementInstitutionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementInstitutionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementInstitutionDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class RetirementRecordInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<RetirementRecordInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementRecordInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementRecordInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementRecordInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RetirementRecordInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementRecordInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementRecordInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<RetirementRecordInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementRecordInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementRecordInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementRecordInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RetirementRecordInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementRecordInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementRecordInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRetirementRecordInfoDto | undefined): Observable<RetirementRecordInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementRecordInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementRecordInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementRecordInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RetirementRecordInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementRecordInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementRecordInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRetirementRecordInfoDto | undefined): Observable<RetirementRecordInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementRecordInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementRecordInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementRecordInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RetirementRecordInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementRecordInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementRecordInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetirementRecordInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RetirementTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRetirementTypeDto | undefined): Observable<RetirementTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RetirementTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetirementType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RetirementTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RetirementTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRetirementTypeDto | undefined): Observable<RetirementTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RetirementTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementTypeDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RetirementTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RetirementType/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetirementTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetirementTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RetirementTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetirementTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetirementTypeDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined && permission !== null)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: Int32EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissionsByTenantFeatures(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissionsByTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionsByTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionsByTenantFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissionsByTenantFeatures(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isDeleted (optional) 
     * @param permissionNames (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isDeleted: boolean | null | undefined, permissionNames: string[] | null | undefined, mainProductId: number, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isDeleted !== undefined && isDeleted !== null)
            url_ += "IsDeleted=" + encodeURIComponent("" + isDeleted) + "&";
        if (permissionNames !== undefined && permissionNames !== null)
            permissionNames && permissionNames.forEach(item => { url_ += "PermissionNames=" + encodeURIComponent("" + item) + "&"; });
        if (mainProductId === undefined || mainProductId === null)
            throw new Error("The parameter 'mainProductId' must be defined and cannot be null.");
        else
            url_ += "MainProductId=" + encodeURIComponent("" + mainProductId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }
}

@Injectable()
export class RouteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<RouteDto> {
        let url_ = this.baseUrl + "/api/services/app/Route/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RouteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(companyId: string, farmId: string, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RouteDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Route/GetAll?";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined and cannot be null.");
        else
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RouteDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRouteDto | undefined): Observable<RouteDto> {
        let url_ = this.baseUrl + "/api/services/app/Route/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RouteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRouteDto | undefined): Observable<RouteDto> {
        let url_ = this.baseUrl + "/api/services/app/Route/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RouteDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RouteDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RouteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RouteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Route/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SalaryAllowanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SalaryAllowanceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryAllowance/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAllowanceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAllowanceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SalaryAllowanceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAllowanceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryAllowanceDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<SalaryAllowanceDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryAllowance/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAllowanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAllowanceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SalaryAllowanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAllowanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryAllowanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSalaryAllowanceDto | undefined): Observable<SalaryAllowanceDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryAllowance/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAllowanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAllowanceDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SalaryAllowanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAllowanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryAllowanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSalaryAllowanceDto | undefined): Observable<SalaryAllowanceDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryAllowance/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAllowanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAllowanceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SalaryAllowanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAllowanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryAllowanceDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalaryAllowance/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SalaryBonusTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SalaryBonusTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryBonusType/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryBonusTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryBonusTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SalaryBonusTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryBonusTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryBonusTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<SalaryBonusTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryBonusType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryBonusTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryBonusTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SalaryBonusTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryBonusTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryBonusTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSalaryBonusTypeDto | undefined): Observable<SalaryBonusTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryBonusType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryBonusTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryBonusTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SalaryBonusTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryBonusTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryBonusTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSalaryBonusTypeDto | undefined): Observable<SalaryBonusTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryBonusType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryBonusTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryBonusTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SalaryBonusTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryBonusTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryBonusTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalaryBonusType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SalaryStructureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(companyId: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SalaryStructureDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryStructure/GetAll?";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined and cannot be null.");
        else
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryStructureDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryStructureDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SalaryStructureDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryStructureDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryStructureDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<SalaryStructureDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryStructure/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryStructureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryStructureDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SalaryStructureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryStructureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryStructureDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSalaryStructureDto | undefined): Observable<SalaryStructureDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryStructure/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryStructureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryStructureDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SalaryStructureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryStructureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryStructureDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSalaryStructureDto | undefined): Observable<SalaryStructureDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryStructure/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryStructureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryStructureDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SalaryStructureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryStructureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryStructureDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalaryStructure/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SalaryTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(countryCode: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SalaryTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryType/GetAll?";
        if (countryCode === undefined || countryCode === null)
            throw new Error("The parameter 'countryCode' must be defined and cannot be null.");
        else
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SalaryTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<SalaryTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SalaryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSalaryTypeDto | undefined): Observable<SalaryTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SalaryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSalaryTypeDto | undefined): Observable<SalaryTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/SalaryType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SalaryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalaryTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalaryType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SalePriceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSalePriceDto | undefined): Observable<SalePriceDto> {
        let url_ = this.baseUrl + "/api/services/app/SalePrice/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalePriceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalePriceDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SalePriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalePriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalePriceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateSalePriceDto | undefined): Observable<SalePriceDto> {
        let url_ = this.baseUrl + "/api/services/app/SalePrice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalePriceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalePriceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SalePriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalePriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalePriceDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SalePrice/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<SalePriceDto> {
        let url_ = this.baseUrl + "/api/services/app/SalePrice/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalePriceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalePriceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SalePriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalePriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalePriceDto>(null as any);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getAll(productId: string | null | undefined): Observable<SalePriceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SalePrice/GetAll?";
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalePriceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalePriceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SalePriceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalePriceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalePriceDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class ScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ScheduleDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ScheduleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleDto>(null as any);
    }

    /**
     * @param date (optional) 
     * @param workerId (optional) 
     * @return Success
     */
    getAll(date: moment.Moment | null | undefined, workerId: string | null | undefined): Observable<ScheduleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/GetAll?";
        if (date !== undefined && date !== null)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (workerId !== undefined && workerId !== null)
            url_ += "WorkerId=" + encodeURIComponent("" + workerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ScheduleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateScheduleDto | undefined): Observable<ScheduleDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ScheduleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMultiple(body: CreateScheduleDto[] | null | undefined): Observable<ScheduleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/CreateMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleDto[]>;
        }));
    }

    protected processCreateMultiple(response: HttpResponseBase): Observable<ScheduleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ScheduleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateScheduleDto | undefined): Observable<ScheduleDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScheduleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScheduleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ScheduleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    multipleDeleteByIds(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/MultipleDeleteByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMultipleDeleteByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMultipleDeleteByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMultipleDeleteByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param farmIds (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getWorkersSchedule(dateFrom: moment.Moment | undefined, dateTo: moment.Moment | undefined, farmIds: string[] | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WorkerScheduleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/GetWorkersSchedule?";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (farmIds !== undefined && farmIds !== null)
            farmIds && farmIds.forEach(item => { url_ += "FarmIds=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkersSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkersSchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerScheduleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerScheduleDtoPagedResultDto>;
        }));
    }

    protected processGetWorkersSchedule(response: HttpResponseBase): Observable<WorkerScheduleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerScheduleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerScheduleDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getSimpleScheduleByDateFarm(farmId: string, date: moment.Moment): Observable<SimpleScheduleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/GetSimpleScheduleByDateFarm?";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSimpleScheduleByDateFarm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSimpleScheduleByDateFarm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleScheduleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleScheduleDtoListResultDto>;
        }));
    }

    protected processGetSimpleScheduleByDateFarm(response: HttpResponseBase): Observable<SimpleScheduleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleScheduleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleScheduleDtoListResultDto>(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(null as any);
    }
}

@Injectable()
export class SizeInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<SizeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SizeInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SizeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SizeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SizeInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<SizeInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SizeInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SizeInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SizeInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SizeInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSizeInfoDto | undefined): Observable<SizeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SizeInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SizeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SizeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SizeInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSizeInfoDto | undefined): Observable<SizeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SizeInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SizeInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SizeInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SizeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SizeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SizeInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SizeInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SpecieServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<SpecieDto> {
        let url_ = this.baseUrl + "/api/services/app/Specie/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecieDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecieDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SpecieDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecieDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecieDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SpecieDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Specie/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecieDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecieDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SpecieDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecieDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecieDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Specie/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: Int64EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Specie/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSpecieDto | undefined): Observable<SpecieDto> {
        let url_ = this.baseUrl + "/api/services/app/Specie/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecieDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecieDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SpecieDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecieDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecieDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateSpecieDto | undefined): Observable<SpecieDto> {
        let url_ = this.baseUrl + "/api/services/app/Specie/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecieDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecieDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SpecieDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpecieDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecieDto>(null as any);
    }
}

@Injectable()
export class SubFamilyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSubFamilyDto | undefined): Observable<SubFamilyDto> {
        let url_ = this.baseUrl + "/api/services/app/SubFamily/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubFamilyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubFamilyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SubFamilyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubFamilyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubFamilyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateSubFamilyDto | undefined): Observable<SubFamilyDto> {
        let url_ = this.baseUrl + "/api/services/app/SubFamily/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubFamilyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubFamilyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SubFamilyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubFamilyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubFamilyDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubFamily/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<SubFamilyDto> {
        let url_ = this.baseUrl + "/api/services/app/SubFamily/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubFamilyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubFamilyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SubFamilyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubFamilyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubFamilyDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<SubFamilyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SubFamily/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubFamilyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubFamilyDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SubFamilyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubFamilyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubFamilyDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class SupplierServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSupplierDto | undefined): Observable<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SupplierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSupplierDto | undefined): Observable<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SupplierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SupplierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SupplierDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SupplierDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class SupplierApproverServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApproverDto | undefined): Observable<ApproverDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierApprover/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ApproverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ApproverDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierApprover/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApproverDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<ApproverDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierApprover/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApproverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupplierApprover/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateApproverDto | undefined): Observable<ApproverDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierApprover/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ApproverDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproverDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproverDto>(null as any);
    }
}

@Injectable()
export class SupplierFarmServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSupplierFarmDto | undefined): Observable<SupplierFarmDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierFarm/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierFarmDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierFarmDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SupplierFarmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierFarmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierFarmDto>(null as any);
    }

    /**
     * @param supplierId (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(supplierId: string | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SupplierFarmDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierFarm/GetAll?";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierFarmDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierFarmDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SupplierFarmDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierFarmDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierFarmDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<SupplierFarmDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierFarm/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierFarmDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierFarmDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SupplierFarmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierFarmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierFarmDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupplierFarm/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSupplierFarmDto | undefined): Observable<SupplierFarmDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierFarm/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierFarmDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierFarmDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SupplierFarmDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierFarmDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierFarmDto>(null as any);
    }
}

@Injectable()
export class SupplierPaymentInformationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePaymentInformationDto | undefined): Observable<PaymentInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierPaymentInformation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInformationDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PaymentInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInformationDto>(null as any);
    }

    /**
     * @param supplierId (optional) 
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(supplierId: string | undefined, keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PaymentInformationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierPaymentInformation/GetAll?";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInformationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInformationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaymentInformationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInformationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInformationDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PaymentInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierPaymentInformation/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInformationDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInformationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupplierPaymentInformation/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePaymentInformationDto | undefined): Observable<PaymentInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/SupplierPaymentInformation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInformationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaymentInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInformationDto>(null as any);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTagDto | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateLegalRepresentativeDto | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param tenantsId (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, tenantsId: number[] | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (tenantsId !== undefined && tenantsId !== null)
            tenantsId && tenantsId.forEach(item => { url_ += "TenantsId=" + encodeURIComponent("" + item) + "&"; });
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesDto | undefined): Observable<TenantDataDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDataDto>;
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<TenantDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDataDto>(null as any);
    }

    /**
     * @return Success
     */
    getTenantsFilter(): Observable<TenantFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantsFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantsFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantsFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantFilterDtoPagedResultDto>;
        }));
    }

    protected processGetTenantsFilter(response: HttpResponseBase): Observable<TenantFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantFilterDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(null as any);
    }
}

@Injectable()
export class TransportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/services/app/Transport/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(farmId: string, keyword: string | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TransportDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Transport/GetAll?";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TransportDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTransportDto | undefined): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/services/app/Transport/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTransportDto | undefined): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/services/app/Transport/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Transport/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TransportClassificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TransportClassificationDto> {
        let url_ = this.baseUrl + "/api/services/app/TransportClassification/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportClassificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportClassificationDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TransportClassificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportClassificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassificationDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TransportClassificationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TransportClassification/GetAll?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportClassificationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportClassificationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TransportClassificationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportClassificationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassificationDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TransportClassificationDto | undefined): Observable<TransportClassificationDto> {
        let url_ = this.baseUrl + "/api/services/app/TransportClassification/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportClassificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportClassificationDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TransportClassificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportClassificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassificationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TransportClassificationDto | undefined): Observable<TransportClassificationDto> {
        let url_ = this.baseUrl + "/api/services/app/TransportClassification/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportClassificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportClassificationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TransportClassificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportClassificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassificationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TransportClassification/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TransportTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/TransportType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TransportTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TransportType/GetAll?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TransportTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TransportTypeDto | undefined): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/TransportType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TransportTypeDto | undefined): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/TransportType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransportTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TransportType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param languageName (optional) 
     * @return Success
     */
    changeLanguageToUser(userId: number | undefined, languageName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguageToUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (languageName !== undefined && languageName !== null)
            url_ += "languageName=" + encodeURIComponent("" + languageName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguageToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguageToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguageToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: UpdateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: Int64EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param userIds (optional) 
     * @param farmsIds (optional) 
     * @param roleIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, userIds: number[] | null | undefined, farmsIds: string[] | null | undefined, roleIds: number[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (userIds !== undefined && userIds !== null)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (farmsIds !== undefined && farmsIds !== null)
            farmsIds && farmsIds.forEach(item => { url_ += "FarmsIds=" + encodeURIComponent("" + item) + "&"; });
        if (roleIds !== undefined && roleIds !== null)
            roleIds && roleIds.forEach(item => { url_ += "RoleIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateEmail(body: ValidateEmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ValidateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getCompanies(): Observable<CompanyUserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetCompanies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyUserDto[]>;
        }));
    }

    protected processGetCompanies(response: HttpResponseBase): Observable<CompanyUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CompanyUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyUserDto[]>(null as any);
    }

    /**
     * @param farmId (optional) 
     * @return Success
     */
    changeUserFarm(farmId: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeUserFarm?";
        if (farmId === null)
            throw new Error("The parameter 'farmId' cannot be null.");
        else if (farmId !== undefined)
            url_ += "farmId=" + encodeURIComponent("" + farmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserFarm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserFarm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangeUserFarm(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validatePassword(body: ValidatePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ValidatePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidatePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidatePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateEmailToResetPassword(body: ValidateEmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ValidateEmailToResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateEmailToResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateEmailToResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidateEmailToResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetForgotedPassword(body: ResetUserPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetForgotedPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetForgotedPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetForgotedPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetForgotedPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param resetPasswordCode (optional) 
     * @return Success
     */
    getUserInfoByResetPAssword(resetPasswordCode: string | null | undefined): Observable<SimpleUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserInfoByResetPAssword?";
        if (resetPasswordCode !== undefined && resetPasswordCode !== null)
            url_ += "ResetPasswordCode=" + encodeURIComponent("" + resetPasswordCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfoByResetPAssword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfoByResetPAssword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleUserDto>;
        }));
    }

    protected processGetUserInfoByResetPAssword(response: HttpResponseBase): Observable<SimpleUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleUserDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMainInfo(id: number | undefined): Observable<UserMainInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetMainInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMainInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMainInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserMainInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserMainInfoDto>;
        }));
    }

    protected processGetMainInfo(response: HttpResponseBase): Observable<UserMainInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserMainInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMainInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMainInfo(body: UserMainInfoDto | undefined): Observable<UserMainInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateMainInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMainInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMainInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserMainInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserMainInfoDto>;
        }));
    }

    protected processUpdateMainInfo(response: HttpResponseBase): Observable<UserMainInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserMainInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMainInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserRoles(id: number | undefined): Observable<UserRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRolesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRolesDto>;
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<UserRolesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRolesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRolesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserRoles(body: UserRolesDto | undefined): Observable<UserRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRolesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRolesDto>;
        }));
    }

    protected processUpdateUserRoles(response: HttpResponseBase): Observable<UserRolesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRolesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRolesDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPhoto(id: number | undefined): Observable<UserPhotoDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPhoto?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserPhotoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserPhotoDto>;
        }));
    }

    protected processGetUserPhoto(response: HttpResponseBase): Observable<UserPhotoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPhotoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPhotoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPhoto(body: UserPhotoDto | undefined): Observable<UserPhotoDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserPhotoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserPhotoDto>;
        }));
    }

    protected processUpdateUserPhoto(response: HttpResponseBase): Observable<UserPhotoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPhotoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPhotoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserProducts(id: number | undefined): Observable<UserProductsDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserProducts?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProductsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProductsDto>;
        }));
    }

    protected processGetUserProducts(response: HttpResponseBase): Observable<UserProductsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProductsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProductsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserProducts(body: UserProductsDto | undefined): Observable<UserProductsDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProductsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProductsDto>;
        }));
    }

    protected processUpdateUserProducts(response: HttpResponseBase): Observable<UserProductsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProductsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProductsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserAllowedResources(id: number | undefined): Observable<UserAllowedResourcesDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserAllowedResources?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAllowedResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAllowedResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAllowedResourcesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAllowedResourcesDto>;
        }));
    }

    protected processGetUserAllowedResources(response: HttpResponseBase): Observable<UserAllowedResourcesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAllowedResourcesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAllowedResourcesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserAllowedResources(body: UserAllowedResourcesDto | undefined): Observable<UserAllowedResourcesDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserAllowedResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserAllowedResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserAllowedResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAllowedResourcesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAllowedResourcesDto>;
        }));
    }

    protected processUpdateUserAllowedResources(response: HttpResponseBase): Observable<UserAllowedResourcesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAllowedResourcesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAllowedResourcesDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserSignatureInfo(id: string | undefined): Observable<SignatureInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserSignatureInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserSignatureInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserSignatureInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SignatureInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SignatureInfoDto>;
        }));
    }

    protected processGetUserSignatureInfo(response: HttpResponseBase): Observable<SignatureInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignatureInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignatureInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserSignatureInfo(body: SignatureInfoDto | undefined): Observable<SignatureInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserSignatureInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignatureInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignatureInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SignatureInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SignatureInfoDto>;
        }));
    }

    protected processUpdateUserSignatureInfo(response: HttpResponseBase): Observable<SignatureInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignatureInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignatureInfoDto>(null as any);
    }

    /**
     * @return Success
     */
    getUsersFilter(): Observable<UserFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserFilterDtoPagedResultDto>;
        }));
    }

    protected processGetUsersFilter(response: HttpResponseBase): Observable<UserFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserFilterDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }
}

@Injectable()
export class UserAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateEmailToResetPassword(body: ValidateEmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/UserAccount/ValidateEmailToResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateEmailToResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateEmailToResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidateEmailToResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param resetPasswordCode (optional) 
     * @return Success
     */
    getUserInfoByResetPasswordCode(resetPasswordCode: string | null | undefined): Observable<SimpleUserDto> {
        let url_ = this.baseUrl + "/UserAccount/GetUserInfoByResetPasswordCode?";
        if (resetPasswordCode !== undefined && resetPasswordCode !== null)
            url_ += "ResetPasswordCode=" + encodeURIComponent("" + resetPasswordCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfoByResetPasswordCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfoByResetPasswordCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleUserDto>;
        }));
    }

    protected processGetUserInfoByResetPasswordCode(response: HttpResponseBase): Observable<SimpleUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetForgottenPassword(body: ResetUserPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/UserAccount/ResetForgottenPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetForgottenPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetForgottenPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetForgottenPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class VarietyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<VarietyDto> {
        let url_ = this.baseUrl + "/api/services/app/Variety/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VarietyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VarietyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VarietyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VarietyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VarietyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateVarietyDto | undefined): Observable<VarietyDto> {
        let url_ = this.baseUrl + "/api/services/app/Variety/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VarietyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VarietyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<VarietyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VarietyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VarietyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateVarietyDto | undefined): Observable<VarietyDto> {
        let url_ = this.baseUrl + "/api/services/app/Variety/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VarietyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VarietyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<VarietyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VarietyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VarietyDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param specieId (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, specieId: number | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<VarietyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Variety/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (specieId !== undefined && specieId !== null)
            url_ += "SpecieId=" + encodeURIComponent("" + specieId) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VarietyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VarietyDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VarietyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VarietyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VarietyDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Variety/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: Int64EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Variety/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class VoluntaryRetirementSavingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateVoluntaryRetirementSavingDto | undefined): Observable<VoluntaryRetirementSavingDto> {
        let url_ = this.baseUrl + "/api/services/app/VoluntaryRetirementSaving/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoluntaryRetirementSavingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoluntaryRetirementSavingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<VoluntaryRetirementSavingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoluntaryRetirementSavingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoluntaryRetirementSavingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: VoluntaryRetirementSavingDto | undefined): Observable<VoluntaryRetirementSavingDto> {
        let url_ = this.baseUrl + "/api/services/app/VoluntaryRetirementSaving/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoluntaryRetirementSavingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoluntaryRetirementSavingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<VoluntaryRetirementSavingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoluntaryRetirementSavingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoluntaryRetirementSavingDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<VoluntaryRetirementSavingDto> {
        let url_ = this.baseUrl + "/api/services/app/VoluntaryRetirementSaving/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoluntaryRetirementSavingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoluntaryRetirementSavingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VoluntaryRetirementSavingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoluntaryRetirementSavingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoluntaryRetirementSavingDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VoluntaryRetirementSaving/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<VoluntaryRetirementSavingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/VoluntaryRetirementSaving/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VoluntaryRetirementSavingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VoluntaryRetirementSavingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VoluntaryRetirementSavingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoluntaryRetirementSavingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoluntaryRetirementSavingDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class WarehouseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWarehouseDto | undefined): Observable<WarehouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouse/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WarehouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWarehouseDto | undefined): Observable<WarehouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WarehouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAddres(body: UpdateWarehouseAddres | undefined): Observable<WarehouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouse/UpdateAddres";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAddres(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAddres(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseDto>;
        }));
    }

    protected processUpdateAddres(response: HttpResponseBase): Observable<WarehouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Warehouse/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<WarehouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouse/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WarehouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WarehouseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouse/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WarehouseDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WarehouseDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WarehouseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    simpleGetAll(body: PagedWarehouseResultRequestDto | undefined): Observable<SimpleWarehouseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouse/SimpleGetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimpleGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimpleGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleWarehouseDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleWarehouseDtoPagedResultDto>;
        }));
    }

    protected processSimpleGetAll(response: HttpResponseBase): Observable<SimpleWarehouseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleWarehouseDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleWarehouseDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class WayPayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWayPayAccountTypeDto | undefined): Observable<WayPayDto> {
        let url_ = this.baseUrl + "/api/services/app/WayPay/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WayPayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WayPayDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WayPayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WayPayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WayPayDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateWayPayAccountTypeDto | undefined): Observable<WayPayDto> {
        let url_ = this.baseUrl + "/api/services/app/WayPay/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WayPayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WayPayDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WayPayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WayPayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WayPayDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WayPay/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WayPayDto> {
        let url_ = this.baseUrl + "/api/services/app/WayPay/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WayPayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WayPayDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WayPayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WayPayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WayPayDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined): Observable<WayPayDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WayPay/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WayPayDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WayPayDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WayPayDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WayPayDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WayPayDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class WorkDayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWorkDayDto | undefined): Observable<WorkDayDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDay/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WorkDayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createV2(body: CreateWorkDayDto | undefined): Observable<WorkDayDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDay/CreateV2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayDto>;
        }));
    }

    protected processCreateV2(response: HttpResponseBase): Observable<WorkDayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkDay/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkDay/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param workDaysId (optional) 
     * @param daysOffId (optional) 
     * @param workDayTypesId (optional) 
     * @param weekDaysId (optional) 
     * @param workShiftsId (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, workDaysId: string[] | null | undefined, daysOffId: number[] | null | undefined, workDayTypesId: number[] | null | undefined, weekDaysId: number[] | null | undefined, workShiftsId: string[] | null | undefined, isActive: boolean | null | undefined, farmId: string, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WorkDayDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDay/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (workDaysId !== undefined && workDaysId !== null)
            workDaysId && workDaysId.forEach(item => { url_ += "WorkDaysId=" + encodeURIComponent("" + item) + "&"; });
        if (daysOffId !== undefined && daysOffId !== null)
            daysOffId && daysOffId.forEach(item => { url_ += "DaysOffId=" + encodeURIComponent("" + item) + "&"; });
        if (workDayTypesId !== undefined && workDayTypesId !== null)
            workDayTypesId && workDayTypesId.forEach(item => { url_ += "WorkDayTypesId=" + encodeURIComponent("" + item) + "&"; });
        if (weekDaysId !== undefined && weekDaysId !== null)
            weekDaysId && weekDaysId.forEach(item => { url_ += "WeekDaysId=" + encodeURIComponent("" + item) + "&"; });
        if (workShiftsId !== undefined && workShiftsId !== null)
            workShiftsId && workShiftsId.forEach(item => { url_ += "WorkShiftsId=" + encodeURIComponent("" + item) + "&"; });
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WorkDayDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<WorkDayDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDay/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WorkDayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getV2(id: string | undefined): Observable<WorkDayDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDay/GetV2?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayDto>;
        }));
    }

    protected processGetV2(response: HttpResponseBase): Observable<WorkDayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWorkDayDto | undefined): Observable<WorkDayDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDay/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WorkDayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayDto>(null as any);
    }
}

@Injectable()
export class WorkDayRoundTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllEntities(): Observable<WorkDayRoundTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayRoundType/GetAllEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayRoundTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayRoundTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAllEntities(response: HttpResponseBase): Observable<WorkDayRoundTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayRoundTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayRoundTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WorkDayRoundTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayRoundType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayRoundTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayRoundTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WorkDayRoundTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayRoundTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayRoundTypeDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<WorkDayRoundTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayRoundType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayRoundTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayRoundTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WorkDayRoundTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayRoundTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayRoundTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWorkDayRoundTypeDto | undefined): Observable<WorkDayRoundTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayRoundType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayRoundTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayRoundTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WorkDayRoundTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayRoundTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayRoundTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WorkDayRoundTypeDto | undefined): Observable<WorkDayRoundTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayRoundType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayRoundTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayRoundTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WorkDayRoundTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayRoundTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayRoundTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayRoundType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkDayTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllEntities(): Observable<WorkDayTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayType/GetAllEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAllEntities(response: HttpResponseBase): Observable<WorkDayTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getWorkDayTypesFilter(): Observable<WorkDayTypeFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayType/GetWorkDayTypesFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkDayTypesFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkDayTypesFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayTypeFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayTypeFilterDtoPagedResultDto>;
        }));
    }

    protected processGetWorkDayTypesFilter(response: HttpResponseBase): Observable<WorkDayTypeFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayTypeFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayTypeFilterDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WorkDayTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WorkDayTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayTypeDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<WorkDayTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WorkDayTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWorkDayTypeDto | undefined): Observable<WorkDayTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WorkDayTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WorkDayTypeDto | undefined): Observable<WorkDayTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkDayTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkDayTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WorkDayTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkDayTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkDayTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkDayType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<WorkerDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WorkerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param departmentIds (optional) 
     * @param costCenterIds (optional) 
     * @param jobTitleIds (optional) 
     * @param workerIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, farmId: string, departmentIds: string[] | null | undefined, costCenterIds: string[] | null | undefined, jobTitleIds: string[] | null | undefined, workerIds: string[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WorkerDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (departmentIds !== undefined && departmentIds !== null)
            departmentIds && departmentIds.forEach(item => { url_ += "DepartmentIds=" + encodeURIComponent("" + item) + "&"; });
        if (costCenterIds !== undefined && costCenterIds !== null)
            costCenterIds && costCenterIds.forEach(item => { url_ += "CostCenterIds=" + encodeURIComponent("" + item) + "&"; });
        if (jobTitleIds !== undefined && jobTitleIds !== null)
            jobTitleIds && jobTitleIds.forEach(item => { url_ += "JobTitleIds=" + encodeURIComponent("" + item) + "&"; });
        if (workerIds !== undefined && workerIds !== null)
            workerIds && workerIds.forEach(item => { url_ += "WorkerIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WorkerDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDtoPagedResultDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param departmentIds (optional) 
     * @param costCenterIds (optional) 
     * @param jobTitleIds (optional) 
     * @param workerIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSimpleWorkers(keyword: string | null | undefined, farmId: string, departmentIds: string[] | null | undefined, costCenterIds: string[] | null | undefined, jobTitleIds: string[] | null | undefined, workerIds: string[] | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SimpleWorkerDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/GetAllSimpleWorkers?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        if (departmentIds !== undefined && departmentIds !== null)
            departmentIds && departmentIds.forEach(item => { url_ += "DepartmentIds=" + encodeURIComponent("" + item) + "&"; });
        if (costCenterIds !== undefined && costCenterIds !== null)
            costCenterIds && costCenterIds.forEach(item => { url_ += "CostCenterIds=" + encodeURIComponent("" + item) + "&"; });
        if (jobTitleIds !== undefined && jobTitleIds !== null)
            jobTitleIds && jobTitleIds.forEach(item => { url_ += "JobTitleIds=" + encodeURIComponent("" + item) + "&"; });
        if (workerIds !== undefined && workerIds !== null)
            workerIds && workerIds.forEach(item => { url_ += "WorkerIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSimpleWorkers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSimpleWorkers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleWorkerDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleWorkerDtoPagedResultDto>;
        }));
    }

    protected processGetAllSimpleWorkers(response: HttpResponseBase): Observable<SimpleWorkerDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleWorkerDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleWorkerDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllSimpleWorkersByFarm(farmId: string): Observable<SimpleWorkerDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/GetAllSimpleWorkersByFarm?";
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSimpleWorkersByFarm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSimpleWorkersByFarm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleWorkerDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleWorkerDtoListResultDto>;
        }));
    }

    protected processGetAllSimpleWorkersByFarm(response: HttpResponseBase): Observable<SimpleWorkerDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleWorkerDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleWorkerDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWorkerDto | undefined): Observable<WorkerDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WorkerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Worker/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: GuidEntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Worker/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMainData(body: UpdateWorkerMainDataDto | undefined): Observable<WorkerDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/UpdateMainData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMainData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMainData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDto>;
        }));
    }

    protected processUpdateMainData(response: HttpResponseBase): Observable<WorkerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePersonalData(body: UpdatePersonalDataDto | undefined): Observable<WorkerDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/UpdatePersonalData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonalData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonalData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDto>;
        }));
    }

    protected processUpdatePersonalData(response: HttpResponseBase): Observable<WorkerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFamilyDependents(body: UpdateWorkerFamilyDependentDto | undefined): Observable<WorkerDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/UpdateFamilyDependents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFamilyDependents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFamilyDependents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDto>;
        }));
    }

    protected processUpdateFamilyDependents(response: HttpResponseBase): Observable<WorkerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVoluntarySavings(body: UpdateWorkerVoluntaryRetirementSavingDto | undefined): Observable<WorkerDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/UpdateVoluntarySavings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVoluntarySavings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVoluntarySavings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDto>;
        }));
    }

    protected processUpdateVoluntarySavings(response: HttpResponseBase): Observable<WorkerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateWorkerPhoto(body: UpdateWorkerPhotoDto | undefined): Observable<WorkerDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/UpdateWorkerPhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWorkerPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWorkerPhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDto>;
        }));
    }

    protected processUpdateWorkerPhoto(response: HttpResponseBase): Observable<WorkerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkerSignatureInfo(id: string | undefined): Observable<SignatureInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/GetWorkerSignatureInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkerSignatureInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkerSignatureInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SignatureInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SignatureInfoDto>;
        }));
    }

    protected processGetWorkerSignatureInfo(response: HttpResponseBase): Observable<SignatureInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignatureInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignatureInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserSignatureInfo(body: SignatureInfoDto | undefined): Observable<SignatureInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/UpdateUserSignatureInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignatureInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignatureInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SignatureInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SignatureInfoDto>;
        }));
    }

    protected processUpdateUserSignatureInfo(response: HttpResponseBase): Observable<SignatureInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignatureInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignatureInfoDto>(null as any);
    }

    /**
     * @param farmId (optional) 
     * @return Success
     */
    getWorkersFilter(farmId: string | null | undefined): Observable<WorkerFilterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/GetWorkersFilter?";
        if (farmId !== undefined && farmId !== null)
            url_ += "FarmId=" + encodeURIComponent("" + farmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkersFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkersFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerFilterDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerFilterDtoPagedResultDto>;
        }));
    }

    protected processGetWorkersFilter(response: HttpResponseBase): Observable<WorkerFilterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerFilterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerFilterDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWorkerDto | undefined): Observable<WorkerDto> {
        let url_ = this.baseUrl + "/api/services/app/Worker/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WorkerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerDto>(null as any);
    }
}

@Injectable()
export class WorkerInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<WorkerInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkerInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WorkerInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<WorkerInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkerInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WorkerInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWorkerInfoDto | undefined): Observable<WorkerInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkerInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WorkerInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWorkerInfoDto | undefined): Observable<WorkerInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkerInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkerInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkerInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WorkerInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkerInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkerInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkerInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkingInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<WorkingInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingInfo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkingInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkingInfoDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WorkingInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkingInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkingInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationalInfo(body: UpdateOrganizationalInfoDto | undefined): Observable<WorkingInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingInfo/UpdateOrganizationalInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationalInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationalInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkingInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkingInfoDto>;
        }));
    }

    protected processUpdateOrganizationalInfo(response: HttpResponseBase): Observable<WorkingInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkingInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkingInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWorkingInfoDto | undefined): Observable<WorkingInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkingInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkingInfoDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WorkingInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkingInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkingInfoDto>(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<WorkingInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingInfo/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkingInfoDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkingInfoDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WorkingInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkingInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkingInfoDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWorkingInfoDto | undefined): Observable<WorkingInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkingInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkingInfoDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WorkingInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkingInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkingInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkingInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkShiftServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<WorkShiftDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkShift/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkShiftDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WorkShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkShiftDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkShiftDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllByFarms(farmIds: string[]): Observable<WorkShiftDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkShift/GetAllByFarms?";
        if (farmIds === undefined || farmIds === null)
            throw new Error("The parameter 'farmIds' must be defined and cannot be null.");
        else
            farmIds && farmIds.forEach(item => { url_ += "FarmIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByFarms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByFarms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkShiftDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkShiftDto[]>;
        }));
    }

    protected processGetAllByFarms(response: HttpResponseBase): Observable<WorkShiftDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(WorkShiftDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkShiftDto[]>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WorkShiftDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkShift/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkShiftDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkShiftDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WorkShiftDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkShiftDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkShiftDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateWorkShiftDto | undefined): Observable<WorkShiftDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkShift/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkShiftDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WorkShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkShiftDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkShiftDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWorkShiftDto | undefined): Observable<WorkShiftDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkShift/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkShiftDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WorkShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkShiftDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkShiftDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkShift/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteById(input: GuidEntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkShift/DeleteById?";
        if (input !== undefined && input !== null)
            input && input.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class AbsenceTypeDto implements IAbsenceTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    id: number;

    constructor(data?: IAbsenceTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AbsenceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbsenceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): AbsenceTypeDto {
        const json = this.toJSON();
        let result = new AbsenceTypeDto();
        result.init(json);
        return result;
    }
}

export interface IAbsenceTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    id: number;
}

export class AbsenceDto implements IAbsenceDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    isPayable: boolean;
    lang_Key: string | undefined;
    percentToPay: number;
    absenceType: AbsenceTypeDto;
    tenantId: number | undefined;
    id: string;

    constructor(data?: IAbsenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.isPayable = _data["isPayable"];
            this.lang_Key = _data["lang_Key"];
            this.percentToPay = _data["percentToPay"];
            this.absenceType = _data["absenceType"] ? AbsenceTypeDto.fromJS(_data["absenceType"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AbsenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbsenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["isPayable"] = this.isPayable;
        data["lang_Key"] = this.lang_Key;
        data["percentToPay"] = this.percentToPay;
        data["absenceType"] = this.absenceType ? this.absenceType.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): AbsenceDto {
        const json = this.toJSON();
        let result = new AbsenceDto();
        result.init(json);
        return result;
    }
}

export interface IAbsenceDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    isPayable: boolean;
    lang_Key: string | undefined;
    percentToPay: number;
    absenceType: AbsenceTypeDto;
    tenantId: number | undefined;
    id: string;
}

export class AbsenceDtoPagedResultDto implements IAbsenceDtoPagedResultDto {
    totalCount: number;
    items: AbsenceDto[] | undefined;

    constructor(data?: IAbsenceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AbsenceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AbsenceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbsenceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AbsenceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AbsenceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAbsenceDtoPagedResultDto {
    totalCount: number;
    items: AbsenceDto[] | undefined;
}

export class CreateAbsenceDto implements ICreateAbsenceDto {
    name: string;
    code: string;
    description: string | undefined;
    isPayable: boolean;
    lang_Key: string | undefined;
    percentToPay: number;
    absenceTypeId: number;

    constructor(data?: ICreateAbsenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.isPayable = _data["isPayable"];
            this.lang_Key = _data["lang_Key"];
            this.percentToPay = _data["percentToPay"];
            this.absenceTypeId = _data["absenceTypeId"];
        }
    }

    static fromJS(data: any): CreateAbsenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAbsenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["isPayable"] = this.isPayable;
        data["lang_Key"] = this.lang_Key;
        data["percentToPay"] = this.percentToPay;
        data["absenceTypeId"] = this.absenceTypeId;
        return data;
    }

    clone(): CreateAbsenceDto {
        const json = this.toJSON();
        let result = new CreateAbsenceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAbsenceDto {
    name: string;
    code: string;
    description: string | undefined;
    isPayable: boolean;
    lang_Key: string | undefined;
    percentToPay: number;
    absenceTypeId: number;
}

export class UpdateAbsenceDto implements IUpdateAbsenceDto {
    name: string;
    code: string;
    description: string | undefined;
    isPayable: boolean;
    lang_Key: string | undefined;
    percentToPay: number;
    absenceTypeId: number;
    id: string;

    constructor(data?: IUpdateAbsenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.isPayable = _data["isPayable"];
            this.lang_Key = _data["lang_Key"];
            this.percentToPay = _data["percentToPay"];
            this.absenceTypeId = _data["absenceTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAbsenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAbsenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["isPayable"] = this.isPayable;
        data["lang_Key"] = this.lang_Key;
        data["percentToPay"] = this.percentToPay;
        data["absenceTypeId"] = this.absenceTypeId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateAbsenceDto {
        const json = this.toJSON();
        let result = new UpdateAbsenceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAbsenceDto {
    name: string;
    code: string;
    description: string | undefined;
    isPayable: boolean;
    lang_Key: string | undefined;
    percentToPay: number;
    absenceTypeId: number;
    id: string;
}

export class AbsenceTypeDtoPagedResultDto implements IAbsenceTypeDtoPagedResultDto {
    totalCount: number;
    items: AbsenceTypeDto[] | undefined;

    constructor(data?: IAbsenceTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AbsenceTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AbsenceTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbsenceTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AbsenceTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AbsenceTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAbsenceTypeDtoPagedResultDto {
    totalCount: number;
    items: AbsenceTypeDto[] | undefined;
}

export class CreateAcademicDegreeDto implements ICreateAcademicDegreeDto {
    name: string;
    description: string;
    langKey: string | undefined;

    constructor(data?: ICreateAcademicDegreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
        }
    }

    static fromJS(data: any): CreateAcademicDegreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAcademicDegreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        return data;
    }

    clone(): CreateAcademicDegreeDto {
        const json = this.toJSON();
        let result = new CreateAcademicDegreeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAcademicDegreeDto {
    name: string;
    description: string;
    langKey: string | undefined;
}

export class AcademicDegreeDto implements IAcademicDegreeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    id: number;

    constructor(data?: IAcademicDegreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AcademicDegreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicDegreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): AcademicDegreeDto {
        const json = this.toJSON();
        let result = new AcademicDegreeDto();
        result.init(json);
        return result;
    }
}

export interface IAcademicDegreeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    id: number;
}

export class UpdateAcademicDegreeDto implements IUpdateAcademicDegreeDto {
    name: string;
    description: string;
    langKey: string | undefined;
    id: number;

    constructor(data?: IUpdateAcademicDegreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAcademicDegreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAcademicDegreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateAcademicDegreeDto {
        const json = this.toJSON();
        let result = new UpdateAcademicDegreeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAcademicDegreeDto {
    name: string;
    description: string;
    langKey: string | undefined;
    id: number;
}

export class AcademicDegreeDtoPagedResultDto implements IAcademicDegreeDtoPagedResultDto {
    totalCount: number;
    items: AcademicDegreeDto[] | undefined;

    constructor(data?: IAcademicDegreeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AcademicDegreeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AcademicDegreeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicDegreeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AcademicDegreeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AcademicDegreeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAcademicDegreeDtoPagedResultDto {
    totalCount: number;
    items: AcademicDegreeDto[] | undefined;
}

export class AcademicInfoDto implements IAcademicInfoDto {
    academicInstitutionName: string | undefined;
    academicDegree: AcademicDegreeDto;
    academicTitleName: string | undefined;
    langKey: string | undefined;
    tenantId: number;
    id: string;

    constructor(data?: IAcademicInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicInstitutionName = _data["academicInstitutionName"];
            this.academicDegree = _data["academicDegree"] ? AcademicDegreeDto.fromJS(_data["academicDegree"]) : <any>undefined;
            this.academicTitleName = _data["academicTitleName"];
            this.langKey = _data["langKey"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AcademicInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicInstitutionName"] = this.academicInstitutionName;
        data["academicDegree"] = this.academicDegree ? this.academicDegree.toJSON() : <any>undefined;
        data["academicTitleName"] = this.academicTitleName;
        data["langKey"] = this.langKey;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): AcademicInfoDto {
        const json = this.toJSON();
        let result = new AcademicInfoDto();
        result.init(json);
        return result;
    }
}

export interface IAcademicInfoDto {
    academicInstitutionName: string | undefined;
    academicDegree: AcademicDegreeDto;
    academicTitleName: string | undefined;
    langKey: string | undefined;
    tenantId: number;
    id: string;
}

export class AcademicInfoDtoPagedResultDto implements IAcademicInfoDtoPagedResultDto {
    totalCount: number;
    items: AcademicInfoDto[] | undefined;

    constructor(data?: IAcademicInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AcademicInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AcademicInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AcademicInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AcademicInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAcademicInfoDtoPagedResultDto {
    totalCount: number;
    items: AcademicInfoDto[] | undefined;
}

export class CreateAcademicInfoDto implements ICreateAcademicInfoDto {
    academicInstitutionName: string | undefined;
    academicDegreeId: number | undefined;
    academicTitleName: string | undefined;

    constructor(data?: ICreateAcademicInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicInstitutionName = _data["academicInstitutionName"];
            this.academicDegreeId = _data["academicDegreeId"];
            this.academicTitleName = _data["academicTitleName"];
        }
    }

    static fromJS(data: any): CreateAcademicInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAcademicInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicInstitutionName"] = this.academicInstitutionName;
        data["academicDegreeId"] = this.academicDegreeId;
        data["academicTitleName"] = this.academicTitleName;
        return data;
    }

    clone(): CreateAcademicInfoDto {
        const json = this.toJSON();
        let result = new CreateAcademicInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAcademicInfoDto {
    academicInstitutionName: string | undefined;
    academicDegreeId: number | undefined;
    academicTitleName: string | undefined;
}

export class UpdateAcademicInfoDto implements IUpdateAcademicInfoDto {
    academicInstitutionName: string | undefined;
    academicDegreeId: number | undefined;
    academicTitleName: string | undefined;
    id: string;

    constructor(data?: IUpdateAcademicInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.academicInstitutionName = _data["academicInstitutionName"];
            this.academicDegreeId = _data["academicDegreeId"];
            this.academicTitleName = _data["academicTitleName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAcademicInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAcademicInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["academicInstitutionName"] = this.academicInstitutionName;
        data["academicDegreeId"] = this.academicDegreeId;
        data["academicTitleName"] = this.academicTitleName;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateAcademicInfoDto {
        const json = this.toJSON();
        let result = new UpdateAcademicInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAcademicInfoDto {
    academicInstitutionName: string | undefined;
    academicDegreeId: number | undefined;
    academicTitleName: string | undefined;
    id: string;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class IdentityError implements IIdentityError {
    code: string | undefined;
    description: string | undefined;

    constructor(data?: IIdentityError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): IdentityError {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }

    clone(): IdentityError {
        const json = this.toJSON();
        let result = new IdentityError();
        result.init(json);
        return result;
    }
}

export interface IIdentityError {
    code: string | undefined;
    description: string | undefined;
}

export class IdentityResult implements IIdentityResult {
    readonly succeeded: boolean;
    readonly errors: IdentityError[] | undefined;

    constructor(data?: IIdentityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors.push(IdentityError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }

    clone(): IdentityResult {
        const json = this.toJSON();
        let result = new IdentityResult();
        result.init(json);
        return result;
    }
}

export interface IIdentityResult {
    succeeded: boolean;
    errors: IdentityError[] | undefined;
}

export class CreateAccountDto implements ICreateAccountDto {
    name: string;
    code: string;
    companyId: string;
    accountTypeId: number;
    id: string;

    constructor(data?: ICreateAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.companyId = _data["companyId"];
            this.accountTypeId = _data["accountTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["companyId"] = this.companyId;
        data["accountTypeId"] = this.accountTypeId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAccountDto {
        const json = this.toJSON();
        let result = new CreateAccountDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAccountDto {
    name: string;
    code: string;
    companyId: string;
    accountTypeId: number;
    id: string;
}

export class AccountDto implements IAccountDto {
    name: string;
    code: string;
    companyId: string;
    accountTypeId: number;
    id: string;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.companyId = _data["companyId"];
            this.accountTypeId = _data["accountTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["companyId"] = this.companyId;
        data["accountTypeId"] = this.accountTypeId;
        data["id"] = this.id;
        return data;
    }

    clone(): AccountDto {
        const json = this.toJSON();
        let result = new AccountDto();
        result.init(json);
        return result;
    }
}

export interface IAccountDto {
    name: string;
    code: string;
    companyId: string;
    accountTypeId: number;
    id: string;
}

export class AccountDtoPagedResultDto implements IAccountDtoPagedResultDto {
    totalCount: number;
    items: AccountDto[] | undefined;

    constructor(data?: IAccountDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AccountDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AccountDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAccountDtoPagedResultDto {
    totalCount: number;
    items: AccountDto[] | undefined;
}

export class CreateAccountingDataDto implements ICreateAccountingDataDto {
    accountId: string;
    subFamilyId: string;
    accountSubFamilyTypeId: number;
    id: string;

    constructor(data?: ICreateAccountingDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.subFamilyId = _data["subFamilyId"];
            this.accountSubFamilyTypeId = _data["accountSubFamilyTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAccountingDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountingDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["subFamilyId"] = this.subFamilyId;
        data["accountSubFamilyTypeId"] = this.accountSubFamilyTypeId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAccountingDataDto {
        const json = this.toJSON();
        let result = new CreateAccountingDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAccountingDataDto {
    accountId: string;
    subFamilyId: string;
    accountSubFamilyTypeId: number;
    id: string;
}

export class AccountingDataDto implements IAccountingDataDto {
    accountId: string;
    subFamilyId: string;
    accountSubFamilyTypeId: number;
    id: string;

    constructor(data?: IAccountingDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.subFamilyId = _data["subFamilyId"];
            this.accountSubFamilyTypeId = _data["accountSubFamilyTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AccountingDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["subFamilyId"] = this.subFamilyId;
        data["accountSubFamilyTypeId"] = this.accountSubFamilyTypeId;
        data["id"] = this.id;
        return data;
    }

    clone(): AccountingDataDto {
        const json = this.toJSON();
        let result = new AccountingDataDto();
        result.init(json);
        return result;
    }
}

export interface IAccountingDataDto {
    accountId: string;
    subFamilyId: string;
    accountSubFamilyTypeId: number;
    id: string;
}

export class AccountingDataDtoPagedResultDto implements IAccountingDataDtoPagedResultDto {
    totalCount: number;
    items: AccountingDataDto[] | undefined;

    constructor(data?: IAccountingDataDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AccountingDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountingDataDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingDataDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AccountingDataDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AccountingDataDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAccountingDataDtoPagedResultDto {
    totalCount: number;
    items: AccountingDataDto[] | undefined;
}

export class CreateAccountSubFamilyTypeDto implements ICreateAccountSubFamilyTypeDto {
    name: string;
    description: string;
    id: number;

    constructor(data?: ICreateAccountSubFamilyTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAccountSubFamilyTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountSubFamilyTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAccountSubFamilyTypeDto {
        const json = this.toJSON();
        let result = new CreateAccountSubFamilyTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAccountSubFamilyTypeDto {
    name: string;
    description: string;
    id: number;
}

export class AccountSubFamilyTypeDto implements IAccountSubFamilyTypeDto {
    name: string;
    description: string;
    isDeleted: boolean;
    id: number;

    constructor(data?: IAccountSubFamilyTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AccountSubFamilyTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSubFamilyTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): AccountSubFamilyTypeDto {
        const json = this.toJSON();
        let result = new AccountSubFamilyTypeDto();
        result.init(json);
        return result;
    }
}

export interface IAccountSubFamilyTypeDto {
    name: string;
    description: string;
    isDeleted: boolean;
    id: number;
}

export class AccountSubFamilyTypeDtoPagedResultDto implements IAccountSubFamilyTypeDtoPagedResultDto {
    totalCount: number;
    items: AccountSubFamilyTypeDto[] | undefined;

    constructor(data?: IAccountSubFamilyTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AccountSubFamilyTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountSubFamilyTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSubFamilyTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AccountSubFamilyTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AccountSubFamilyTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAccountSubFamilyTypeDtoPagedResultDto {
    totalCount: number;
    items: AccountSubFamilyTypeDto[] | undefined;
}

export class CreateAccountTypeDto implements ICreateAccountTypeDto {
    name: string;
    description: string;
    id: number;

    constructor(data?: ICreateAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAccountTypeDto {
        const json = this.toJSON();
        let result = new CreateAccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAccountTypeDto {
    name: string;
    description: string;
    id: number;
}

export class AccountTypeDto implements IAccountTypeDto {
    name: string;
    description: string;
    isDeleted: boolean;
    id: number;

    constructor(data?: IAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): AccountTypeDto {
        const json = this.toJSON();
        let result = new AccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface IAccountTypeDto {
    name: string;
    description: string;
    isDeleted: boolean;
    id: number;
}

export class AccountTypeDtoPagedResultDto implements IAccountTypeDtoPagedResultDto {
    totalCount: number;
    items: AccountTypeDto[] | undefined;

    constructor(data?: IAccountTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AccountTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AccountTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AccountTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAccountTypeDtoPagedResultDto {
    totalCount: number;
    items: AccountTypeDto[] | undefined;
}

export class ActionTypeDto implements IActionTypeDto {
    name: string;
    description: string;
    id: number;

    constructor(data?: IActionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): ActionTypeDto {
        const json = this.toJSON();
        let result = new ActionTypeDto();
        result.init(json);
        return result;
    }
}

export interface IActionTypeDto {
    name: string;
    description: string;
    id: number;
}

export class ActionTypeDtoPagedResultDto implements IActionTypeDtoPagedResultDto {
    totalCount: number;
    items: ActionTypeDto[] | undefined;

    constructor(data?: IActionTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ActionTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ActionTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ActionTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IActionTypeDtoPagedResultDto {
    totalCount: number;
    items: ActionTypeDto[] | undefined;
}

export class CreateActionTypeDto implements ICreateActionTypeDto {
    name: string;
    description: string;

    constructor(data?: ICreateActionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateActionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }

    clone(): CreateActionTypeDto {
        const json = this.toJSON();
        let result = new CreateActionTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateActionTypeDto {
    name: string;
    description: string;
}

export class UpdateActionTypeDto implements IUpdateActionTypeDto {
    name: string;
    description: string;
    id: number;

    constructor(data?: IUpdateActionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateActionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateActionTypeDto {
        const json = this.toJSON();
        let result = new UpdateActionTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateActionTypeDto {
    name: string;
    description: string;
    id: number;
}

export class CreateActiveIngredientDto implements ICreateActiveIngredientDto {
    name: string | undefined;
    code: string | undefined;
    id: string;

    constructor(data?: ICreateActiveIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateActiveIngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActiveIngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateActiveIngredientDto {
        const json = this.toJSON();
        let result = new CreateActiveIngredientDto();
        result.init(json);
        return result;
    }
}

export interface ICreateActiveIngredientDto {
    name: string | undefined;
    code: string | undefined;
    id: string;
}

export class ProductProductStockMeasureUnitDto implements IProductProductStockMeasureUnitDto {
    measureUnitName: string | undefined;
    measureUnitId: number;

    constructor(data?: IProductProductStockMeasureUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.measureUnitName = _data["measureUnitName"];
            this.measureUnitId = _data["measureUnitId"];
        }
    }

    static fromJS(data: any): ProductProductStockMeasureUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductProductStockMeasureUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["measureUnitName"] = this.measureUnitName;
        data["measureUnitId"] = this.measureUnitId;
        return data;
    }

    clone(): ProductProductStockMeasureUnitDto {
        const json = this.toJSON();
        let result = new ProductProductStockMeasureUnitDto();
        result.init(json);
        return result;
    }
}

export interface IProductProductStockMeasureUnitDto {
    measureUnitName: string | undefined;
    measureUnitId: number;
}

export class ActiveIngredientProductDto implements IActiveIngredientProductDto {
    code: string | undefined;
    name: string | undefined;
    productStock: ProductProductStockMeasureUnitDto;
    id: string;

    constructor(data?: IActiveIngredientProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.productStock = _data["productStock"] ? ProductProductStockMeasureUnitDto.fromJS(_data["productStock"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActiveIngredientProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveIngredientProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["productStock"] = this.productStock ? this.productStock.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ActiveIngredientProductDto {
        const json = this.toJSON();
        let result = new ActiveIngredientProductDto();
        result.init(json);
        return result;
    }
}

export interface IActiveIngredientProductDto {
    code: string | undefined;
    name: string | undefined;
    productStock: ProductProductStockMeasureUnitDto;
    id: string;
}

export class ActiveIngredientDto implements IActiveIngredientDto {
    name: string | undefined;
    code: string | undefined;
    products: ActiveIngredientProductDto[] | undefined;
    id: string;

    constructor(data?: IActiveIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products.push(ActiveIngredientProductDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActiveIngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveIngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): ActiveIngredientDto {
        const json = this.toJSON();
        let result = new ActiveIngredientDto();
        result.init(json);
        return result;
    }
}

export interface IActiveIngredientDto {
    name: string | undefined;
    code: string | undefined;
    products: ActiveIngredientProductDto[] | undefined;
    id: string;
}

export class ActiveIngredientDtoPagedResultDto implements IActiveIngredientDtoPagedResultDto {
    totalCount: number;
    items: ActiveIngredientDto[] | undefined;

    constructor(data?: IActiveIngredientDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ActiveIngredientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActiveIngredientDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveIngredientDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ActiveIngredientDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ActiveIngredientDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IActiveIngredientDtoPagedResultDto {
    totalCount: number;
    items: ActiveIngredientDto[] | undefined;
}

export class CreateActivityDto implements ICreateActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    macroActivityId: string;
    farmIds: string[] | undefined;

    constructor(data?: ICreateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.macroActivityId = _data["macroActivityId"];
            if (Array.isArray(_data["farmIds"])) {
                this.farmIds = [] as any;
                for (let item of _data["farmIds"])
                    this.farmIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["macroActivityId"] = this.macroActivityId;
        if (Array.isArray(this.farmIds)) {
            data["farmIds"] = [];
            for (let item of this.farmIds)
                data["farmIds"].push(item);
        }
        return data;
    }

    clone(): CreateActivityDto {
        const json = this.toJSON();
        let result = new CreateActivityDto();
        result.init(json);
        return result;
    }
}

export interface ICreateActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    macroActivityId: string;
    farmIds: string[] | undefined;
}

export class AddressDto implements IAddressDto {
    address1: string;
    address2: string | undefined;
    city: string;
    state: string;
    county: string;
    country: string;
    countryCode: string | undefined;
    postalCode: string;
    latitude: number;
    longitude: number;
    tenantId: number;
    id: string;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.county = _data["county"];
            this.country = _data["country"];
            this.countryCode = _data["countryCode"];
            this.postalCode = _data["postalCode"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["county"] = this.county;
        data["country"] = this.country;
        data["countryCode"] = this.countryCode;
        data["postalCode"] = this.postalCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): AddressDto {
        const json = this.toJSON();
        let result = new AddressDto();
        result.init(json);
        return result;
    }
}

export interface IAddressDto {
    address1: string;
    address2: string | undefined;
    city: string;
    state: string;
    county: string;
    country: string;
    countryCode: string | undefined;
    postalCode: string;
    latitude: number;
    longitude: number;
    tenantId: number;
    id: string;
}

export class FarmCompanyDto implements IFarmCompanyDto {
    name: string | undefined;
    code: number;
    businessName: string | undefined;
    id: string;

    constructor(data?: IFarmCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FarmCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["id"] = this.id;
        return data;
    }

    clone(): FarmCompanyDto {
        const json = this.toJSON();
        let result = new FarmCompanyDto();
        result.init(json);
        return result;
    }
}

export interface IFarmCompanyDto {
    name: string | undefined;
    code: number;
    businessName: string | undefined;
    id: string;
}

export class TagDto implements ITagDto {
    name: string | undefined;
    id: string;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): TagDto {
        const json = this.toJSON();
        let result = new TagDto();
        result.init(json);
        return result;
    }
}

export interface ITagDto {
    name: string | undefined;
    id: string;
}

export class FarmDto implements IFarmDto {
    name: string | undefined;
    code: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    address: AddressDto;
    company: FarmCompanyDto;
    tenantId: number;
    tags: TagDto[] | undefined;
    companyId: string;
    isDeleted: boolean;
    id: string;

    constructor(data?: IFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.company = _data["company"] ? FarmCompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.companyId = _data["companyId"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["companyId"] = this.companyId;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): FarmDto {
        const json = this.toJSON();
        let result = new FarmDto();
        result.init(json);
        return result;
    }
}

export interface IFarmDto {
    name: string | undefined;
    code: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    address: AddressDto;
    company: FarmCompanyDto;
    tenantId: number;
    tags: TagDto[] | undefined;
    companyId: string;
    isDeleted: boolean;
    id: string;
}

export class ActivityDto implements IActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    macroActivityId: string;
    macroActivityName: string | undefined;
    farms: FarmDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.macroActivityId = _data["macroActivityId"];
            this.macroActivityName = _data["macroActivityName"];
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["macroActivityId"] = this.macroActivityId;
        data["macroActivityName"] = this.macroActivityName;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ActivityDto {
        const json = this.toJSON();
        let result = new ActivityDto();
        result.init(json);
        return result;
    }
}

export interface IActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    macroActivityId: string;
    macroActivityName: string | undefined;
    farms: FarmDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateActivityDto implements IUpdateActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    macroActivityId: string;
    farmIds: string[] | undefined;
    id: string;

    constructor(data?: IUpdateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.macroActivityId = _data["macroActivityId"];
            if (Array.isArray(_data["farmIds"])) {
                this.farmIds = [] as any;
                for (let item of _data["farmIds"])
                    this.farmIds.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["macroActivityId"] = this.macroActivityId;
        if (Array.isArray(this.farmIds)) {
            data["farmIds"] = [];
            for (let item of this.farmIds)
                data["farmIds"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateActivityDto {
        const json = this.toJSON();
        let result = new UpdateActivityDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    macroActivityId: string;
    farmIds: string[] | undefined;
    id: string;
}

export class ActivityDtoPagedResultDto implements IActivityDtoPagedResultDto {
    totalCount: number;
    items: ActivityDto[] | undefined;

    constructor(data?: IActivityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ActivityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ActivityDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ActivityDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IActivityDtoPagedResultDto {
    totalCount: number;
    items: ActivityDto[] | undefined;
}

export class AddressDtoPagedResultDto implements IAddressDtoPagedResultDto {
    totalCount: number;
    items: AddressDto[] | undefined;

    constructor(data?: IAddressDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddressDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AddressDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AddressDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAddressDtoPagedResultDto {
    totalCount: number;
    items: AddressDto[] | undefined;
}

export class CreateAddressDto implements ICreateAddressDto {
    address1: string;
    address2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    county: string | undefined;
    country: string;
    countryCode: string;
    postalCode: string | undefined;
    latitude: number;
    longitude: number;
    tenantId: number;

    constructor(data?: ICreateAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.county = _data["county"];
            this.country = _data["country"];
            this.countryCode = _data["countryCode"];
            this.postalCode = _data["postalCode"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["county"] = this.county;
        data["country"] = this.country;
        data["countryCode"] = this.countryCode;
        data["postalCode"] = this.postalCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateAddressDto {
        const json = this.toJSON();
        let result = new CreateAddressDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAddressDto {
    address1: string;
    address2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    county: string | undefined;
    country: string;
    countryCode: string;
    postalCode: string | undefined;
    latitude: number;
    longitude: number;
    tenantId: number;
}

export class UpdateAddressDto implements IUpdateAddressDto {
    address1: string;
    address2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    county: string | undefined;
    country: string;
    countryCode: string;
    postalCode: string | undefined;
    latitude: number;
    longitude: number;
    id: string;

    constructor(data?: IUpdateAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.county = _data["county"];
            this.country = _data["country"];
            this.countryCode = _data["countryCode"];
            this.postalCode = _data["postalCode"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["county"] = this.county;
        data["country"] = this.country;
        data["countryCode"] = this.countryCode;
        data["postalCode"] = this.postalCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateAddressDto {
        const json = this.toJSON();
        let result = new UpdateAddressDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAddressDto {
    address1: string;
    address2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    county: string | undefined;
    country: string;
    countryCode: string;
    postalCode: string | undefined;
    latitude: number;
    longitude: number;
    id: string;
}

export class AFCInfoDto implements IAFCInfoDto {
    admissionDate: moment.Moment;
    value: number;
    afc: boolean;
    id: string;

    constructor(data?: IAFCInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.afc = _data["afc"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AFCInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AFCInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["afc"] = this.afc;
        data["id"] = this.id;
        return data;
    }

    clone(): AFCInfoDto {
        const json = this.toJSON();
        let result = new AFCInfoDto();
        result.init(json);
        return result;
    }
}

export interface IAFCInfoDto {
    admissionDate: moment.Moment;
    value: number;
    afc: boolean;
    id: string;
}

export class AFCInfoDtoPagedResultDto implements IAFCInfoDtoPagedResultDto {
    totalCount: number;
    items: AFCInfoDto[] | undefined;

    constructor(data?: IAFCInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AFCInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AFCInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AFCInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AFCInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AFCInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAFCInfoDtoPagedResultDto {
    totalCount: number;
    items: AFCInfoDto[] | undefined;
}

export class CreateAFCInfoDto implements ICreateAFCInfoDto {
    admissionDate: moment.Moment;
    value: number;
    afc: boolean;

    constructor(data?: ICreateAFCInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.afc = _data["afc"];
        }
    }

    static fromJS(data: any): CreateAFCInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAFCInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["afc"] = this.afc;
        return data;
    }

    clone(): CreateAFCInfoDto {
        const json = this.toJSON();
        let result = new CreateAFCInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAFCInfoDto {
    admissionDate: moment.Moment;
    value: number;
    afc: boolean;
}

export class UpdateAFCInfoDto implements IUpdateAFCInfoDto {
    admissionDate: moment.Moment;
    value: number;
    afc: boolean;
    id: string;

    constructor(data?: IUpdateAFCInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.afc = _data["afc"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAFCInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAFCInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["afc"] = this.afc;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateAFCInfoDto {
        const json = this.toJSON();
        let result = new UpdateAFCInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAFCInfoDto {
    admissionDate: moment.Moment;
    value: number;
    afc: boolean;
    id: string;
}

export class AppProductDto implements IAppProductDto {
    name: string;
    code: string;
    logo: string;
    descripctionKey: string;
    mainProductId: number;
    id: number;

    constructor(data?: IAppProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.logo = _data["logo"];
            this.descripctionKey = _data["descripctionKey"];
            this.mainProductId = _data["mainProductId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["logo"] = this.logo;
        data["descripctionKey"] = this.descripctionKey;
        data["mainProductId"] = this.mainProductId;
        data["id"] = this.id;
        return data;
    }

    clone(): AppProductDto {
        const json = this.toJSON();
        let result = new AppProductDto();
        result.init(json);
        return result;
    }
}

export interface IAppProductDto {
    name: string;
    code: string;
    logo: string;
    descripctionKey: string;
    mainProductId: number;
    id: number;
}

export class AppProductDtoPagedResultDto implements IAppProductDtoPagedResultDto {
    totalCount: number;
    items: AppProductDto[] | undefined;

    constructor(data?: IAppProductDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AppProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppProductDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppProductDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AppProductDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AppProductDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAppProductDtoPagedResultDto {
    totalCount: number;
    items: AppProductDto[] | undefined;
}

export class CreateAppProductSessionDto implements ICreateAppProductSessionDto {
    userId: number;
    code: string;
    deviceId: string | undefined;
    notificationId: string | undefined;
    version: string | undefined;

    constructor(data?: ICreateAppProductSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.code = _data["code"];
            this.deviceId = _data["deviceId"];
            this.notificationId = _data["notificationId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): CreateAppProductSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppProductSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["code"] = this.code;
        data["deviceId"] = this.deviceId;
        data["notificationId"] = this.notificationId;
        data["version"] = this.version;
        return data;
    }

    clone(): CreateAppProductSessionDto {
        const json = this.toJSON();
        let result = new CreateAppProductSessionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAppProductSessionDto {
    userId: number;
    code: string;
    deviceId: string | undefined;
    notificationId: string | undefined;
    version: string | undefined;
}

export class SimpleUserDto implements ISimpleUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    companyId: string | undefined;
    farmId: string | undefined;
    photography: string | undefined;
    id: number;

    constructor(data?: ISimpleUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.fullName = _data["fullName"];
            this.companyId = _data["companyId"];
            this.farmId = _data["farmId"];
            this.photography = _data["photography"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["companyId"] = this.companyId;
        data["farmId"] = this.farmId;
        data["photography"] = this.photography;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleUserDto {
        const json = this.toJSON();
        let result = new SimpleUserDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleUserDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    companyId: string | undefined;
    farmId: string | undefined;
    photography: string | undefined;
    id: number;
}

export class AppProductSessionDto implements IAppProductSessionDto {
    userId: number;
    user: SimpleUserDto;
    appProductId: number;
    appProduct: AppProductDto;
    deviceId: string | undefined;
    notificationId: string | undefined;
    version: string | undefined;
    lastVerificationTime: moment.Moment;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IAppProductSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.user = _data["user"] ? SimpleUserDto.fromJS(_data["user"]) : <any>undefined;
            this.appProductId = _data["appProductId"];
            this.appProduct = _data["appProduct"] ? AppProductDto.fromJS(_data["appProduct"]) : <any>undefined;
            this.deviceId = _data["deviceId"];
            this.notificationId = _data["notificationId"];
            this.version = _data["version"];
            this.lastVerificationTime = _data["lastVerificationTime"] ? moment(_data["lastVerificationTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppProductSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppProductSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["appProductId"] = this.appProductId;
        data["appProduct"] = this.appProduct ? this.appProduct.toJSON() : <any>undefined;
        data["deviceId"] = this.deviceId;
        data["notificationId"] = this.notificationId;
        data["version"] = this.version;
        data["lastVerificationTime"] = this.lastVerificationTime ? this.lastVerificationTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): AppProductSessionDto {
        const json = this.toJSON();
        let result = new AppProductSessionDto();
        result.init(json);
        return result;
    }
}

export interface IAppProductSessionDto {
    userId: number;
    user: SimpleUserDto;
    appProductId: number;
    appProduct: AppProductDto;
    deviceId: string | undefined;
    notificationId: string | undefined;
    version: string | undefined;
    lastVerificationTime: moment.Moment;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateAppProductSessionDto implements IUpdateAppProductSessionDto {
    userId: number;
    code: string;
    deviceId: string | undefined;
    notificationId: string | undefined;
    version: string | undefined;
    id: string;

    constructor(data?: IUpdateAppProductSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.code = _data["code"];
            this.deviceId = _data["deviceId"];
            this.notificationId = _data["notificationId"];
            this.version = _data["version"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAppProductSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppProductSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["code"] = this.code;
        data["deviceId"] = this.deviceId;
        data["notificationId"] = this.notificationId;
        data["version"] = this.version;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateAppProductSessionDto {
        const json = this.toJSON();
        let result = new UpdateAppProductSessionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAppProductSessionDto {
    userId: number;
    code: string;
    deviceId: string | undefined;
    notificationId: string | undefined;
    version: string | undefined;
    id: string;
}

export class AppProductSessionDtoPagedResultDto implements IAppProductSessionDtoPagedResultDto {
    totalCount: number;
    items: AppProductSessionDto[] | undefined;

    constructor(data?: IAppProductSessionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AppProductSessionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppProductSessionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppProductSessionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AppProductSessionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AppProductSessionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAppProductSessionDtoPagedResultDto {
    totalCount: number;
    items: AppProductSessionDto[] | undefined;
}

export class CreateApprovalOrderDto implements ICreateApprovalOrderDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    authorizationMethodId: number;
    id: number;

    constructor(data?: ICreateApprovalOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.authorizationMethodId = _data["authorizationMethodId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateApprovalOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApprovalOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["authorizationMethodId"] = this.authorizationMethodId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateApprovalOrderDto {
        const json = this.toJSON();
        let result = new CreateApprovalOrderDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApprovalOrderDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    authorizationMethodId: number;
    id: number;
}

export class ApprovalTypeDto implements IApprovalTypeDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    approverEntityId: number | undefined;
    id: number;

    constructor(data?: IApprovalTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.approverEntityId = _data["approverEntityId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["approverEntityId"] = this.approverEntityId;
        data["id"] = this.id;
        return data;
    }

    clone(): ApprovalTypeDto {
        const json = this.toJSON();
        let result = new ApprovalTypeDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalTypeDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    approverEntityId: number | undefined;
    id: number;
}

export class AuthorizationMethodDto implements IAuthorizationMethodDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    approvalType: ApprovalTypeDto;
    id: number;

    constructor(data?: IAuthorizationMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.approvalType = _data["approvalType"] ? ApprovalTypeDto.fromJS(_data["approvalType"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuthorizationMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizationMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["approvalType"] = this.approvalType ? this.approvalType.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): AuthorizationMethodDto {
        const json = this.toJSON();
        let result = new AuthorizationMethodDto();
        result.init(json);
        return result;
    }
}

export interface IAuthorizationMethodDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    approvalType: ApprovalTypeDto;
    id: number;
}

export class ApprovalOrderDto implements IApprovalOrderDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    authorizationMethod: AuthorizationMethodDto;
    id: number;

    constructor(data?: IApprovalOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.authorizationMethod = _data["authorizationMethod"] ? AuthorizationMethodDto.fromJS(_data["authorizationMethod"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApprovalOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["authorizationMethod"] = this.authorizationMethod ? this.authorizationMethod.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ApprovalOrderDto {
        const json = this.toJSON();
        let result = new ApprovalOrderDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalOrderDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    authorizationMethod: AuthorizationMethodDto;
    id: number;
}

export class ApprovalOrderDtoPagedResultDto implements IApprovalOrderDtoPagedResultDto {
    totalCount: number;
    items: ApprovalOrderDto[] | undefined;

    constructor(data?: IApprovalOrderDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApprovalOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApprovalOrderDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalOrderDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApprovalOrderDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApprovalOrderDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalOrderDtoPagedResultDto {
    totalCount: number;
    items: ApprovalOrderDto[] | undefined;
}

export class CreateApprovalTypeDto implements ICreateApprovalTypeDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    approverEntityId: number | undefined;
    id: number;

    constructor(data?: ICreateApprovalTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.approverEntityId = _data["approverEntityId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateApprovalTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApprovalTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["approverEntityId"] = this.approverEntityId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateApprovalTypeDto {
        const json = this.toJSON();
        let result = new CreateApprovalTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApprovalTypeDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    approverEntityId: number | undefined;
    id: number;
}

export class ApprovalTypeDtoPagedResultDto implements IApprovalTypeDtoPagedResultDto {
    totalCount: number;
    items: ApprovalTypeDto[] | undefined;

    constructor(data?: IApprovalTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApprovalTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApprovalTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApprovalTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApprovalTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalTypeDtoPagedResultDto {
    totalCount: number;
    items: ApprovalTypeDto[] | undefined;
}

export class CreateApproverEntityDto implements ICreateApproverEntityDto {
    name: string | undefined;
    langKey: string | undefined;
    approverModuleId: number;
    id: number;

    constructor(data?: ICreateApproverEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.approverModuleId = _data["approverModuleId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateApproverEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApproverEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["approverModuleId"] = this.approverModuleId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateApproverEntityDto {
        const json = this.toJSON();
        let result = new CreateApproverEntityDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApproverEntityDto {
    name: string | undefined;
    langKey: string | undefined;
    approverModuleId: number;
    id: number;
}

export class ApproverEntityDto implements IApproverEntityDto {
    name: string | undefined;
    langKey: string | undefined;
    id: number;

    constructor(data?: IApproverEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApproverEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): ApproverEntityDto {
        const json = this.toJSON();
        let result = new ApproverEntityDto();
        result.init(json);
        return result;
    }
}

export interface IApproverEntityDto {
    name: string | undefined;
    langKey: string | undefined;
    id: number;
}

export class ApproverEntityDtoPagedResultDto implements IApproverEntityDtoPagedResultDto {
    totalCount: number;
    items: ApproverEntityDto[] | undefined;

    constructor(data?: IApproverEntityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApproverEntityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApproverEntityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverEntityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApproverEntityDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApproverEntityDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApproverEntityDtoPagedResultDto {
    totalCount: number;
    items: ApproverEntityDto[] | undefined;
}

export class CreateAprroverFamilyConfigDto implements ICreateAprroverFamilyConfigDto {
    productFamilyId: string;
    climbTop: boolean;
    aprroversIds: string[] | undefined;
    id: string;

    constructor(data?: ICreateAprroverFamilyConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productFamilyId = _data["productFamilyId"];
            this.climbTop = _data["climbTop"];
            if (Array.isArray(_data["aprroversIds"])) {
                this.aprroversIds = [] as any;
                for (let item of _data["aprroversIds"])
                    this.aprroversIds.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAprroverFamilyConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAprroverFamilyConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productFamilyId"] = this.productFamilyId;
        data["climbTop"] = this.climbTop;
        if (Array.isArray(this.aprroversIds)) {
            data["aprroversIds"] = [];
            for (let item of this.aprroversIds)
                data["aprroversIds"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAprroverFamilyConfigDto {
        const json = this.toJSON();
        let result = new CreateAprroverFamilyConfigDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAprroverFamilyConfigDto {
    productFamilyId: string;
    climbTop: boolean;
    aprroversIds: string[] | undefined;
    id: string;
}

export class CreateAprroverConfigDto implements ICreateAprroverConfigDto {
    approverId: string;
    level: number;
    id: string;

    constructor(data?: ICreateAprroverConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approverId = _data["approverId"];
            this.level = _data["level"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAprroverConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAprroverConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approverId"] = this.approverId;
        data["level"] = this.level;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAprroverConfigDto {
        const json = this.toJSON();
        let result = new CreateAprroverConfigDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAprroverConfigDto {
    approverId: string;
    level: number;
    id: string;
}

export class CreateApproverEntityConfigDto implements ICreateApproverEntityConfigDto {
    approverEntityId: number;
    farmId: string;
    approvalTypeId: number;
    authorizationMethodId: number | undefined;
    approvalOrderId: number | undefined;
    approverFamilyConfigIds: CreateAprroverFamilyConfigDto[] | undefined;
    aprroverConfigIds: CreateAprroverConfigDto[] | undefined;
    numberSignatures: number | undefined;
    waitingPeriod: number | undefined;
    id: number;

    constructor(data?: ICreateApproverEntityConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approverEntityId = _data["approverEntityId"];
            this.farmId = _data["farmId"];
            this.approvalTypeId = _data["approvalTypeId"];
            this.authorizationMethodId = _data["authorizationMethodId"];
            this.approvalOrderId = _data["approvalOrderId"];
            if (Array.isArray(_data["approverFamilyConfigIds"])) {
                this.approverFamilyConfigIds = [] as any;
                for (let item of _data["approverFamilyConfigIds"])
                    this.approverFamilyConfigIds.push(CreateAprroverFamilyConfigDto.fromJS(item));
            }
            if (Array.isArray(_data["aprroverConfigIds"])) {
                this.aprroverConfigIds = [] as any;
                for (let item of _data["aprroverConfigIds"])
                    this.aprroverConfigIds.push(CreateAprroverConfigDto.fromJS(item));
            }
            this.numberSignatures = _data["numberSignatures"];
            this.waitingPeriod = _data["waitingPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateApproverEntityConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApproverEntityConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approverEntityId"] = this.approverEntityId;
        data["farmId"] = this.farmId;
        data["approvalTypeId"] = this.approvalTypeId;
        data["authorizationMethodId"] = this.authorizationMethodId;
        data["approvalOrderId"] = this.approvalOrderId;
        if (Array.isArray(this.approverFamilyConfigIds)) {
            data["approverFamilyConfigIds"] = [];
            for (let item of this.approverFamilyConfigIds)
                data["approverFamilyConfigIds"].push(item.toJSON());
        }
        if (Array.isArray(this.aprroverConfigIds)) {
            data["aprroverConfigIds"] = [];
            for (let item of this.aprroverConfigIds)
                data["aprroverConfigIds"].push(item.toJSON());
        }
        data["numberSignatures"] = this.numberSignatures;
        data["waitingPeriod"] = this.waitingPeriod;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateApproverEntityConfigDto {
        const json = this.toJSON();
        let result = new CreateApproverEntityConfigDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApproverEntityConfigDto {
    approverEntityId: number;
    farmId: string;
    approvalTypeId: number;
    authorizationMethodId: number | undefined;
    approvalOrderId: number | undefined;
    approverFamilyConfigIds: CreateAprroverFamilyConfigDto[] | undefined;
    aprroverConfigIds: CreateAprroverConfigDto[] | undefined;
    numberSignatures: number | undefined;
    waitingPeriod: number | undefined;
    id: number;
}

export class MainProductDto implements IMainProductDto {
    name: string;
    code: string;
    logo: string;
    descripctionKey: string;
    id: number;

    constructor(data?: IMainProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.logo = _data["logo"];
            this.descripctionKey = _data["descripctionKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MainProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["logo"] = this.logo;
        data["descripctionKey"] = this.descripctionKey;
        data["id"] = this.id;
        return data;
    }

    clone(): MainProductDto {
        const json = this.toJSON();
        let result = new MainProductDto();
        result.init(json);
        return result;
    }
}

export interface IMainProductDto {
    name: string;
    code: string;
    logo: string;
    descripctionKey: string;
    id: number;
}

export class FarmUserDto implements IFarmUserDto {
    name: string | undefined;
    code: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    companyId: string;
    id: string;

    constructor(data?: IFarmUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FarmUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data;
    }

    clone(): FarmUserDto {
        const json = this.toJSON();
        let result = new FarmUserDto();
        result.init(json);
        return result;
    }
}

export interface IFarmUserDto {
    name: string | undefined;
    code: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    companyId: string;
    id: string;
}

export class CompanyUserDto implements ICompanyUserDto {
    name: string;
    code: number;
    businessName: string;
    logo: string | undefined;
    tenantId: number;
    isDeleted: number;
    farms: FarmUserDto[] | undefined;
    id: string;

    constructor(data?: ICompanyUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.logo = _data["logo"];
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmUserDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["logo"] = this.logo;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyUserDto {
        const json = this.toJSON();
        let result = new CompanyUserDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyUserDto {
    name: string;
    code: number;
    businessName: string;
    logo: string | undefined;
    tenantId: number;
    isDeleted: number;
    farms: FarmUserDto[] | undefined;
    id: string;
}

export class FileDto implements IFileDto {
    base64: string | undefined;
    name: string | undefined;
    mimeType: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64 = _data["base64"];
            this.name = _data["name"];
            this.mimeType = _data["mimeType"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64"] = this.base64;
        data["name"] = this.name;
        data["mimeType"] = this.mimeType;
        return data;
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    base64: string | undefined;
    name: string | undefined;
    mimeType: string | undefined;
}

export class SignatureInfoDto implements ISignatureInfoDto {
    idFrontImage: string | undefined;
    frontImage: FileDto;
    idBackImage: string | undefined;
    backImage: FileDto;
    signImage: string | undefined;
    signatureImage: FileDto;
    workerId: string | undefined;
    userId: number | undefined;
    id: string;

    constructor(data?: ISignatureInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idFrontImage = _data["idFrontImage"];
            this.frontImage = _data["frontImage"] ? FileDto.fromJS(_data["frontImage"]) : <any>undefined;
            this.idBackImage = _data["idBackImage"];
            this.backImage = _data["backImage"] ? FileDto.fromJS(_data["backImage"]) : <any>undefined;
            this.signImage = _data["signImage"];
            this.signatureImage = _data["signatureImage"] ? FileDto.fromJS(_data["signatureImage"]) : <any>undefined;
            this.workerId = _data["workerId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SignatureInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignatureInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idFrontImage"] = this.idFrontImage;
        data["frontImage"] = this.frontImage ? this.frontImage.toJSON() : <any>undefined;
        data["idBackImage"] = this.idBackImage;
        data["backImage"] = this.backImage ? this.backImage.toJSON() : <any>undefined;
        data["signImage"] = this.signImage;
        data["signatureImage"] = this.signatureImage ? this.signatureImage.toJSON() : <any>undefined;
        data["workerId"] = this.workerId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data;
    }

    clone(): SignatureInfoDto {
        const json = this.toJSON();
        let result = new SignatureInfoDto();
        result.init(json);
        return result;
    }
}

export interface ISignatureInfoDto {
    idFrontImage: string | undefined;
    frontImage: FileDto;
    idBackImage: string | undefined;
    backImage: FileDto;
    signImage: string | undefined;
    signatureImage: FileDto;
    workerId: string | undefined;
    userId: number | undefined;
    id: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    mainProducts: MainProductDto[] | undefined;
    appProducts: AppProductDto[] | undefined;
    companyId: string | undefined;
    farmId: string | undefined;
    representedCompanies: CompanyUserDto[] | undefined;
    companies: CompanyUserDto[] | undefined;
    farms: FarmDto[] | undefined;
    photography: string | undefined;
    languageName: string | undefined;
    signatureInfo: SignatureInfoDto;
    isDeleted: boolean;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            if (Array.isArray(_data["mainProducts"])) {
                this.mainProducts = [] as any;
                for (let item of _data["mainProducts"])
                    this.mainProducts.push(MainProductDto.fromJS(item));
            }
            if (Array.isArray(_data["appProducts"])) {
                this.appProducts = [] as any;
                for (let item of _data["appProducts"])
                    this.appProducts.push(AppProductDto.fromJS(item));
            }
            this.companyId = _data["companyId"];
            this.farmId = _data["farmId"];
            if (Array.isArray(_data["representedCompanies"])) {
                this.representedCompanies = [] as any;
                for (let item of _data["representedCompanies"])
                    this.representedCompanies.push(CompanyUserDto.fromJS(item));
            }
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies.push(CompanyUserDto.fromJS(item));
            }
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.photography = _data["photography"];
            this.languageName = _data["languageName"];
            this.signatureInfo = _data["signatureInfo"] ? SignatureInfoDto.fromJS(_data["signatureInfo"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.mainProducts)) {
            data["mainProducts"] = [];
            for (let item of this.mainProducts)
                data["mainProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.appProducts)) {
            data["appProducts"] = [];
            for (let item of this.appProducts)
                data["appProducts"].push(item.toJSON());
        }
        data["companyId"] = this.companyId;
        data["farmId"] = this.farmId;
        if (Array.isArray(this.representedCompanies)) {
            data["representedCompanies"] = [];
            for (let item of this.representedCompanies)
                data["representedCompanies"].push(item.toJSON());
        }
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item.toJSON());
        }
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["photography"] = this.photography;
        data["languageName"] = this.languageName;
        data["signatureInfo"] = this.signatureInfo ? this.signatureInfo.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    mainProducts: MainProductDto[] | undefined;
    appProducts: AppProductDto[] | undefined;
    companyId: string | undefined;
    farmId: string | undefined;
    representedCompanies: CompanyUserDto[] | undefined;
    companies: CompanyUserDto[] | undefined;
    farms: FarmDto[] | undefined;
    photography: string | undefined;
    languageName: string | undefined;
    signatureInfo: SignatureInfoDto;
    isDeleted: boolean;
    id: number;
}

export class JobTitleDto implements IJobTitleDto {
    name: string | undefined;
    description: string | undefined;
    companyId: string | undefined;
    supervisorId: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.companyId = _data["companyId"];
            this.supervisorId = _data["supervisorId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): JobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["companyId"] = this.companyId;
        data["supervisorId"] = this.supervisorId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): JobTitleDto {
        const json = this.toJSON();
        let result = new JobTitleDto();
        result.init(json);
        return result;
    }
}

export interface IJobTitleDto {
    name: string | undefined;
    description: string | undefined;
    companyId: string | undefined;
    supervisorId: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class ApproverDto implements IApproverDto {
    user: UserDto;
    jobTitle: JobTitleDto;
    approvalLimit: number;
    signature: string | undefined;
    delegatedSignatureUser: UserDto;
    isActive: boolean;
    id: string;

    constructor(data?: IApproverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.jobTitle = _data["jobTitle"] ? JobTitleDto.fromJS(_data["jobTitle"]) : <any>undefined;
            this.approvalLimit = _data["approvalLimit"];
            this.signature = _data["signature"];
            this.delegatedSignatureUser = _data["delegatedSignatureUser"] ? UserDto.fromJS(_data["delegatedSignatureUser"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApproverDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["approvalLimit"] = this.approvalLimit;
        data["signature"] = this.signature;
        data["delegatedSignatureUser"] = this.delegatedSignatureUser ? this.delegatedSignatureUser.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): ApproverDto {
        const json = this.toJSON();
        let result = new ApproverDto();
        result.init(json);
        return result;
    }
}

export interface IApproverDto {
    user: UserDto;
    jobTitle: JobTitleDto;
    approvalLimit: number;
    signature: string | undefined;
    delegatedSignatureUser: UserDto;
    isActive: boolean;
    id: string;
}

export class AprroverFamilyConfigDto implements IAprroverFamilyConfigDto {
    productFamilyId: string;
    productFamilyName: string | undefined;
    climbTop: boolean;
    approvers: ApproverDto[] | undefined;
    id: string;

    constructor(data?: IAprroverFamilyConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productFamilyId = _data["productFamilyId"];
            this.productFamilyName = _data["productFamilyName"];
            this.climbTop = _data["climbTop"];
            if (Array.isArray(_data["approvers"])) {
                this.approvers = [] as any;
                for (let item of _data["approvers"])
                    this.approvers.push(ApproverDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AprroverFamilyConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AprroverFamilyConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productFamilyId"] = this.productFamilyId;
        data["productFamilyName"] = this.productFamilyName;
        data["climbTop"] = this.climbTop;
        if (Array.isArray(this.approvers)) {
            data["approvers"] = [];
            for (let item of this.approvers)
                data["approvers"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): AprroverFamilyConfigDto {
        const json = this.toJSON();
        let result = new AprroverFamilyConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAprroverFamilyConfigDto {
    productFamilyId: string;
    productFamilyName: string | undefined;
    climbTop: boolean;
    approvers: ApproverDto[] | undefined;
    id: string;
}

export class AprroverConfigDto implements IAprroverConfigDto {
    approver: ApproverDto;
    level: number;
    id: string;

    constructor(data?: IAprroverConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approver = _data["approver"] ? ApproverDto.fromJS(_data["approver"]) : <any>undefined;
            this.level = _data["level"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AprroverConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AprroverConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approver"] = this.approver ? this.approver.toJSON() : <any>undefined;
        data["level"] = this.level;
        data["id"] = this.id;
        return data;
    }

    clone(): AprroverConfigDto {
        const json = this.toJSON();
        let result = new AprroverConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAprroverConfigDto {
    approver: ApproverDto;
    level: number;
    id: string;
}

export class ApproverEntityConfigDto implements IApproverEntityConfigDto {
    approverEntity: ApproverEntityDto;
    farm: FarmDto;
    approvalType: ApprovalTypeDto;
    authorizationMethod: AuthorizationMethodDto;
    approvalOrder: ApprovalOrderDto;
    aprroverFamilyConfigs: AprroverFamilyConfigDto[] | undefined;
    aprroverConfigs: AprroverConfigDto[] | undefined;
    numberSignatures: number | undefined;
    waitingPeriod: number | undefined;
    id: number;

    constructor(data?: IApproverEntityConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approverEntity = _data["approverEntity"] ? ApproverEntityDto.fromJS(_data["approverEntity"]) : <any>undefined;
            this.farm = _data["farm"] ? FarmDto.fromJS(_data["farm"]) : <any>undefined;
            this.approvalType = _data["approvalType"] ? ApprovalTypeDto.fromJS(_data["approvalType"]) : <any>undefined;
            this.authorizationMethod = _data["authorizationMethod"] ? AuthorizationMethodDto.fromJS(_data["authorizationMethod"]) : <any>undefined;
            this.approvalOrder = _data["approvalOrder"] ? ApprovalOrderDto.fromJS(_data["approvalOrder"]) : <any>undefined;
            if (Array.isArray(_data["aprroverFamilyConfigs"])) {
                this.aprroverFamilyConfigs = [] as any;
                for (let item of _data["aprroverFamilyConfigs"])
                    this.aprroverFamilyConfigs.push(AprroverFamilyConfigDto.fromJS(item));
            }
            if (Array.isArray(_data["aprroverConfigs"])) {
                this.aprroverConfigs = [] as any;
                for (let item of _data["aprroverConfigs"])
                    this.aprroverConfigs.push(AprroverConfigDto.fromJS(item));
            }
            this.numberSignatures = _data["numberSignatures"];
            this.waitingPeriod = _data["waitingPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApproverEntityConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverEntityConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approverEntity"] = this.approverEntity ? this.approverEntity.toJSON() : <any>undefined;
        data["farm"] = this.farm ? this.farm.toJSON() : <any>undefined;
        data["approvalType"] = this.approvalType ? this.approvalType.toJSON() : <any>undefined;
        data["authorizationMethod"] = this.authorizationMethod ? this.authorizationMethod.toJSON() : <any>undefined;
        data["approvalOrder"] = this.approvalOrder ? this.approvalOrder.toJSON() : <any>undefined;
        if (Array.isArray(this.aprroverFamilyConfigs)) {
            data["aprroverFamilyConfigs"] = [];
            for (let item of this.aprroverFamilyConfigs)
                data["aprroverFamilyConfigs"].push(item.toJSON());
        }
        if (Array.isArray(this.aprroverConfigs)) {
            data["aprroverConfigs"] = [];
            for (let item of this.aprroverConfigs)
                data["aprroverConfigs"].push(item.toJSON());
        }
        data["numberSignatures"] = this.numberSignatures;
        data["waitingPeriod"] = this.waitingPeriod;
        data["id"] = this.id;
        return data;
    }

    clone(): ApproverEntityConfigDto {
        const json = this.toJSON();
        let result = new ApproverEntityConfigDto();
        result.init(json);
        return result;
    }
}

export interface IApproverEntityConfigDto {
    approverEntity: ApproverEntityDto;
    farm: FarmDto;
    approvalType: ApprovalTypeDto;
    authorizationMethod: AuthorizationMethodDto;
    approvalOrder: ApprovalOrderDto;
    aprroverFamilyConfigs: AprroverFamilyConfigDto[] | undefined;
    aprroverConfigs: AprroverConfigDto[] | undefined;
    numberSignatures: number | undefined;
    waitingPeriod: number | undefined;
    id: number;
}

export class ApproverEntityConfigDtoPagedResultDto implements IApproverEntityConfigDtoPagedResultDto {
    totalCount: number;
    items: ApproverEntityConfigDto[] | undefined;

    constructor(data?: IApproverEntityConfigDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApproverEntityConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApproverEntityConfigDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverEntityConfigDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApproverEntityConfigDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApproverEntityConfigDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApproverEntityConfigDtoPagedResultDto {
    totalCount: number;
    items: ApproverEntityConfigDto[] | undefined;
}

export class CreateApproverModuleDto implements ICreateApproverModuleDto {
    name: string | undefined;
    langKey: string | undefined;
    permissionName: string | undefined;
    id: number;

    constructor(data?: ICreateApproverModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.permissionName = _data["permissionName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateApproverModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApproverModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["permissionName"] = this.permissionName;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateApproverModuleDto {
        const json = this.toJSON();
        let result = new CreateApproverModuleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApproverModuleDto {
    name: string | undefined;
    langKey: string | undefined;
    permissionName: string | undefined;
    id: number;
}

export class ApproverModuleDto implements IApproverModuleDto {
    name: string | undefined;
    langKey: string | undefined;
    permissionName: string | undefined;
    approverEntities: ApproverEntityDto[] | undefined;
    id: number;

    constructor(data?: IApproverModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.permissionName = _data["permissionName"];
            if (Array.isArray(_data["approverEntities"])) {
                this.approverEntities = [] as any;
                for (let item of _data["approverEntities"])
                    this.approverEntities.push(ApproverEntityDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApproverModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["permissionName"] = this.permissionName;
        if (Array.isArray(this.approverEntities)) {
            data["approverEntities"] = [];
            for (let item of this.approverEntities)
                data["approverEntities"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): ApproverModuleDto {
        const json = this.toJSON();
        let result = new ApproverModuleDto();
        result.init(json);
        return result;
    }
}

export interface IApproverModuleDto {
    name: string | undefined;
    langKey: string | undefined;
    permissionName: string | undefined;
    approverEntities: ApproverEntityDto[] | undefined;
    id: number;
}

export class ApproverModuleDtoPagedResultDto implements IApproverModuleDtoPagedResultDto {
    totalCount: number;
    items: ApproverModuleDto[] | undefined;

    constructor(data?: IApproverModuleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApproverModuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApproverModuleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverModuleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApproverModuleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApproverModuleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApproverModuleDtoPagedResultDto {
    totalCount: number;
    items: ApproverModuleDto[] | undefined;
}

export class AprroverConfigDtoPagedResultDto implements IAprroverConfigDtoPagedResultDto {
    totalCount: number;
    items: AprroverConfigDto[] | undefined;

    constructor(data?: IAprroverConfigDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AprroverConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AprroverConfigDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AprroverConfigDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AprroverConfigDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AprroverConfigDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAprroverConfigDtoPagedResultDto {
    totalCount: number;
    items: AprroverConfigDto[] | undefined;
}

export class AprroverFamilyConfigDtoPagedResultDto implements IAprroverFamilyConfigDtoPagedResultDto {
    totalCount: number;
    items: AprroverFamilyConfigDto[] | undefined;

    constructor(data?: IAprroverFamilyConfigDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AprroverFamilyConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AprroverFamilyConfigDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AprroverFamilyConfigDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AprroverFamilyConfigDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AprroverFamilyConfigDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAprroverFamilyConfigDtoPagedResultDto {
    totalCount: number;
    items: AprroverFamilyConfigDto[] | undefined;
}

export class CreateAttendanceDto implements ICreateAttendanceDto {
    startDate: moment.Moment;
    workerId: string | undefined;
    fullNameWorker: string;
    dniWorker: string;
    actionTypeId: number;
    contractorId: string | undefined;
    dniContractor: string | undefined;
    farmId: string;
    entranceId: string | undefined;
    notes: string | undefined;
    filePhoto: FileDto;
    origin: string | undefined;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    remoteIp: string | undefined;
    userAgent: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ICreateAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.workerId = _data["workerId"];
            this.fullNameWorker = _data["fullNameWorker"];
            this.dniWorker = _data["dniWorker"];
            this.actionTypeId = _data["actionTypeId"];
            this.contractorId = _data["contractorId"];
            this.dniContractor = _data["dniContractor"];
            this.farmId = _data["farmId"];
            this.entranceId = _data["entranceId"];
            this.notes = _data["notes"];
            this.filePhoto = _data["filePhoto"] ? FileDto.fromJS(_data["filePhoto"]) : <any>undefined;
            this.origin = _data["origin"];
            this.deviceId = _data["deviceId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.remoteIp = _data["remoteIp"];
            this.userAgent = _data["userAgent"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAttendanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["workerId"] = this.workerId;
        data["fullNameWorker"] = this.fullNameWorker;
        data["dniWorker"] = this.dniWorker;
        data["actionTypeId"] = this.actionTypeId;
        data["contractorId"] = this.contractorId;
        data["dniContractor"] = this.dniContractor;
        data["farmId"] = this.farmId;
        data["entranceId"] = this.entranceId;
        data["notes"] = this.notes;
        data["filePhoto"] = this.filePhoto ? this.filePhoto.toJSON() : <any>undefined;
        data["origin"] = this.origin;
        data["deviceId"] = this.deviceId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["remoteIp"] = this.remoteIp;
        data["userAgent"] = this.userAgent;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAttendanceDto {
        const json = this.toJSON();
        let result = new CreateAttendanceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAttendanceDto {
    startDate: moment.Moment;
    workerId: string | undefined;
    fullNameWorker: string;
    dniWorker: string;
    actionTypeId: number;
    contractorId: string | undefined;
    dniContractor: string | undefined;
    farmId: string;
    entranceId: string | undefined;
    notes: string | undefined;
    filePhoto: FileDto;
    origin: string | undefined;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    remoteIp: string | undefined;
    userAgent: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class CreateVehicleEntranceDto implements ICreateVehicleEntranceDto {
    startDate: moment.Moment;
    entranceId: string;
    actionTypeId: number;
    transportId: string | undefined;
    plateNumber: string;
    driverName: string;
    driverIdNumber: string;
    observations: string | undefined;
    numberWorkers: number;
    origin: string;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    allAttendances: CreateAttendanceDto[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ICreateVehicleEntranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.entranceId = _data["entranceId"];
            this.actionTypeId = _data["actionTypeId"];
            this.transportId = _data["transportId"];
            this.plateNumber = _data["plateNumber"];
            this.driverName = _data["driverName"];
            this.driverIdNumber = _data["driverIdNumber"];
            this.observations = _data["observations"];
            this.numberWorkers = _data["numberWorkers"];
            this.origin = _data["origin"];
            this.deviceId = _data["deviceId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            if (Array.isArray(_data["allAttendances"])) {
                this.allAttendances = [] as any;
                for (let item of _data["allAttendances"])
                    this.allAttendances.push(CreateAttendanceDto.fromJS(item));
            }
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateVehicleEntranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleEntranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["entranceId"] = this.entranceId;
        data["actionTypeId"] = this.actionTypeId;
        data["transportId"] = this.transportId;
        data["plateNumber"] = this.plateNumber;
        data["driverName"] = this.driverName;
        data["driverIdNumber"] = this.driverIdNumber;
        data["observations"] = this.observations;
        data["numberWorkers"] = this.numberWorkers;
        data["origin"] = this.origin;
        data["deviceId"] = this.deviceId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        if (Array.isArray(this.allAttendances)) {
            data["allAttendances"] = [];
            for (let item of this.allAttendances)
                data["allAttendances"].push(item.toJSON());
        }
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateVehicleEntranceDto {
        const json = this.toJSON();
        let result = new CreateVehicleEntranceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateVehicleEntranceDto {
    startDate: moment.Moment;
    entranceId: string;
    actionTypeId: number;
    transportId: string | undefined;
    plateNumber: string;
    driverName: string;
    driverIdNumber: string;
    observations: string | undefined;
    numberWorkers: number;
    origin: string;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    allAttendances: CreateAttendanceDto[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class SimpleEntranceDto implements ISimpleEntranceDto {
    name: string | undefined;
    description: string | undefined;
    id: string;

    constructor(data?: ISimpleEntranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleEntranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleEntranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleEntranceDto {
        const json = this.toJSON();
        let result = new SimpleEntranceDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleEntranceDto {
    name: string | undefined;
    description: string | undefined;
    id: string;
}

export class TransportTypeDto implements ITransportTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: number;

    constructor(data?: ITransportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TransportTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): TransportTypeDto {
        const json = this.toJSON();
        let result = new TransportTypeDto();
        result.init(json);
        return result;
    }
}

export interface ITransportTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: number;
}

export class TransportClassificationDto implements ITransportClassificationDto {
    name: string;
    description: string | undefined;
    langKey: string | undefined;
    id: number;

    constructor(data?: ITransportClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TransportClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): TransportClassificationDto {
        const json = this.toJSON();
        let result = new TransportClassificationDto();
        result.init(json);
        return result;
    }
}

export interface ITransportClassificationDto {
    name: string;
    description: string | undefined;
    langKey: string | undefined;
    id: number;
}

export class SimpleTransportDto implements ISimpleTransportDto {
    name: string | undefined;
    description: string | undefined;
    plateNumber: string | undefined;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    transportType: TransportTypeDto;
    transportClassification: TransportClassificationDto;
    id: string;

    constructor(data?: ISimpleTransportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.plateNumber = _data["plateNumber"];
            this.driverName = _data["driverName"];
            this.driverIdNumber = _data["driverIdNumber"];
            this.transportType = _data["transportType"] ? TransportTypeDto.fromJS(_data["transportType"]) : <any>undefined;
            this.transportClassification = _data["transportClassification"] ? TransportClassificationDto.fromJS(_data["transportClassification"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleTransportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleTransportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["plateNumber"] = this.plateNumber;
        data["driverName"] = this.driverName;
        data["driverIdNumber"] = this.driverIdNumber;
        data["transportType"] = this.transportType ? this.transportType.toJSON() : <any>undefined;
        data["transportClassification"] = this.transportClassification ? this.transportClassification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleTransportDto {
        const json = this.toJSON();
        let result = new SimpleTransportDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleTransportDto {
    name: string | undefined;
    description: string | undefined;
    plateNumber: string | undefined;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    transportType: TransportTypeDto;
    transportClassification: TransportClassificationDto;
    id: string;
}

export class SimpleWorkerDto implements ISimpleWorkerDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    readonly fullName: string | undefined;
    photo: string | undefined;
    code: string | undefined;
    faceId: string;
    identificationNumber: string | undefined;
    id: string;

    constructor(data?: ISimpleWorkerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
            this.photo = _data["photo"];
            this.code = _data["code"];
            this.faceId = _data["faceId"];
            this.identificationNumber = _data["identificationNumber"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleWorkerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleWorkerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["photo"] = this.photo;
        data["code"] = this.code;
        data["faceId"] = this.faceId;
        data["identificationNumber"] = this.identificationNumber;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleWorkerDto {
        const json = this.toJSON();
        let result = new SimpleWorkerDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleWorkerDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    photo: string | undefined;
    code: string | undefined;
    faceId: string;
    identificationNumber: string | undefined;
    id: string;
}

export class DocumentDto implements IDocumentDto {
    name: string;
    description: string | undefined;
    path: string;
    id: string;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.path = _data["path"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["path"] = this.path;
        data["id"] = this.id;
        return data;
    }

    clone(): DocumentDto {
        const json = this.toJSON();
        let result = new DocumentDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentDto {
    name: string;
    description: string | undefined;
    path: string;
    id: string;
}

export class ContractorDto implements IContractorDto {
    dni: string;
    name: string;
    businessName: string;
    legalRepresentativeDni: string;
    legalRepresentativeName: string;
    phone: string;
    email: string;
    address: AddressDto;
    folio: number;
    chore: string | undefined;
    documents: DocumentDto[] | undefined;
    tenantId: number;
    id: string;

    constructor(data?: IContractorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dni = _data["dni"];
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.legalRepresentativeDni = _data["legalRepresentativeDni"];
            this.legalRepresentativeName = _data["legalRepresentativeName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.folio = _data["folio"];
            this.chore = _data["chore"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents.push(DocumentDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dni"] = this.dni;
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["legalRepresentativeDni"] = this.legalRepresentativeDni;
        data["legalRepresentativeName"] = this.legalRepresentativeName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["folio"] = this.folio;
        data["chore"] = this.chore;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractorDto {
        const json = this.toJSON();
        let result = new ContractorDto();
        result.init(json);
        return result;
    }
}

export interface IContractorDto {
    dni: string;
    name: string;
    businessName: string;
    legalRepresentativeDni: string;
    legalRepresentativeName: string;
    phone: string;
    email: string;
    address: AddressDto;
    folio: number;
    chore: string | undefined;
    documents: DocumentDto[] | undefined;
    tenantId: number;
    id: string;
}

export class AttendanceFarmDto implements IAttendanceFarmDto {
    id: string;
    name: string | undefined;
    code: string | undefined;

    constructor(data?: IAttendanceFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): AttendanceFarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceFarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }

    clone(): AttendanceFarmDto {
        const json = this.toJSON();
        let result = new AttendanceFarmDto();
        result.init(json);
        return result;
    }
}

export interface IAttendanceFarmDto {
    id: string;
    name: string | undefined;
    code: string | undefined;
}

export class SimpleVehicleEntranceDto implements ISimpleVehicleEntranceDto {
    startDate: moment.Moment;
    transportId: string | undefined;
    transport: SimpleTransportDto;
    plateNumber: string | undefined;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    observations: string | undefined;
    numberWorkers: number;
    origin: string | undefined;
    remoteIp: string | undefined;
    userAgent: string | undefined;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;

    constructor(data?: ISimpleVehicleEntranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.transportId = _data["transportId"];
            this.transport = _data["transport"] ? SimpleTransportDto.fromJS(_data["transport"]) : <any>undefined;
            this.plateNumber = _data["plateNumber"];
            this.driverName = _data["driverName"];
            this.driverIdNumber = _data["driverIdNumber"];
            this.observations = _data["observations"];
            this.numberWorkers = _data["numberWorkers"];
            this.origin = _data["origin"];
            this.remoteIp = _data["remoteIp"];
            this.userAgent = _data["userAgent"];
            this.deviceId = _data["deviceId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): SimpleVehicleEntranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleVehicleEntranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["transportId"] = this.transportId;
        data["transport"] = this.transport ? this.transport.toJSON() : <any>undefined;
        data["plateNumber"] = this.plateNumber;
        data["driverName"] = this.driverName;
        data["driverIdNumber"] = this.driverIdNumber;
        data["observations"] = this.observations;
        data["numberWorkers"] = this.numberWorkers;
        data["origin"] = this.origin;
        data["remoteIp"] = this.remoteIp;
        data["userAgent"] = this.userAgent;
        data["deviceId"] = this.deviceId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }

    clone(): SimpleVehicleEntranceDto {
        const json = this.toJSON();
        let result = new SimpleVehicleEntranceDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleVehicleEntranceDto {
    startDate: moment.Moment;
    transportId: string | undefined;
    transport: SimpleTransportDto;
    plateNumber: string | undefined;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    observations: string | undefined;
    numberWorkers: number;
    origin: string | undefined;
    remoteIp: string | undefined;
    userAgent: string | undefined;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
}

export class AttendanceDto implements IAttendanceDto {
    startDate: moment.Moment;
    worker: SimpleWorkerDto;
    workerId: string;
    fullNameWorker: string | undefined;
    dniWorker: string | undefined;
    actionTypeId: number;
    actionType: ActionTypeDto;
    contractor: ContractorDto;
    contractorId: string | undefined;
    dniContractor: string | undefined;
    farm: AttendanceFarmDto;
    farmId: string;
    entranceId: string | undefined;
    entrance: SimpleEntranceDto;
    vehicleEntranceId: string | undefined;
    vehicleEntrance: SimpleVehicleEntranceDto;
    notes: string | undefined;
    photo: string | undefined;
    faceId: string | undefined;
    machImages: boolean;
    checked: boolean;
    percent: number;
    id: string;

    constructor(data?: IAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.worker = _data["worker"] ? SimpleWorkerDto.fromJS(_data["worker"]) : <any>undefined;
            this.workerId = _data["workerId"];
            this.fullNameWorker = _data["fullNameWorker"];
            this.dniWorker = _data["dniWorker"];
            this.actionTypeId = _data["actionTypeId"];
            this.actionType = _data["actionType"] ? ActionTypeDto.fromJS(_data["actionType"]) : <any>undefined;
            this.contractor = _data["contractor"] ? ContractorDto.fromJS(_data["contractor"]) : <any>undefined;
            this.contractorId = _data["contractorId"];
            this.dniContractor = _data["dniContractor"];
            this.farm = _data["farm"] ? AttendanceFarmDto.fromJS(_data["farm"]) : <any>undefined;
            this.farmId = _data["farmId"];
            this.entranceId = _data["entranceId"];
            this.entrance = _data["entrance"] ? SimpleEntranceDto.fromJS(_data["entrance"]) : <any>undefined;
            this.vehicleEntranceId = _data["vehicleEntranceId"];
            this.vehicleEntrance = _data["vehicleEntrance"] ? SimpleVehicleEntranceDto.fromJS(_data["vehicleEntrance"]) : <any>undefined;
            this.notes = _data["notes"];
            this.photo = _data["photo"];
            this.faceId = _data["faceId"];
            this.machImages = _data["machImages"];
            this.checked = _data["checked"];
            this.percent = _data["percent"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AttendanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        data["workerId"] = this.workerId;
        data["fullNameWorker"] = this.fullNameWorker;
        data["dniWorker"] = this.dniWorker;
        data["actionTypeId"] = this.actionTypeId;
        data["actionType"] = this.actionType ? this.actionType.toJSON() : <any>undefined;
        data["contractor"] = this.contractor ? this.contractor.toJSON() : <any>undefined;
        data["contractorId"] = this.contractorId;
        data["dniContractor"] = this.dniContractor;
        data["farm"] = this.farm ? this.farm.toJSON() : <any>undefined;
        data["farmId"] = this.farmId;
        data["entranceId"] = this.entranceId;
        data["entrance"] = this.entrance ? this.entrance.toJSON() : <any>undefined;
        data["vehicleEntranceId"] = this.vehicleEntranceId;
        data["vehicleEntrance"] = this.vehicleEntrance ? this.vehicleEntrance.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["photo"] = this.photo;
        data["faceId"] = this.faceId;
        data["machImages"] = this.machImages;
        data["checked"] = this.checked;
        data["percent"] = this.percent;
        data["id"] = this.id;
        return data;
    }

    clone(): AttendanceDto {
        const json = this.toJSON();
        let result = new AttendanceDto();
        result.init(json);
        return result;
    }
}

export interface IAttendanceDto {
    startDate: moment.Moment;
    worker: SimpleWorkerDto;
    workerId: string;
    fullNameWorker: string | undefined;
    dniWorker: string | undefined;
    actionTypeId: number;
    actionType: ActionTypeDto;
    contractor: ContractorDto;
    contractorId: string | undefined;
    dniContractor: string | undefined;
    farm: AttendanceFarmDto;
    farmId: string;
    entranceId: string | undefined;
    entrance: SimpleEntranceDto;
    vehicleEntranceId: string | undefined;
    vehicleEntrance: SimpleVehicleEntranceDto;
    notes: string | undefined;
    photo: string | undefined;
    faceId: string | undefined;
    machImages: boolean;
    checked: boolean;
    percent: number;
    id: string;
}

export class VehicleEntranceDto implements IVehicleEntranceDto {
    startDate: moment.Moment;
    entranceId: string;
    entrance: SimpleEntranceDto;
    actionTypeId: number;
    actionType: ActionTypeDto;
    transportId: string | undefined;
    transport: SimpleTransportDto;
    plateNumber: string | undefined;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    observations: string | undefined;
    numberWorkers: number;
    origin: string | undefined;
    remoteIp: string | undefined;
    userAgent: string | undefined;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    attendances: AttendanceDto[] | undefined;

    constructor(data?: IVehicleEntranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.entranceId = _data["entranceId"];
            this.entrance = _data["entrance"] ? SimpleEntranceDto.fromJS(_data["entrance"]) : <any>undefined;
            this.actionTypeId = _data["actionTypeId"];
            this.actionType = _data["actionType"] ? ActionTypeDto.fromJS(_data["actionType"]) : <any>undefined;
            this.transportId = _data["transportId"];
            this.transport = _data["transport"] ? SimpleTransportDto.fromJS(_data["transport"]) : <any>undefined;
            this.plateNumber = _data["plateNumber"];
            this.driverName = _data["driverName"];
            this.driverIdNumber = _data["driverIdNumber"];
            this.observations = _data["observations"];
            this.numberWorkers = _data["numberWorkers"];
            this.origin = _data["origin"];
            this.remoteIp = _data["remoteIp"];
            this.userAgent = _data["userAgent"];
            this.deviceId = _data["deviceId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            if (Array.isArray(_data["attendances"])) {
                this.attendances = [] as any;
                for (let item of _data["attendances"])
                    this.attendances.push(AttendanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleEntranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleEntranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["entranceId"] = this.entranceId;
        data["entrance"] = this.entrance ? this.entrance.toJSON() : <any>undefined;
        data["actionTypeId"] = this.actionTypeId;
        data["actionType"] = this.actionType ? this.actionType.toJSON() : <any>undefined;
        data["transportId"] = this.transportId;
        data["transport"] = this.transport ? this.transport.toJSON() : <any>undefined;
        data["plateNumber"] = this.plateNumber;
        data["driverName"] = this.driverName;
        data["driverIdNumber"] = this.driverIdNumber;
        data["observations"] = this.observations;
        data["numberWorkers"] = this.numberWorkers;
        data["origin"] = this.origin;
        data["remoteIp"] = this.remoteIp;
        data["userAgent"] = this.userAgent;
        data["deviceId"] = this.deviceId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        if (Array.isArray(this.attendances)) {
            data["attendances"] = [];
            for (let item of this.attendances)
                data["attendances"].push(item.toJSON());
        }
        return data;
    }

    clone(): VehicleEntranceDto {
        const json = this.toJSON();
        let result = new VehicleEntranceDto();
        result.init(json);
        return result;
    }
}

export interface IVehicleEntranceDto {
    startDate: moment.Moment;
    entranceId: string;
    entrance: SimpleEntranceDto;
    actionTypeId: number;
    actionType: ActionTypeDto;
    transportId: string | undefined;
    transport: SimpleTransportDto;
    plateNumber: string | undefined;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    observations: string | undefined;
    numberWorkers: number;
    origin: string | undefined;
    remoteIp: string | undefined;
    userAgent: string | undefined;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    attendances: AttendanceDto[] | undefined;
}

export class AttendanceDtoPagedResultDto implements IAttendanceDtoPagedResultDto {
    totalCount: number;
    items: AttendanceDto[] | undefined;

    constructor(data?: IAttendanceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AttendanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttendanceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AttendanceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AttendanceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAttendanceDtoPagedResultDto {
    totalCount: number;
    items: AttendanceDto[] | undefined;
}

export class UpdateAttendanceDto implements IUpdateAttendanceDto {
    startDate: moment.Moment;
    workerId: string | undefined;
    fullNameWorker: string;
    dniWorker: string;
    actionTypeId: number;
    contractorId: string | undefined;
    dniContractor: string | undefined;
    farmId: string;
    entranceId: string | undefined;
    notes: string | undefined;
    machImages: boolean;
    checked: boolean;
    origin: string | undefined;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    id: string;

    constructor(data?: IUpdateAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.workerId = _data["workerId"];
            this.fullNameWorker = _data["fullNameWorker"];
            this.dniWorker = _data["dniWorker"];
            this.actionTypeId = _data["actionTypeId"];
            this.contractorId = _data["contractorId"];
            this.dniContractor = _data["dniContractor"];
            this.farmId = _data["farmId"];
            this.entranceId = _data["entranceId"];
            this.notes = _data["notes"];
            this.machImages = _data["machImages"];
            this.checked = _data["checked"];
            this.origin = _data["origin"];
            this.deviceId = _data["deviceId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateAttendanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["workerId"] = this.workerId;
        data["fullNameWorker"] = this.fullNameWorker;
        data["dniWorker"] = this.dniWorker;
        data["actionTypeId"] = this.actionTypeId;
        data["contractorId"] = this.contractorId;
        data["dniContractor"] = this.dniContractor;
        data["farmId"] = this.farmId;
        data["entranceId"] = this.entranceId;
        data["notes"] = this.notes;
        data["machImages"] = this.machImages;
        data["checked"] = this.checked;
        data["origin"] = this.origin;
        data["deviceId"] = this.deviceId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateAttendanceDto {
        const json = this.toJSON();
        let result = new UpdateAttendanceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAttendanceDto {
    startDate: moment.Moment;
    workerId: string | undefined;
    fullNameWorker: string;
    dniWorker: string;
    actionTypeId: number;
    contractorId: string | undefined;
    dniContractor: string | undefined;
    farmId: string;
    entranceId: string | undefined;
    notes: string | undefined;
    machImages: boolean;
    checked: boolean;
    origin: string | undefined;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    id: string;
}

export class AttendanceLogDto implements IAttendanceLogDto {
    attendanceId: string;
    action: string;
    origin: string;
    remoteIp: string;
    userAgent: string;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    creatorUserFullName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IAttendanceLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attendanceId = _data["attendanceId"];
            this.action = _data["action"];
            this.origin = _data["origin"];
            this.remoteIp = _data["remoteIp"];
            this.userAgent = _data["userAgent"];
            this.deviceId = _data["deviceId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.creatorUserFullName = _data["creatorUserFullName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AttendanceLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attendanceId"] = this.attendanceId;
        data["action"] = this.action;
        data["origin"] = this.origin;
        data["remoteIp"] = this.remoteIp;
        data["userAgent"] = this.userAgent;
        data["deviceId"] = this.deviceId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["creatorUserFullName"] = this.creatorUserFullName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): AttendanceLogDto {
        const json = this.toJSON();
        let result = new AttendanceLogDto();
        result.init(json);
        return result;
    }
}

export interface IAttendanceLogDto {
    attendanceId: string;
    action: string;
    origin: string;
    remoteIp: string;
    userAgent: string;
    deviceId: string | undefined;
    latitude: number;
    longitude: number;
    creatorUserFullName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class GuidEntityDto implements IGuidEntityDto {
    id: string;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): GuidEntityDto {
        const json = this.toJSON();
        let result = new GuidEntityDto();
        result.init(json);
        return result;
    }
}

export interface IGuidEntityDto {
    id: string;
}

export class CreateAuthorizationMethodDto implements ICreateAuthorizationMethodDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    approvalTypeId: number;
    id: number;

    constructor(data?: ICreateAuthorizationMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.approvalTypeId = _data["approvalTypeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAuthorizationMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAuthorizationMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["approvalTypeId"] = this.approvalTypeId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAuthorizationMethodDto {
        const json = this.toJSON();
        let result = new CreateAuthorizationMethodDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAuthorizationMethodDto {
    name: string | undefined;
    langKey: string | undefined;
    description: string | undefined;
    approvalTypeId: number;
    id: number;
}

export class AuthorizationMethodDtoPagedResultDto implements IAuthorizationMethodDtoPagedResultDto {
    totalCount: number;
    items: AuthorizationMethodDto[] | undefined;

    constructor(data?: IAuthorizationMethodDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AuthorizationMethodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuthorizationMethodDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizationMethodDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AuthorizationMethodDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuthorizationMethodDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuthorizationMethodDtoPagedResultDto {
    totalCount: number;
    items: AuthorizationMethodDto[] | undefined;
}

export class CreateBankDto implements ICreateBankDto {
    name: string | undefined;
    code: string | undefined;
    countryId: number;
    isDeleted: boolean;
    id: number;

    constructor(data?: ICreateBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateBankDto {
        const json = this.toJSON();
        let result = new CreateBankDto();
        result.init(json);
        return result;
    }
}

export interface ICreateBankDto {
    name: string | undefined;
    code: string | undefined;
    countryId: number;
    isDeleted: boolean;
    id: number;
}

export class BankDto implements IBankDto {
    name: string;
    code: string | undefined;
    countryId: number;
    countryName: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BankDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): BankDto {
        const json = this.toJSON();
        let result = new BankDto();
        result.init(json);
        return result;
    }
}

export interface IBankDto {
    name: string;
    code: string | undefined;
    countryId: number;
    countryName: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class BankDtoPagedResultDto implements IBankDtoPagedResultDto {
    totalCount: number;
    items: BankDto[] | undefined;

    constructor(data?: IBankDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BankDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): BankDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BankDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBankDtoPagedResultDto {
    totalCount: number;
    items: BankDto[] | undefined;
}

export class CreateBankAccountTypeAccountTypeDto implements ICreateBankAccountTypeAccountTypeDto {
    name: string | undefined;
    code: string | undefined;
    bankId: number;
    isDeleted: boolean;
    id: number;

    constructor(data?: ICreateBankAccountTypeAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.bankId = _data["bankId"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateBankAccountTypeAccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBankAccountTypeAccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["bankId"] = this.bankId;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateBankAccountTypeAccountTypeDto {
        const json = this.toJSON();
        let result = new CreateBankAccountTypeAccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateBankAccountTypeAccountTypeDto {
    name: string | undefined;
    code: string | undefined;
    bankId: number;
    isDeleted: boolean;
    id: number;
}

export class BankAccountTypeDto implements IBankAccountTypeDto {
    name: string | undefined;
    code: string | undefined;
    bankId: number;
    isDeleted: boolean;
    id: number;

    constructor(data?: IBankAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.bankId = _data["bankId"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BankAccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["bankId"] = this.bankId;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): BankAccountTypeDto {
        const json = this.toJSON();
        let result = new BankAccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface IBankAccountTypeDto {
    name: string | undefined;
    code: string | undefined;
    bankId: number;
    isDeleted: boolean;
    id: number;
}

export class BankAccountTypeDtoPagedResultDto implements IBankAccountTypeDtoPagedResultDto {
    totalCount: number;
    items: BankAccountTypeDto[] | undefined;

    constructor(data?: IBankAccountTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BankAccountTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankAccountTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): BankAccountTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BankAccountTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBankAccountTypeDtoPagedResultDto {
    totalCount: number;
    items: BankAccountTypeDto[] | undefined;
}

export class PaymentMethodDto implements IPaymentMethodDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IPaymentMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.localizationKey = _data["localizationKey"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["localizationKey"] = this.localizationKey;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): PaymentMethodDto {
        const json = this.toJSON();
        let result = new PaymentMethodDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentMethodDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class BankaryInfoDto implements IBankaryInfoDto {
    paymentMethod: PaymentMethodDto;
    paymentMethodId: number;
    bank: BankDto;
    bankId: number;
    bankAccountType: BankAccountTypeDto;
    bankAccountTypeId: number;
    accountNumber: string | undefined;
    emailTo: string | undefined;
    id: string;

    constructor(data?: IBankaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethodDto.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.paymentMethodId = _data["paymentMethodId"];
            this.bank = _data["bank"] ? BankDto.fromJS(_data["bank"]) : <any>undefined;
            this.bankId = _data["bankId"];
            this.bankAccountType = _data["bankAccountType"] ? BankAccountTypeDto.fromJS(_data["bankAccountType"]) : <any>undefined;
            this.bankAccountTypeId = _data["bankAccountTypeId"];
            this.accountNumber = _data["accountNumber"];
            this.emailTo = _data["emailTo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BankaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["paymentMethodId"] = this.paymentMethodId;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["bankId"] = this.bankId;
        data["bankAccountType"] = this.bankAccountType ? this.bankAccountType.toJSON() : <any>undefined;
        data["bankAccountTypeId"] = this.bankAccountTypeId;
        data["accountNumber"] = this.accountNumber;
        data["emailTo"] = this.emailTo;
        data["id"] = this.id;
        return data;
    }

    clone(): BankaryInfoDto {
        const json = this.toJSON();
        let result = new BankaryInfoDto();
        result.init(json);
        return result;
    }
}

export interface IBankaryInfoDto {
    paymentMethod: PaymentMethodDto;
    paymentMethodId: number;
    bank: BankDto;
    bankId: number;
    bankAccountType: BankAccountTypeDto;
    bankAccountTypeId: number;
    accountNumber: string | undefined;
    emailTo: string | undefined;
    id: string;
}

export class BankaryInfoDtoPagedResultDto implements IBankaryInfoDtoPagedResultDto {
    totalCount: number;
    items: BankaryInfoDto[] | undefined;

    constructor(data?: IBankaryInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BankaryInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankaryInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankaryInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): BankaryInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BankaryInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBankaryInfoDtoPagedResultDto {
    totalCount: number;
    items: BankaryInfoDto[] | undefined;
}

export class CreateBankaryInfoDto implements ICreateBankaryInfoDto {
    paymentMethodId: number;
    bankId: number | undefined;
    accountTypeId: number | undefined;
    accountNumber: string | undefined;
    emailTo: string | undefined;

    constructor(data?: ICreateBankaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"];
            this.bankId = _data["bankId"];
            this.accountTypeId = _data["accountTypeId"];
            this.accountNumber = _data["accountNumber"];
            this.emailTo = _data["emailTo"];
        }
    }

    static fromJS(data: any): CreateBankaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBankaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId;
        data["bankId"] = this.bankId;
        data["accountTypeId"] = this.accountTypeId;
        data["accountNumber"] = this.accountNumber;
        data["emailTo"] = this.emailTo;
        return data;
    }

    clone(): CreateBankaryInfoDto {
        const json = this.toJSON();
        let result = new CreateBankaryInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateBankaryInfoDto {
    paymentMethodId: number;
    bankId: number | undefined;
    accountTypeId: number | undefined;
    accountNumber: string | undefined;
    emailTo: string | undefined;
}

export class UpdateBankaryInfoDto implements IUpdateBankaryInfoDto {
    paymentMethodId: number;
    bankId: number | undefined;
    bankAccountTypeId: number | undefined;
    accountNumber: string | undefined;
    emailTo: string | undefined;
    id: string;

    constructor(data?: IUpdateBankaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"];
            this.bankId = _data["bankId"];
            this.bankAccountTypeId = _data["bankAccountTypeId"];
            this.accountNumber = _data["accountNumber"];
            this.emailTo = _data["emailTo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateBankaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBankaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId;
        data["bankId"] = this.bankId;
        data["bankAccountTypeId"] = this.bankAccountTypeId;
        data["accountNumber"] = this.accountNumber;
        data["emailTo"] = this.emailTo;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateBankaryInfoDto {
        const json = this.toJSON();
        let result = new UpdateBankaryInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateBankaryInfoDto {
    paymentMethodId: number;
    bankId: number | undefined;
    bankAccountTypeId: number | undefined;
    accountNumber: string | undefined;
    emailTo: string | undefined;
    id: string;
}

export class BreakDto implements IBreakDto {
    name: string;
    time: number;
    initHour: moment.Moment | undefined;
    workShiftId: string;
    id: string;

    constructor(data?: IBreakDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.time = _data["time"];
            this.initHour = _data["initHour"] ? moment(_data["initHour"].toString()) : <any>undefined;
            this.workShiftId = _data["workShiftId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BreakDto {
        data = typeof data === 'object' ? data : {};
        let result = new BreakDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["time"] = this.time;
        data["initHour"] = this.initHour ? this.initHour.toISOString() : <any>undefined;
        data["workShiftId"] = this.workShiftId;
        data["id"] = this.id;
        return data;
    }

    clone(): BreakDto {
        const json = this.toJSON();
        let result = new BreakDto();
        result.init(json);
        return result;
    }
}

export interface IBreakDto {
    name: string;
    time: number;
    initHour: moment.Moment | undefined;
    workShiftId: string;
    id: string;
}

export class BreakDtoPagedResultDto implements IBreakDtoPagedResultDto {
    totalCount: number;
    items: BreakDto[] | undefined;

    constructor(data?: IBreakDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BreakDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BreakDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BreakDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): BreakDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BreakDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBreakDtoPagedResultDto {
    totalCount: number;
    items: BreakDto[] | undefined;
}

export class CreateBreakDto implements ICreateBreakDto {
    name: string;
    time: number;
    initHour: moment.Moment | undefined;

    constructor(data?: ICreateBreakDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.time = _data["time"];
            this.initHour = _data["initHour"] ? moment(_data["initHour"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateBreakDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBreakDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["time"] = this.time;
        data["initHour"] = this.initHour ? this.initHour.toISOString() : <any>undefined;
        return data;
    }

    clone(): CreateBreakDto {
        const json = this.toJSON();
        let result = new CreateBreakDto();
        result.init(json);
        return result;
    }
}

export interface ICreateBreakDto {
    name: string;
    time: number;
    initHour: moment.Moment | undefined;
}

export class UpdateBreakDto implements IUpdateBreakDto {
    name: string;
    time: number;
    initHour: moment.Moment | undefined;
    id: string;

    constructor(data?: IUpdateBreakDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.time = _data["time"];
            this.initHour = _data["initHour"] ? moment(_data["initHour"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateBreakDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBreakDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["time"] = this.time;
        data["initHour"] = this.initHour ? this.initHour.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateBreakDto {
        const json = this.toJSON();
        let result = new UpdateBreakDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateBreakDto {
    name: string;
    time: number;
    initHour: moment.Moment | undefined;
    id: string;
}

export class CreateBusinessAreaInput implements ICreateBusinessAreaInput {
    name: string;
    langKey: string;
    id: number;

    constructor(data?: ICreateBusinessAreaInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateBusinessAreaInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBusinessAreaInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateBusinessAreaInput {
        const json = this.toJSON();
        let result = new CreateBusinessAreaInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBusinessAreaInput {
    name: string;
    langKey: string;
    id: number;
}

export class BusinessAreaDto implements IBusinessAreaDto {
    name: string;
    langKey: string;
    id: number;

    constructor(data?: IBusinessAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessAreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessAreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): BusinessAreaDto {
        const json = this.toJSON();
        let result = new BusinessAreaDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessAreaDto {
    name: string;
    langKey: string;
    id: number;
}

export class BusinessAreaDtoPagedResultDto implements IBusinessAreaDtoPagedResultDto {
    totalCount: number;
    items: BusinessAreaDto[] | undefined;

    constructor(data?: IBusinessAreaDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BusinessAreaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessAreaDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessAreaDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): BusinessAreaDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BusinessAreaDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessAreaDtoPagedResultDto {
    totalCount: number;
    items: BusinessAreaDto[] | undefined;
}

export class CreateCommentDto implements ICreateCommentDto {
    description: string | undefined;

    constructor(data?: ICreateCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data;
    }

    clone(): CreateCommentDto {
        const json = this.toJSON();
        let result = new CreateCommentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCommentDto {
    description: string | undefined;
}

export class CommentDto implements ICommentDto {
    description: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): CommentDto {
        const json = this.toJSON();
        let result = new CommentDto();
        result.init(json);
        return result;
    }
}

export interface ICommentDto {
    description: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateCommentDto implements IUpdateCommentDto {
    description: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IUpdateCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCommentDto {
        const json = this.toJSON();
        let result = new UpdateCommentDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCommentDto {
    description: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class CommentDtoPagedResultDto implements ICommentDtoPagedResultDto {
    totalCount: number;
    items: CommentDto[] | undefined;

    constructor(data?: ICommentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CommentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CommentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICommentDtoPagedResultDto {
    totalCount: number;
    items: CommentDto[] | undefined;
}

export class CreateCompanyDto implements ICreateCompanyDto {
    rut: string;
    businessName: string;
    name: string;
    code: number;
    fileLogo: FileDto;
    address: CreateAddressDto;
    phone: string;
    webSite: string | undefined;
    email: string | undefined;
    economicActivityId: number;
    legalRepresentativesId: number[] | undefined;
    currenciesId: number[] | undefined;
    tenantId: number;
    tagsArray: string[] | undefined;
    newFarm: boolean;

    constructor(data?: ICreateCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rut = _data["rut"];
            this.businessName = _data["businessName"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.fileLogo = _data["fileLogo"] ? FileDto.fromJS(_data["fileLogo"]) : <any>undefined;
            this.address = _data["address"] ? CreateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.phone = _data["phone"];
            this.webSite = _data["webSite"];
            this.email = _data["email"];
            this.economicActivityId = _data["economicActivityId"];
            if (Array.isArray(_data["legalRepresentativesId"])) {
                this.legalRepresentativesId = [] as any;
                for (let item of _data["legalRepresentativesId"])
                    this.legalRepresentativesId.push(item);
            }
            if (Array.isArray(_data["currenciesId"])) {
                this.currenciesId = [] as any;
                for (let item of _data["currenciesId"])
                    this.currenciesId.push(item);
            }
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["tagsArray"])) {
                this.tagsArray = [] as any;
                for (let item of _data["tagsArray"])
                    this.tagsArray.push(item);
            }
            this.newFarm = _data["newFarm"];
        }
    }

    static fromJS(data: any): CreateCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rut"] = this.rut;
        data["businessName"] = this.businessName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["fileLogo"] = this.fileLogo ? this.fileLogo.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["webSite"] = this.webSite;
        data["email"] = this.email;
        data["economicActivityId"] = this.economicActivityId;
        if (Array.isArray(this.legalRepresentativesId)) {
            data["legalRepresentativesId"] = [];
            for (let item of this.legalRepresentativesId)
                data["legalRepresentativesId"].push(item);
        }
        if (Array.isArray(this.currenciesId)) {
            data["currenciesId"] = [];
            for (let item of this.currenciesId)
                data["currenciesId"].push(item);
        }
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.tagsArray)) {
            data["tagsArray"] = [];
            for (let item of this.tagsArray)
                data["tagsArray"].push(item);
        }
        data["newFarm"] = this.newFarm;
        return data;
    }

    clone(): CreateCompanyDto {
        const json = this.toJSON();
        let result = new CreateCompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCompanyDto {
    rut: string;
    businessName: string;
    name: string;
    code: number;
    fileLogo: FileDto;
    address: CreateAddressDto;
    phone: string;
    webSite: string | undefined;
    email: string | undefined;
    economicActivityId: number;
    legalRepresentativesId: number[] | undefined;
    currenciesId: number[] | undefined;
    tenantId: number;
    tagsArray: string[] | undefined;
    newFarm: boolean;
}

export class EconomicActivityDto implements IEconomicActivityDto {
    code: string;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    businessArea: BusinessAreaDto;
    businessAreaId: number;
    businessAreaName: string | undefined;
    id: number;

    constructor(data?: IEconomicActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.businessArea = _data["businessArea"] ? BusinessAreaDto.fromJS(_data["businessArea"]) : <any>undefined;
            this.businessAreaId = _data["businessAreaId"];
            this.businessAreaName = _data["businessAreaName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EconomicActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EconomicActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["businessArea"] = this.businessArea ? this.businessArea.toJSON() : <any>undefined;
        data["businessAreaId"] = this.businessAreaId;
        data["businessAreaName"] = this.businessAreaName;
        data["id"] = this.id;
        return data;
    }

    clone(): EconomicActivityDto {
        const json = this.toJSON();
        let result = new EconomicActivityDto();
        result.init(json);
        return result;
    }
}

export interface IEconomicActivityDto {
    code: string;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    businessArea: BusinessAreaDto;
    businessAreaId: number;
    businessAreaName: string | undefined;
    id: number;
}

export class UserCompanyDto implements IUserCompanyDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
    id: number;

    constructor(data?: IUserCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["id"] = this.id;
        return data;
    }

    clone(): UserCompanyDto {
        const json = this.toJSON();
        let result = new UserCompanyDto();
        result.init(json);
        return result;
    }
}

export interface IUserCompanyDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
    id: number;
}

export class CurrencyDto implements ICurrencyDto {
    name: string | undefined;
    code: string | undefined;
    symbol: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.symbol = _data["symbol"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["symbol"] = this.symbol;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): CurrencyDto {
        const json = this.toJSON();
        let result = new CurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyDto {
    name: string | undefined;
    code: string | undefined;
    symbol: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CompanyCurrencyDto implements ICompanyCurrencyDto {
    currency: CurrencyDto;
    isPrimary: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICompanyCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.isPrimary = _data["isPrimary"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["isPrimary"] = this.isPrimary;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyCurrencyDto {
        const json = this.toJSON();
        let result = new CompanyCurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyCurrencyDto {
    currency: CurrencyDto;
    isPrimary: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CompanyFarmDto implements ICompanyFarmDto {
    name: string | undefined;
    id: string;

    constructor(data?: ICompanyFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyFarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyFarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyFarmDto {
        const json = this.toJSON();
        let result = new CompanyFarmDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyFarmDto {
    name: string | undefined;
    id: string;
}

export class CompanyDto implements ICompanyDto {
    name: string | undefined;
    code: number;
    businessName: string | undefined;
    logo: string | undefined;
    phone: string | undefined;
    webSite: string | undefined;
    email: string | undefined;
    address: AddressDto;
    rut: string | undefined;
    economicActivity: EconomicActivityDto;
    legalRepresentatives: UserCompanyDto[] | undefined;
    companyCurrencies: CompanyCurrencyDto[] | undefined;
    tags: TagDto[] | undefined;
    farms: CompanyFarmDto[] | undefined;
    tenantId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.logo = _data["logo"];
            this.phone = _data["phone"];
            this.webSite = _data["webSite"];
            this.email = _data["email"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.rut = _data["rut"];
            this.economicActivity = _data["economicActivity"] ? EconomicActivityDto.fromJS(_data["economicActivity"]) : <any>undefined;
            if (Array.isArray(_data["legalRepresentatives"])) {
                this.legalRepresentatives = [] as any;
                for (let item of _data["legalRepresentatives"])
                    this.legalRepresentatives.push(UserCompanyDto.fromJS(item));
            }
            if (Array.isArray(_data["companyCurrencies"])) {
                this.companyCurrencies = [] as any;
                for (let item of _data["companyCurrencies"])
                    this.companyCurrencies.push(CompanyCurrencyDto.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(CompanyFarmDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["logo"] = this.logo;
        data["phone"] = this.phone;
        data["webSite"] = this.webSite;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["rut"] = this.rut;
        data["economicActivity"] = this.economicActivity ? this.economicActivity.toJSON() : <any>undefined;
        if (Array.isArray(this.legalRepresentatives)) {
            data["legalRepresentatives"] = [];
            for (let item of this.legalRepresentatives)
                data["legalRepresentatives"].push(item.toJSON());
        }
        if (Array.isArray(this.companyCurrencies)) {
            data["companyCurrencies"] = [];
            for (let item of this.companyCurrencies)
                data["companyCurrencies"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyDto {
        const json = this.toJSON();
        let result = new CompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDto {
    name: string | undefined;
    code: number;
    businessName: string | undefined;
    logo: string | undefined;
    phone: string | undefined;
    webSite: string | undefined;
    email: string | undefined;
    address: AddressDto;
    rut: string | undefined;
    economicActivity: EconomicActivityDto;
    legalRepresentatives: UserCompanyDto[] | undefined;
    companyCurrencies: CompanyCurrencyDto[] | undefined;
    tags: TagDto[] | undefined;
    farms: CompanyFarmDto[] | undefined;
    tenantId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateCompanyDto implements IUpdateCompanyDto {
    name: string | undefined;
    code: number;
    businessName: string;
    fileLogo: FileDto;
    phone: string;
    webSite: string | undefined;
    email: string | undefined;
    address: UpdateAddressDto;
    economicActivityId: number;
    legalRepresentativesId: number[] | undefined;
    currencieId: number | undefined;
    tags: TagDto[] | undefined;
    id: string;

    constructor(data?: IUpdateCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.fileLogo = _data["fileLogo"] ? FileDto.fromJS(_data["fileLogo"]) : <any>undefined;
            this.phone = _data["phone"];
            this.webSite = _data["webSite"];
            this.email = _data["email"];
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.economicActivityId = _data["economicActivityId"];
            if (Array.isArray(_data["legalRepresentativesId"])) {
                this.legalRepresentativesId = [] as any;
                for (let item of _data["legalRepresentativesId"])
                    this.legalRepresentativesId.push(item);
            }
            this.currencieId = _data["currencieId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["fileLogo"] = this.fileLogo ? this.fileLogo.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["webSite"] = this.webSite;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["economicActivityId"] = this.economicActivityId;
        if (Array.isArray(this.legalRepresentativesId)) {
            data["legalRepresentativesId"] = [];
            for (let item of this.legalRepresentativesId)
                data["legalRepresentativesId"].push(item);
        }
        data["currencieId"] = this.currencieId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCompanyDto {
        const json = this.toJSON();
        let result = new UpdateCompanyDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCompanyDto {
    name: string | undefined;
    code: number;
    businessName: string;
    fileLogo: FileDto;
    phone: string;
    webSite: string | undefined;
    email: string | undefined;
    address: UpdateAddressDto;
    economicActivityId: number;
    legalRepresentativesId: number[] | undefined;
    currencieId: number | undefined;
    tags: TagDto[] | undefined;
    id: string;
}

export class CompanyDtoPagedResultDto implements ICompanyDtoPagedResultDto {
    totalCount: number;
    items: CompanyDto[] | undefined;

    constructor(data?: ICompanyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CompanyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CompanyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CompanyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDtoPagedResultDto {
    totalCount: number;
    items: CompanyDto[] | undefined;
}

export class UpdateCompanyMainInfoDto implements IUpdateCompanyMainInfoDto {
    rut: string;
    name: string;
    code: number;
    businessName: string;
    id: string;

    constructor(data?: IUpdateCompanyMainInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rut = _data["rut"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCompanyMainInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyMainInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rut"] = this.rut;
        data["name"] = this.name;
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCompanyMainInfoDto {
        const json = this.toJSON();
        let result = new UpdateCompanyMainInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCompanyMainInfoDto {
    rut: string;
    name: string;
    code: number;
    businessName: string;
    id: string;
}

export class UpdateCompanyLogoDto implements IUpdateCompanyLogoDto {
    logo: string | undefined;
    fileLogo: FileDto;
    id: string;

    constructor(data?: IUpdateCompanyLogoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logo = _data["logo"];
            this.fileLogo = _data["fileLogo"] ? FileDto.fromJS(_data["fileLogo"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCompanyLogoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyLogoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logo"] = this.logo;
        data["fileLogo"] = this.fileLogo ? this.fileLogo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCompanyLogoDto {
        const json = this.toJSON();
        let result = new UpdateCompanyLogoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCompanyLogoDto {
    logo: string | undefined;
    fileLogo: FileDto;
    id: string;
}

export class UpdateCompanyContactAddressInfoDto implements IUpdateCompanyContactAddressInfoDto {
    phone: string;
    webSite: string | undefined;
    email: string | undefined;
    address: UpdateAddressDto;
    id: string;

    constructor(data?: IUpdateCompanyContactAddressInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.webSite = _data["webSite"];
            this.email = _data["email"];
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCompanyContactAddressInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyContactAddressInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["webSite"] = this.webSite;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCompanyContactAddressInfoDto {
        const json = this.toJSON();
        let result = new UpdateCompanyContactAddressInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCompanyContactAddressInfoDto {
    phone: string;
    webSite: string | undefined;
    email: string | undefined;
    address: UpdateAddressDto;
    id: string;
}

export class CompanyContactAddressInfoDto implements ICompanyContactAddressInfoDto {
    phone: string | undefined;
    webSite: string | undefined;
    email: string | undefined;
    address: AddressDto;
    id: string;

    constructor(data?: ICompanyContactAddressInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.webSite = _data["webSite"];
            this.email = _data["email"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyContactAddressInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyContactAddressInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["webSite"] = this.webSite;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyContactAddressInfoDto {
        const json = this.toJSON();
        let result = new CompanyContactAddressInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyContactAddressInfoDto {
    phone: string | undefined;
    webSite: string | undefined;
    email: string | undefined;
    address: AddressDto;
    id: string;
}

export class UpdateLegalFiscalInfoDto implements IUpdateLegalFiscalInfoDto {
    economicActivity: EconomicActivityDto;
    economicActivityId: number;
    legalRepresentatives: UserCompanyDto[] | undefined;
    legalRepresentativesId: number[] | undefined;
    id: string;

    constructor(data?: IUpdateLegalFiscalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.economicActivity = _data["economicActivity"] ? EconomicActivityDto.fromJS(_data["economicActivity"]) : <any>undefined;
            this.economicActivityId = _data["economicActivityId"];
            if (Array.isArray(_data["legalRepresentatives"])) {
                this.legalRepresentatives = [] as any;
                for (let item of _data["legalRepresentatives"])
                    this.legalRepresentatives.push(UserCompanyDto.fromJS(item));
            }
            if (Array.isArray(_data["legalRepresentativesId"])) {
                this.legalRepresentativesId = [] as any;
                for (let item of _data["legalRepresentativesId"])
                    this.legalRepresentativesId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateLegalFiscalInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLegalFiscalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["economicActivity"] = this.economicActivity ? this.economicActivity.toJSON() : <any>undefined;
        data["economicActivityId"] = this.economicActivityId;
        if (Array.isArray(this.legalRepresentatives)) {
            data["legalRepresentatives"] = [];
            for (let item of this.legalRepresentatives)
                data["legalRepresentatives"].push(item.toJSON());
        }
        if (Array.isArray(this.legalRepresentativesId)) {
            data["legalRepresentativesId"] = [];
            for (let item of this.legalRepresentativesId)
                data["legalRepresentativesId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateLegalFiscalInfoDto {
        const json = this.toJSON();
        let result = new UpdateLegalFiscalInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateLegalFiscalInfoDto {
    economicActivity: EconomicActivityDto;
    economicActivityId: number;
    legalRepresentatives: UserCompanyDto[] | undefined;
    legalRepresentativesId: number[] | undefined;
    id: string;
}

export class UpdateCompanyTagsDto implements IUpdateCompanyTagsDto {
    tags: TagDto[] | undefined;
    id: string;

    constructor(data?: IUpdateCompanyTagsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCompanyTagsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyTagsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCompanyTagsDto {
        const json = this.toJSON();
        let result = new UpdateCompanyTagsDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCompanyTagsDto {
    tags: TagDto[] | undefined;
    id: string;
}

export class CompanyFilterDto implements ICompanyFilterDto {
    name: string;
    code: number;
    businessName: string;
    rut: string;
    id: string;

    constructor(data?: ICompanyFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.rut = _data["rut"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["rut"] = this.rut;
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyFilterDto {
        const json = this.toJSON();
        let result = new CompanyFilterDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyFilterDto {
    name: string;
    code: number;
    businessName: string;
    rut: string;
    id: string;
}

export class CompanyFilterDtoPagedResultDto implements ICompanyFilterDtoPagedResultDto {
    totalCount: number;
    items: CompanyFilterDto[] | undefined;

    constructor(data?: ICompanyFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CompanyFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CompanyFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CompanyFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyFilterDtoPagedResultDto {
    totalCount: number;
    items: CompanyFilterDto[] | undefined;
}

export class UpdateFinancialInfoDto implements IUpdateFinancialInfoDto {
    companyCurrencies: CompanyCurrencyDto[] | undefined;
    currencyId: number | undefined;
    id: string;

    constructor(data?: IUpdateFinancialInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["companyCurrencies"])) {
                this.companyCurrencies = [] as any;
                for (let item of _data["companyCurrencies"])
                    this.companyCurrencies.push(CompanyCurrencyDto.fromJS(item));
            }
            this.currencyId = _data["currencyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateFinancialInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFinancialInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.companyCurrencies)) {
            data["companyCurrencies"] = [];
            for (let item of this.companyCurrencies)
                data["companyCurrencies"].push(item.toJSON());
        }
        data["currencyId"] = this.currencyId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateFinancialInfoDto {
        const json = this.toJSON();
        let result = new UpdateFinancialInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFinancialInfoDto {
    companyCurrencies: CompanyCurrencyDto[] | undefined;
    currencyId: number | undefined;
    id: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ContactInfoDto implements IContactInfoDto {
    cellPhone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    address: AddressDto;
    addressId: string;
    id: string;

    constructor(data?: IContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cellPhone = _data["cellPhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.addressId = _data["addressId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cellPhone"] = this.cellPhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["addressId"] = this.addressId;
        data["id"] = this.id;
        return data;
    }

    clone(): ContactInfoDto {
        const json = this.toJSON();
        let result = new ContactInfoDto();
        result.init(json);
        return result;
    }
}

export interface IContactInfoDto {
    cellPhone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    address: AddressDto;
    addressId: string;
    id: string;
}

export class UpdateContactInfoDto implements IUpdateContactInfoDto {
    cellPhone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    address: UpdateAddressDto;
    id: string;

    constructor(data?: IUpdateContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cellPhone = _data["cellPhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cellPhone"] = this.cellPhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateContactInfoDto {
        const json = this.toJSON();
        let result = new UpdateContactInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateContactInfoDto {
    cellPhone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    address: UpdateAddressDto;
    id: string;
}

export class ContactInfoDtoPagedResultDto implements IContactInfoDtoPagedResultDto {
    totalCount: number;
    items: ContactInfoDto[] | undefined;

    constructor(data?: IContactInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ContactInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ContactInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ContactInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IContactInfoDtoPagedResultDto {
    totalCount: number;
    items: ContactInfoDto[] | undefined;
}

export class CreateContactInfoDto implements ICreateContactInfoDto {
    cellPhone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    address: CreateAddressDto;

    constructor(data?: ICreateContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cellPhone = _data["cellPhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"] ? CreateAddressDto.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cellPhone"] = this.cellPhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateContactInfoDto {
        const json = this.toJSON();
        let result = new CreateContactInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateContactInfoDto {
    cellPhone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    address: CreateAddressDto;
}

export class CorrelativeTypeDto implements ICorrelativeTypeDto {
    name: string;
    code: string;
    langKey: string;
    description: string;
    id: number;

    constructor(data?: ICorrelativeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CorrelativeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CorrelativeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): CorrelativeTypeDto {
        const json = this.toJSON();
        let result = new CorrelativeTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICorrelativeTypeDto {
    name: string;
    code: string;
    langKey: string;
    description: string;
    id: number;
}

export class StateDto implements IStateDto {
    name: string;
    langKey: string;
    description: string;
    id: number;

    constructor(data?: IStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StateDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): StateDto {
        const json = this.toJSON();
        let result = new StateDto();
        result.init(json);
        return result;
    }
}

export interface IStateDto {
    name: string;
    langKey: string;
    description: string;
    id: number;
}

export class CorrelativeDto implements ICorrelativeDto {
    number: number;
    correlativeType: CorrelativeTypeDto;
    state: StateDto;
    tenantId: number;
    id: string;

    constructor(data?: ICorrelativeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.correlativeType = _data["correlativeType"] ? CorrelativeTypeDto.fromJS(_data["correlativeType"]) : <any>undefined;
            this.state = _data["state"] ? StateDto.fromJS(_data["state"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CorrelativeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CorrelativeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["correlativeType"] = this.correlativeType ? this.correlativeType.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): CorrelativeDto {
        const json = this.toJSON();
        let result = new CorrelativeDto();
        result.init(json);
        return result;
    }
}

export interface ICorrelativeDto {
    number: number;
    correlativeType: CorrelativeTypeDto;
    state: StateDto;
    tenantId: number;
    id: string;
}

export class ContractTypeDto implements IContractTypeDto {
    name: string;
    description: string | undefined;
    countryCode: string;
    id: number;

    constructor(data?: IContractTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractTypeDto {
        const json = this.toJSON();
        let result = new ContractTypeDto();
        result.init(json);
        return result;
    }
}

export interface IContractTypeDto {
    name: string;
    description: string | undefined;
    countryCode: string;
    id: number;
}

export class ContractLayoutDto implements IContractLayoutDto {
    name: string;
    code: string;
    description: string | undefined;
    company: CompanyDto;
    companyId: string;
    id: string;

    constructor(data?: IContractLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractLayoutDto {
        const json = this.toJSON();
        let result = new ContractLayoutDto();
        result.init(json);
        return result;
    }
}

export interface IContractLayoutDto {
    name: string;
    code: string;
    description: string | undefined;
    company: CompanyDto;
    companyId: string;
    id: string;
}

export class LaborDto implements ILaborDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    activityId: string;
    farms: FarmDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ILaborDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.activityId = _data["activityId"];
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LaborDto {
        data = typeof data === 'object' ? data : {};
        let result = new LaborDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["activityId"] = this.activityId;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): LaborDto {
        const json = this.toJSON();
        let result = new LaborDto();
        result.init(json);
        return result;
    }
}

export interface ILaborDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    activityId: string;
    farms: FarmDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class SupervisorDepartmentDto implements ISupervisorDepartmentDto {
    name: string;
    id: string;

    constructor(data?: ISupervisorDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SupervisorDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupervisorDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): SupervisorDepartmentDto {
        const json = this.toJSON();
        let result = new SupervisorDepartmentDto();
        result.init(json);
        return result;
    }
}

export interface ISupervisorDepartmentDto {
    name: string;
    id: string;
}

export class DepartmentDto implements IDepartmentDto {
    name: string;
    description: string | undefined;
    supervisor: SupervisorDepartmentDto;
    supervisorId: string | undefined;
    company: CompanyDto;
    companyId: string | undefined;
    id: string;

    constructor(data?: IDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.supervisor = _data["supervisor"] ? SupervisorDepartmentDto.fromJS(_data["supervisor"]) : <any>undefined;
            this.supervisorId = _data["supervisorId"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["supervisor"] = this.supervisor ? this.supervisor.toJSON() : <any>undefined;
        data["supervisorId"] = this.supervisorId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data;
    }

    clone(): DepartmentDto {
        const json = this.toJSON();
        let result = new DepartmentDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDto {
    name: string;
    description: string | undefined;
    supervisor: SupervisorDepartmentDto;
    supervisorId: string | undefined;
    company: CompanyDto;
    companyId: string | undefined;
    id: string;
}

export class WorkerCostCenterDto implements IWorkerCostCenterDto {
    name: string | undefined;
    code: string | undefined;
    id: string;

    constructor(data?: IWorkerCostCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkerCostCenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerCostCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkerCostCenterDto {
        const json = this.toJSON();
        let result = new WorkerCostCenterDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerCostCenterDto {
    name: string | undefined;
    code: string | undefined;
    id: string;
}

export class PaymentTypeDto implements IPaymentTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IPaymentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): PaymentTypeDto {
        const json = this.toJSON();
        let result = new PaymentTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class TransportDto implements ITransportDto {
    name: string | undefined;
    description: string | undefined;
    plateNumber: string | undefined;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    transportType: TransportTypeDto;
    transportClassification: TransportClassificationDto;
    company: CompanyDto;
    farms: FarmDto[] | undefined;
    id: string;

    constructor(data?: ITransportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.plateNumber = _data["plateNumber"];
            this.driverName = _data["driverName"];
            this.driverIdNumber = _data["driverIdNumber"];
            this.transportType = _data["transportType"] ? TransportTypeDto.fromJS(_data["transportType"]) : <any>undefined;
            this.transportClassification = _data["transportClassification"] ? TransportClassificationDto.fromJS(_data["transportClassification"]) : <any>undefined;
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TransportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["plateNumber"] = this.plateNumber;
        data["driverName"] = this.driverName;
        data["driverIdNumber"] = this.driverIdNumber;
        data["transportType"] = this.transportType ? this.transportType.toJSON() : <any>undefined;
        data["transportClassification"] = this.transportClassification ? this.transportClassification.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): TransportDto {
        const json = this.toJSON();
        let result = new TransportDto();
        result.init(json);
        return result;
    }
}

export interface ITransportDto {
    name: string | undefined;
    description: string | undefined;
    plateNumber: string | undefined;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    transportType: TransportTypeDto;
    transportClassification: TransportClassificationDto;
    company: CompanyDto;
    farms: FarmDto[] | undefined;
    id: string;
}

export class WorkingInfoDto implements IWorkingInfoDto {
    workPhone: string | undefined;
    jobTitle: JobTitleDto;
    jobTitleName: string | undefined;
    department: DepartmentDto;
    departmentName: string | undefined;
    costCenter: WorkerCostCenterDto;
    costCenterId: string;
    isActive: boolean;
    farms: FarmDto[] | undefined;
    admissionDate: moment.Moment | undefined;
    paymentType: PaymentTypeDto;
    paymentTypeId: number | undefined;
    transport: TransportDto;
    transportId: string | undefined;
    id: string;

    constructor(data?: IWorkingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workPhone = _data["workPhone"];
            this.jobTitle = _data["jobTitle"] ? JobTitleDto.fromJS(_data["jobTitle"]) : <any>undefined;
            this.jobTitleName = _data["jobTitleName"];
            this.department = _data["department"] ? DepartmentDto.fromJS(_data["department"]) : <any>undefined;
            this.departmentName = _data["departmentName"];
            this.costCenter = _data["costCenter"] ? WorkerCostCenterDto.fromJS(_data["costCenter"]) : <any>undefined;
            this.costCenterId = _data["costCenterId"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.paymentType = _data["paymentType"] ? PaymentTypeDto.fromJS(_data["paymentType"]) : <any>undefined;
            this.paymentTypeId = _data["paymentTypeId"];
            this.transport = _data["transport"] ? TransportDto.fromJS(_data["transport"]) : <any>undefined;
            this.transportId = _data["transportId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workPhone"] = this.workPhone;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["jobTitleName"] = this.jobTitleName;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["departmentName"] = this.departmentName;
        data["costCenter"] = this.costCenter ? this.costCenter.toJSON() : <any>undefined;
        data["costCenterId"] = this.costCenterId;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["paymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["paymentTypeId"] = this.paymentTypeId;
        data["transport"] = this.transport ? this.transport.toJSON() : <any>undefined;
        data["transportId"] = this.transportId;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkingInfoDto {
        const json = this.toJSON();
        let result = new WorkingInfoDto();
        result.init(json);
        return result;
    }
}

export interface IWorkingInfoDto {
    workPhone: string | undefined;
    jobTitle: JobTitleDto;
    jobTitleName: string | undefined;
    department: DepartmentDto;
    departmentName: string | undefined;
    costCenter: WorkerCostCenterDto;
    costCenterId: string;
    isActive: boolean;
    farms: FarmDto[] | undefined;
    admissionDate: moment.Moment | undefined;
    paymentType: PaymentTypeDto;
    paymentTypeId: number | undefined;
    transport: TransportDto;
    transportId: string | undefined;
    id: string;
}

export class ContractWorkerDto implements IContractWorkerDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    readonly fullName: string | undefined;
    workingInfo: WorkingInfoDto;
    id: string;

    constructor(data?: IContractWorkerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
            this.workingInfo = _data["workingInfo"] ? WorkingInfoDto.fromJS(_data["workingInfo"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractWorkerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractWorkerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["workingInfo"] = this.workingInfo ? this.workingInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractWorkerDto {
        const json = this.toJSON();
        let result = new ContractWorkerDto();
        result.init(json);
        return result;
    }
}

export interface IContractWorkerDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    workingInfo: WorkingInfoDto;
    id: string;
}

export class SalaryStructureDto implements ISalaryStructureDto {
    name: string;
    code: string;
    description: string | undefined;
    company: CompanyDto;
    companyId: string;
    id: string;

    constructor(data?: ISalaryStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SalaryStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data;
    }

    clone(): SalaryStructureDto {
        const json = this.toJSON();
        let result = new SalaryStructureDto();
        result.init(json);
        return result;
    }
}

export interface ISalaryStructureDto {
    name: string;
    code: string;
    description: string | undefined;
    company: CompanyDto;
    companyId: string;
    id: string;
}

export class SalaryTypeDto implements ISalaryTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    countryCode: string;
    id: number;

    constructor(data?: ISalaryTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SalaryTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): SalaryTypeDto {
        const json = this.toJSON();
        let result = new SalaryTypeDto();
        result.init(json);
        return result;
    }
}

export interface ISalaryTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    countryCode: string;
    id: number;
}

export class SalaryBonusTypeDto implements ISalaryBonusTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: ISalaryBonusTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SalaryBonusTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryBonusTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): SalaryBonusTypeDto {
        const json = this.toJSON();
        let result = new SalaryBonusTypeDto();
        result.init(json);
        return result;
    }
}

export interface ISalaryBonusTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class ContractStatusDto implements IContractStatusDto {
    state: StateDto;
    stateId: number | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IContractStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"] ? StateDto.fromJS(_data["state"]) : <any>undefined;
            this.stateId = _data["stateId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["stateId"] = this.stateId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractStatusDto {
        const json = this.toJSON();
        let result = new ContractStatusDto();
        result.init(json);
        return result;
    }
}

export interface IContractStatusDto {
    state: StateDto;
    stateId: number | undefined;
    isActive: boolean;
    id: number;
}

export class SalaryAllowanceDto implements ISalaryAllowanceDto {
    name: string;
    code: string;
    description: string | undefined;
    amount: number;
    taxable: boolean;
    langKey: string;
    countryCode: string;
    id: string;

    constructor(data?: ISalaryAllowanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.taxable = _data["taxable"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SalaryAllowanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryAllowanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["taxable"] = this.taxable;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): SalaryAllowanceDto {
        const json = this.toJSON();
        let result = new SalaryAllowanceDto();
        result.init(json);
        return result;
    }
}

export interface ISalaryAllowanceDto {
    name: string;
    code: string;
    description: string | undefined;
    amount: number;
    taxable: boolean;
    langKey: string;
    countryCode: string;
    id: string;
}

export class WorkShiftDto implements IWorkShiftDto {
    name: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    farms: FarmDto[] | undefined;
    color: string | undefined;
    breaks: BreakDto[] | undefined;
    id: string;

    constructor(data?: IWorkShiftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.color = _data["color"];
            if (Array.isArray(_data["breaks"])) {
                this.breaks = [] as any;
                for (let item of _data["breaks"])
                    this.breaks.push(BreakDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkShiftDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkShiftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["color"] = this.color;
        if (Array.isArray(this.breaks)) {
            data["breaks"] = [];
            for (let item of this.breaks)
                data["breaks"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): WorkShiftDto {
        const json = this.toJSON();
        let result = new WorkShiftDto();
        result.init(json);
        return result;
    }
}

export interface IWorkShiftDto {
    name: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    farms: FarmDto[] | undefined;
    color: string | undefined;
    breaks: BreakDto[] | undefined;
    id: string;
}

export class WorkDayInfoDto implements IWorkDayInfoDto {
    weekDayId: number;
    workDayId: string;
    workShifts: WorkShiftDto[] | undefined;
    id: string;

    constructor(data?: IWorkDayInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weekDayId = _data["weekDayId"];
            this.workDayId = _data["workDayId"];
            if (Array.isArray(_data["workShifts"])) {
                this.workShifts = [] as any;
                for (let item of _data["workShifts"])
                    this.workShifts.push(WorkShiftDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkDayInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weekDayId"] = this.weekDayId;
        data["workDayId"] = this.workDayId;
        if (Array.isArray(this.workShifts)) {
            data["workShifts"] = [];
            for (let item of this.workShifts)
                data["workShifts"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): WorkDayInfoDto {
        const json = this.toJSON();
        let result = new WorkDayInfoDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayInfoDto {
    weekDayId: number;
    workDayId: string;
    workShifts: WorkShiftDto[] | undefined;
    id: string;
}

export class WorkDayDto implements IWorkDayDto {
    name: string;
    description: string | undefined;
    startTolerance: number;
    endTolerance: number;
    workDayTypeId: number;
    compensateOverTime: boolean;
    overTime: boolean;
    workDayRoundTypeId: number | undefined;
    daysOff: number[] | undefined;
    daysOffV2: WorkDayInfoDto[] | undefined;
    workDayInfos: WorkDayInfoDto[] | undefined;
    isDeleted: boolean;
    contractsCount: number;
    id: string;

    constructor(data?: IWorkDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.startTolerance = _data["startTolerance"];
            this.endTolerance = _data["endTolerance"];
            this.workDayTypeId = _data["workDayTypeId"];
            this.compensateOverTime = _data["compensateOverTime"];
            this.overTime = _data["overTime"];
            this.workDayRoundTypeId = _data["workDayRoundTypeId"];
            if (Array.isArray(_data["daysOff"])) {
                this.daysOff = [] as any;
                for (let item of _data["daysOff"])
                    this.daysOff.push(item);
            }
            if (Array.isArray(_data["daysOffV2"])) {
                this.daysOffV2 = [] as any;
                for (let item of _data["daysOffV2"])
                    this.daysOffV2.push(WorkDayInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["workDayInfos"])) {
                this.workDayInfos = [] as any;
                for (let item of _data["workDayInfos"])
                    this.workDayInfos.push(WorkDayInfoDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.contractsCount = _data["contractsCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startTolerance"] = this.startTolerance;
        data["endTolerance"] = this.endTolerance;
        data["workDayTypeId"] = this.workDayTypeId;
        data["compensateOverTime"] = this.compensateOverTime;
        data["overTime"] = this.overTime;
        data["workDayRoundTypeId"] = this.workDayRoundTypeId;
        if (Array.isArray(this.daysOff)) {
            data["daysOff"] = [];
            for (let item of this.daysOff)
                data["daysOff"].push(item);
        }
        if (Array.isArray(this.daysOffV2)) {
            data["daysOffV2"] = [];
            for (let item of this.daysOffV2)
                data["daysOffV2"].push(item.toJSON());
        }
        if (Array.isArray(this.workDayInfos)) {
            data["workDayInfos"] = [];
            for (let item of this.workDayInfos)
                data["workDayInfos"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["contractsCount"] = this.contractsCount;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkDayDto {
        const json = this.toJSON();
        let result = new WorkDayDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayDto {
    name: string;
    description: string | undefined;
    startTolerance: number;
    endTolerance: number;
    workDayTypeId: number;
    compensateOverTime: boolean;
    overTime: boolean;
    workDayRoundTypeId: number | undefined;
    daysOff: number[] | undefined;
    daysOffV2: WorkDayInfoDto[] | undefined;
    workDayInfos: WorkDayInfoDto[] | undefined;
    isDeleted: boolean;
    contractsCount: number;
    id: string;
}

export class WorkPermitFileDto implements IWorkPermitFileDto {
    name: string;
    path: string | undefined;
    documentTypeId: number;
    mimeType: string;
    id: string;

    constructor(data?: IWorkPermitFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.path = _data["path"];
            this.documentTypeId = _data["documentTypeId"];
            this.mimeType = _data["mimeType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkPermitFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkPermitFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["path"] = this.path;
        data["documentTypeId"] = this.documentTypeId;
        data["mimeType"] = this.mimeType;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkPermitFileDto {
        const json = this.toJSON();
        let result = new WorkPermitFileDto();
        result.init(json);
        return result;
    }
}

export interface IWorkPermitFileDto {
    name: string;
    path: string | undefined;
    documentTypeId: number;
    mimeType: string;
    id: string;
}

export class WorkPermitInfoDto implements IWorkPermitInfoDto {
    visaNumber: string;
    expireDate: moment.Moment;
    permitNumber: string | undefined;
    files: WorkPermitFileDto[] | undefined;
    id: string;

    constructor(data?: IWorkPermitInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visaNumber = _data["visaNumber"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.permitNumber = _data["permitNumber"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(WorkPermitFileDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkPermitInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkPermitInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visaNumber"] = this.visaNumber;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["permitNumber"] = this.permitNumber;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): WorkPermitInfoDto {
        const json = this.toJSON();
        let result = new WorkPermitInfoDto();
        result.init(json);
        return result;
    }
}

export interface IWorkPermitInfoDto {
    visaNumber: string;
    expireDate: moment.Moment;
    permitNumber: string | undefined;
    files: WorkPermitFileDto[] | undefined;
    id: string;
}

export class ContractFileDto implements IContractFileDto {
    name: string;
    path: string | undefined;
    documentTypeId: number;
    mimeType: string;
    id: string;

    constructor(data?: IContractFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.path = _data["path"];
            this.documentTypeId = _data["documentTypeId"];
            this.mimeType = _data["mimeType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["path"] = this.path;
        data["documentTypeId"] = this.documentTypeId;
        data["mimeType"] = this.mimeType;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractFileDto {
        const json = this.toJSON();
        let result = new ContractFileDto();
        result.init(json);
        return result;
    }
}

export interface IContractFileDto {
    name: string;
    path: string | undefined;
    documentTypeId: number;
    mimeType: string;
    id: string;
}

export class ContractDto implements IContractDto {
    correlative: CorrelativeDto;
    correlativeId: string | undefined;
    folio: CorrelativeDto;
    folioId: string | undefined;
    contractType: ContractTypeDto;
    contractTypeId: number | undefined;
    contractLayout: ContractLayoutDto;
    contractLayoutId: string | undefined;
    labors: LaborDto[] | undefined;
    jobTitle: JobTitleDto;
    jobTitleId: string | undefined;
    worker: ContractWorkerDto;
    workerId: string;
    farm: FarmDto;
    farmId: string;
    dateFrom: moment.Moment;
    dateTo: moment.Moment | undefined;
    salary: number;
    salaryStructure: SalaryStructureDto;
    salaryStructureId: string | undefined;
    salaryType: SalaryTypeDto;
    salaryTypeId: number | undefined;
    salaryBonusType: SalaryBonusTypeDto;
    salaryBonusTypeId: number | undefined;
    salaryAdvance: number;
    contractStatuses: ContractStatusDto[] | undefined;
    paymentType: PaymentTypeDto;
    paymentTypeId: number;
    salaryAllowances: SalaryAllowanceDto[] | undefined;
    workDay: WorkDayDto;
    workDayId: string | undefined;
    workPermitInfo: WorkPermitInfoDto;
    workPermitInfoId: string | undefined;
    approver: ApproverDto;
    approverId: string | undefined;
    workerSignature: boolean;
    companySignature: boolean;
    files: ContractFileDto[] | undefined;
    activeStatus: ContractStatusDto;
    id: string;

    constructor(data?: IContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlative = _data["correlative"] ? CorrelativeDto.fromJS(_data["correlative"]) : <any>undefined;
            this.correlativeId = _data["correlativeId"];
            this.folio = _data["folio"] ? CorrelativeDto.fromJS(_data["folio"]) : <any>undefined;
            this.folioId = _data["folioId"];
            this.contractType = _data["contractType"] ? ContractTypeDto.fromJS(_data["contractType"]) : <any>undefined;
            this.contractTypeId = _data["contractTypeId"];
            this.contractLayout = _data["contractLayout"] ? ContractLayoutDto.fromJS(_data["contractLayout"]) : <any>undefined;
            this.contractLayoutId = _data["contractLayoutId"];
            if (Array.isArray(_data["labors"])) {
                this.labors = [] as any;
                for (let item of _data["labors"])
                    this.labors.push(LaborDto.fromJS(item));
            }
            this.jobTitle = _data["jobTitle"] ? JobTitleDto.fromJS(_data["jobTitle"]) : <any>undefined;
            this.jobTitleId = _data["jobTitleId"];
            this.worker = _data["worker"] ? ContractWorkerDto.fromJS(_data["worker"]) : <any>undefined;
            this.workerId = _data["workerId"];
            this.farm = _data["farm"] ? FarmDto.fromJS(_data["farm"]) : <any>undefined;
            this.farmId = _data["farmId"];
            this.dateFrom = _data["dateFrom"] ? moment(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? moment(_data["dateTo"].toString()) : <any>undefined;
            this.salary = _data["salary"];
            this.salaryStructure = _data["salaryStructure"] ? SalaryStructureDto.fromJS(_data["salaryStructure"]) : <any>undefined;
            this.salaryStructureId = _data["salaryStructureId"];
            this.salaryType = _data["salaryType"] ? SalaryTypeDto.fromJS(_data["salaryType"]) : <any>undefined;
            this.salaryTypeId = _data["salaryTypeId"];
            this.salaryBonusType = _data["salaryBonusType"] ? SalaryBonusTypeDto.fromJS(_data["salaryBonusType"]) : <any>undefined;
            this.salaryBonusTypeId = _data["salaryBonusTypeId"];
            this.salaryAdvance = _data["salaryAdvance"];
            if (Array.isArray(_data["contractStatuses"])) {
                this.contractStatuses = [] as any;
                for (let item of _data["contractStatuses"])
                    this.contractStatuses.push(ContractStatusDto.fromJS(item));
            }
            this.paymentType = _data["paymentType"] ? PaymentTypeDto.fromJS(_data["paymentType"]) : <any>undefined;
            this.paymentTypeId = _data["paymentTypeId"];
            if (Array.isArray(_data["salaryAllowances"])) {
                this.salaryAllowances = [] as any;
                for (let item of _data["salaryAllowances"])
                    this.salaryAllowances.push(SalaryAllowanceDto.fromJS(item));
            }
            this.workDay = _data["workDay"] ? WorkDayDto.fromJS(_data["workDay"]) : <any>undefined;
            this.workDayId = _data["workDayId"];
            this.workPermitInfo = _data["workPermitInfo"] ? WorkPermitInfoDto.fromJS(_data["workPermitInfo"]) : <any>undefined;
            this.workPermitInfoId = _data["workPermitInfoId"];
            this.approver = _data["approver"] ? ApproverDto.fromJS(_data["approver"]) : <any>undefined;
            this.approverId = _data["approverId"];
            this.workerSignature = _data["workerSignature"];
            this.companySignature = _data["companySignature"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(ContractFileDto.fromJS(item));
            }
            this.activeStatus = _data["activeStatus"] ? ContractStatusDto.fromJS(_data["activeStatus"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlative"] = this.correlative ? this.correlative.toJSON() : <any>undefined;
        data["correlativeId"] = this.correlativeId;
        data["folio"] = this.folio ? this.folio.toJSON() : <any>undefined;
        data["folioId"] = this.folioId;
        data["contractType"] = this.contractType ? this.contractType.toJSON() : <any>undefined;
        data["contractTypeId"] = this.contractTypeId;
        data["contractLayout"] = this.contractLayout ? this.contractLayout.toJSON() : <any>undefined;
        data["contractLayoutId"] = this.contractLayoutId;
        if (Array.isArray(this.labors)) {
            data["labors"] = [];
            for (let item of this.labors)
                data["labors"].push(item.toJSON());
        }
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["jobTitleId"] = this.jobTitleId;
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        data["workerId"] = this.workerId;
        data["farm"] = this.farm ? this.farm.toJSON() : <any>undefined;
        data["farmId"] = this.farmId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.format('YYYY-MM-DD') : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.format('YYYY-MM-DD') : <any>undefined;
        data["salary"] = this.salary;
        data["salaryStructure"] = this.salaryStructure ? this.salaryStructure.toJSON() : <any>undefined;
        data["salaryStructureId"] = this.salaryStructureId;
        data["salaryType"] = this.salaryType ? this.salaryType.toJSON() : <any>undefined;
        data["salaryTypeId"] = this.salaryTypeId;
        data["salaryBonusType"] = this.salaryBonusType ? this.salaryBonusType.toJSON() : <any>undefined;
        data["salaryBonusTypeId"] = this.salaryBonusTypeId;
        data["salaryAdvance"] = this.salaryAdvance;
        if (Array.isArray(this.contractStatuses)) {
            data["contractStatuses"] = [];
            for (let item of this.contractStatuses)
                data["contractStatuses"].push(item.toJSON());
        }
        data["paymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["paymentTypeId"] = this.paymentTypeId;
        if (Array.isArray(this.salaryAllowances)) {
            data["salaryAllowances"] = [];
            for (let item of this.salaryAllowances)
                data["salaryAllowances"].push(item.toJSON());
        }
        data["workDay"] = this.workDay ? this.workDay.toJSON() : <any>undefined;
        data["workDayId"] = this.workDayId;
        data["workPermitInfo"] = this.workPermitInfo ? this.workPermitInfo.toJSON() : <any>undefined;
        data["workPermitInfoId"] = this.workPermitInfoId;
        data["approver"] = this.approver ? this.approver.toJSON() : <any>undefined;
        data["approverId"] = this.approverId;
        data["workerSignature"] = this.workerSignature;
        data["companySignature"] = this.companySignature;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["activeStatus"] = this.activeStatus ? this.activeStatus.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractDto {
        const json = this.toJSON();
        let result = new ContractDto();
        result.init(json);
        return result;
    }
}

export interface IContractDto {
    correlative: CorrelativeDto;
    correlativeId: string | undefined;
    folio: CorrelativeDto;
    folioId: string | undefined;
    contractType: ContractTypeDto;
    contractTypeId: number | undefined;
    contractLayout: ContractLayoutDto;
    contractLayoutId: string | undefined;
    labors: LaborDto[] | undefined;
    jobTitle: JobTitleDto;
    jobTitleId: string | undefined;
    worker: ContractWorkerDto;
    workerId: string;
    farm: FarmDto;
    farmId: string;
    dateFrom: moment.Moment;
    dateTo: moment.Moment | undefined;
    salary: number;
    salaryStructure: SalaryStructureDto;
    salaryStructureId: string | undefined;
    salaryType: SalaryTypeDto;
    salaryTypeId: number | undefined;
    salaryBonusType: SalaryBonusTypeDto;
    salaryBonusTypeId: number | undefined;
    salaryAdvance: number;
    contractStatuses: ContractStatusDto[] | undefined;
    paymentType: PaymentTypeDto;
    paymentTypeId: number;
    salaryAllowances: SalaryAllowanceDto[] | undefined;
    workDay: WorkDayDto;
    workDayId: string | undefined;
    workPermitInfo: WorkPermitInfoDto;
    workPermitInfoId: string | undefined;
    approver: ApproverDto;
    approverId: string | undefined;
    workerSignature: boolean;
    companySignature: boolean;
    files: ContractFileDto[] | undefined;
    activeStatus: ContractStatusDto;
    id: string;
}

export class ContractDtoPagedResultDto implements IContractDtoPagedResultDto {
    totalCount: number;
    items: ContractDto[] | undefined;

    constructor(data?: IContractDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ContractDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ContractDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ContractDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IContractDtoPagedResultDto {
    totalCount: number;
    items: ContractDto[] | undefined;
}

export class CreateWorkPermitInfoDto implements ICreateWorkPermitInfoDto {
    workerId: string;
    visaNumber: string | undefined;
    expireDate: moment.Moment;
    permitNumber: string | undefined;

    constructor(data?: ICreateWorkPermitInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workerId = _data["workerId"];
            this.visaNumber = _data["visaNumber"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.permitNumber = _data["permitNumber"];
        }
    }

    static fromJS(data: any): CreateWorkPermitInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkPermitInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workerId"] = this.workerId;
        data["visaNumber"] = this.visaNumber;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["permitNumber"] = this.permitNumber;
        return data;
    }

    clone(): CreateWorkPermitInfoDto {
        const json = this.toJSON();
        let result = new CreateWorkPermitInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkPermitInfoDto {
    workerId: string;
    visaNumber: string | undefined;
    expireDate: moment.Moment;
    permitNumber: string | undefined;
}

export class CreateContractDto implements ICreateContractDto {
    workPermitInfos: CreateWorkPermitInfoDto[] | undefined;
    documentTypeId: number | undefined;
    contractTypeId: number | undefined;
    contractLayoutId: string | undefined;
    laborIds: string[] | undefined;
    jobTitleId: string | undefined;
    departmentId: string | undefined;
    farmId: string;
    dateFrom: moment.Moment;
    dateTo: moment.Moment | undefined;
    salary: number;
    salaryStructureId: string | undefined;
    salaryTypeId: number | undefined;
    salaryBonusTypeId: number | undefined;
    salaryAdvance: number;
    paymentTypeId: number | undefined;
    salaryAllowanceIds: string[] | undefined;
    workDayId: string | undefined;

    constructor(data?: ICreateContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["workPermitInfos"])) {
                this.workPermitInfos = [] as any;
                for (let item of _data["workPermitInfos"])
                    this.workPermitInfos.push(CreateWorkPermitInfoDto.fromJS(item));
            }
            this.documentTypeId = _data["documentTypeId"];
            this.contractTypeId = _data["contractTypeId"];
            this.contractLayoutId = _data["contractLayoutId"];
            if (Array.isArray(_data["laborIds"])) {
                this.laborIds = [] as any;
                for (let item of _data["laborIds"])
                    this.laborIds.push(item);
            }
            this.jobTitleId = _data["jobTitleId"];
            this.departmentId = _data["departmentId"];
            this.farmId = _data["farmId"];
            this.dateFrom = _data["dateFrom"] ? moment(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? moment(_data["dateTo"].toString()) : <any>undefined;
            this.salary = _data["salary"];
            this.salaryStructureId = _data["salaryStructureId"];
            this.salaryTypeId = _data["salaryTypeId"];
            this.salaryBonusTypeId = _data["salaryBonusTypeId"];
            this.salaryAdvance = _data["salaryAdvance"];
            this.paymentTypeId = _data["paymentTypeId"];
            if (Array.isArray(_data["salaryAllowanceIds"])) {
                this.salaryAllowanceIds = [] as any;
                for (let item of _data["salaryAllowanceIds"])
                    this.salaryAllowanceIds.push(item);
            }
            this.workDayId = _data["workDayId"];
        }
    }

    static fromJS(data: any): CreateContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.workPermitInfos)) {
            data["workPermitInfos"] = [];
            for (let item of this.workPermitInfos)
                data["workPermitInfos"].push(item.toJSON());
        }
        data["documentTypeId"] = this.documentTypeId;
        data["contractTypeId"] = this.contractTypeId;
        data["contractLayoutId"] = this.contractLayoutId;
        if (Array.isArray(this.laborIds)) {
            data["laborIds"] = [];
            for (let item of this.laborIds)
                data["laborIds"].push(item);
        }
        data["jobTitleId"] = this.jobTitleId;
        data["departmentId"] = this.departmentId;
        data["farmId"] = this.farmId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.format('YYYY-MM-DD') : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.format('YYYY-MM-DD') : <any>undefined;
        data["salary"] = this.salary;
        data["salaryStructureId"] = this.salaryStructureId;
        data["salaryTypeId"] = this.salaryTypeId;
        data["salaryBonusTypeId"] = this.salaryBonusTypeId;
        data["salaryAdvance"] = this.salaryAdvance;
        data["paymentTypeId"] = this.paymentTypeId;
        if (Array.isArray(this.salaryAllowanceIds)) {
            data["salaryAllowanceIds"] = [];
            for (let item of this.salaryAllowanceIds)
                data["salaryAllowanceIds"].push(item);
        }
        data["workDayId"] = this.workDayId;
        return data;
    }

    clone(): CreateContractDto {
        const json = this.toJSON();
        let result = new CreateContractDto();
        result.init(json);
        return result;
    }
}

export interface ICreateContractDto {
    workPermitInfos: CreateWorkPermitInfoDto[] | undefined;
    documentTypeId: number | undefined;
    contractTypeId: number | undefined;
    contractLayoutId: string | undefined;
    laborIds: string[] | undefined;
    jobTitleId: string | undefined;
    departmentId: string | undefined;
    farmId: string;
    dateFrom: moment.Moment;
    dateTo: moment.Moment | undefined;
    salary: number;
    salaryStructureId: string | undefined;
    salaryTypeId: number | undefined;
    salaryBonusTypeId: number | undefined;
    salaryAdvance: number;
    paymentTypeId: number | undefined;
    salaryAllowanceIds: string[] | undefined;
    workDayId: string | undefined;
}

export class CreateContractAnnexDto implements ICreateContractAnnexDto {
    workPermitInfos: CreateWorkPermitInfoDto[] | undefined;
    documentTypeId: number;
    contractTypeId: number;
    contractLayoutId: string;
    laborIds: string[] | undefined;
    jobTitleId: string;
    departmentId: string | undefined;
    farmId: string;
    dateFrom: moment.Moment;
    dateTo: moment.Moment | undefined;
    salary: number;
    salaryStructureId: string;
    salaryTypeId: number;
    salaryBonusTypeId: number;
    salaryAdvance: number;
    paymentTypeId: number;
    salaryAllowanceIds: string[] | undefined;
    workDayId: string;
    parentId: string;

    constructor(data?: ICreateContractAnnexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["workPermitInfos"])) {
                this.workPermitInfos = [] as any;
                for (let item of _data["workPermitInfos"])
                    this.workPermitInfos.push(CreateWorkPermitInfoDto.fromJS(item));
            }
            this.documentTypeId = _data["documentTypeId"];
            this.contractTypeId = _data["contractTypeId"];
            this.contractLayoutId = _data["contractLayoutId"];
            if (Array.isArray(_data["laborIds"])) {
                this.laborIds = [] as any;
                for (let item of _data["laborIds"])
                    this.laborIds.push(item);
            }
            this.jobTitleId = _data["jobTitleId"];
            this.departmentId = _data["departmentId"];
            this.farmId = _data["farmId"];
            this.dateFrom = _data["dateFrom"] ? moment(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? moment(_data["dateTo"].toString()) : <any>undefined;
            this.salary = _data["salary"];
            this.salaryStructureId = _data["salaryStructureId"];
            this.salaryTypeId = _data["salaryTypeId"];
            this.salaryBonusTypeId = _data["salaryBonusTypeId"];
            this.salaryAdvance = _data["salaryAdvance"];
            this.paymentTypeId = _data["paymentTypeId"];
            if (Array.isArray(_data["salaryAllowanceIds"])) {
                this.salaryAllowanceIds = [] as any;
                for (let item of _data["salaryAllowanceIds"])
                    this.salaryAllowanceIds.push(item);
            }
            this.workDayId = _data["workDayId"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateContractAnnexDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractAnnexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.workPermitInfos)) {
            data["workPermitInfos"] = [];
            for (let item of this.workPermitInfos)
                data["workPermitInfos"].push(item.toJSON());
        }
        data["documentTypeId"] = this.documentTypeId;
        data["contractTypeId"] = this.contractTypeId;
        data["contractLayoutId"] = this.contractLayoutId;
        if (Array.isArray(this.laborIds)) {
            data["laborIds"] = [];
            for (let item of this.laborIds)
                data["laborIds"].push(item);
        }
        data["jobTitleId"] = this.jobTitleId;
        data["departmentId"] = this.departmentId;
        data["farmId"] = this.farmId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.format('YYYY-MM-DD') : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.format('YYYY-MM-DD') : <any>undefined;
        data["salary"] = this.salary;
        data["salaryStructureId"] = this.salaryStructureId;
        data["salaryTypeId"] = this.salaryTypeId;
        data["salaryBonusTypeId"] = this.salaryBonusTypeId;
        data["salaryAdvance"] = this.salaryAdvance;
        data["paymentTypeId"] = this.paymentTypeId;
        if (Array.isArray(this.salaryAllowanceIds)) {
            data["salaryAllowanceIds"] = [];
            for (let item of this.salaryAllowanceIds)
                data["salaryAllowanceIds"].push(item);
        }
        data["workDayId"] = this.workDayId;
        data["parentId"] = this.parentId;
        return data;
    }

    clone(): CreateContractAnnexDto {
        const json = this.toJSON();
        let result = new CreateContractAnnexDto();
        result.init(json);
        return result;
    }
}

export interface ICreateContractAnnexDto {
    workPermitInfos: CreateWorkPermitInfoDto[] | undefined;
    documentTypeId: number;
    contractTypeId: number;
    contractLayoutId: string;
    laborIds: string[] | undefined;
    jobTitleId: string;
    departmentId: string | undefined;
    farmId: string;
    dateFrom: moment.Moment;
    dateTo: moment.Moment | undefined;
    salary: number;
    salaryStructureId: string;
    salaryTypeId: number;
    salaryBonusTypeId: number;
    salaryAdvance: number;
    paymentTypeId: number;
    salaryAllowanceIds: string[] | undefined;
    workDayId: string;
    parentId: string;
}

export class UpdateContractDto implements IUpdateContractDto {
    name: string;
    farmId: string;
    workerId: string;
    dateFrom: moment.Moment;
    dateTo: moment.Moment;
    contractStatusId: number;
    documentsId: string[] | undefined;
    id: string;

    constructor(data?: IUpdateContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.farmId = _data["farmId"];
            this.workerId = _data["workerId"];
            this.dateFrom = _data["dateFrom"] ? moment(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? moment(_data["dateTo"].toString()) : <any>undefined;
            this.contractStatusId = _data["contractStatusId"];
            if (Array.isArray(_data["documentsId"])) {
                this.documentsId = [] as any;
                for (let item of _data["documentsId"])
                    this.documentsId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["farmId"] = this.farmId;
        data["workerId"] = this.workerId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.format('YYYY-MM-DD') : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.format('YYYY-MM-DD') : <any>undefined;
        data["contractStatusId"] = this.contractStatusId;
        if (Array.isArray(this.documentsId)) {
            data["documentsId"] = [];
            for (let item of this.documentsId)
                data["documentsId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateContractDto {
        const json = this.toJSON();
        let result = new UpdateContractDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateContractDto {
    name: string;
    farmId: string;
    workerId: string;
    dateFrom: moment.Moment;
    dateTo: moment.Moment;
    contractStatusId: number;
    documentsId: string[] | undefined;
    id: string;
}

export class AuthorizeContractDto implements IAuthorizeContractDto {
    approverId: string;
    id: string;

    constructor(data?: IAuthorizeContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approverId = _data["approverId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuthorizeContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approverId"] = this.approverId;
        data["id"] = this.id;
        return data;
    }

    clone(): AuthorizeContractDto {
        const json = this.toJSON();
        let result = new AuthorizeContractDto();
        result.init(json);
        return result;
    }
}

export interface IAuthorizeContractDto {
    approverId: string;
    id: string;
}

export class ContractCompanySignDto implements IContractCompanySignDto {
    userId: number;
    fileSign: FileDto;
    id: string;

    constructor(data?: IContractCompanySignDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fileSign = new FileDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.fileSign = _data["fileSign"] ? FileDto.fromJS(_data["fileSign"]) : new FileDto();
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractCompanySignDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractCompanySignDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["fileSign"] = this.fileSign ? this.fileSign.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractCompanySignDto {
        const json = this.toJSON();
        let result = new ContractCompanySignDto();
        result.init(json);
        return result;
    }
}

export interface IContractCompanySignDto {
    userId: number;
    fileSign: FileDto;
    id: string;
}

export class CorrelativeTypeDtoPagedResultDto implements ICorrelativeTypeDtoPagedResultDto {
    totalCount: number;
    items: CorrelativeTypeDto[] | undefined;

    constructor(data?: ICorrelativeTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CorrelativeTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CorrelativeTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CorrelativeTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CorrelativeTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CorrelativeTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICorrelativeTypeDtoPagedResultDto {
    totalCount: number;
    items: CorrelativeTypeDto[] | undefined;
}

export class RejectContractDto implements IRejectContractDto {
    approverId: string;
    id: string;

    constructor(data?: IRejectContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approverId = _data["approverId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RejectContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new RejectContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approverId"] = this.approverId;
        data["id"] = this.id;
        return data;
    }

    clone(): RejectContractDto {
        const json = this.toJSON();
        let result = new RejectContractDto();
        result.init(json);
        return result;
    }
}

export interface IRejectContractDto {
    approverId: string;
    id: string;
}

export class ContractGeneralInfoDto implements IContractGeneralInfoDto {
    contractType: ContractTypeDto;
    contractTypeId: number | undefined;
    contractLayout: ContractLayoutDto;
    contractLayoutId: string | undefined;
    labors: LaborDto[] | undefined;
    jobTitle: JobTitleDto;
    jobTitleId: string | undefined;
    id: string;

    constructor(data?: IContractGeneralInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractType = _data["contractType"] ? ContractTypeDto.fromJS(_data["contractType"]) : <any>undefined;
            this.contractTypeId = _data["contractTypeId"];
            this.contractLayout = _data["contractLayout"] ? ContractLayoutDto.fromJS(_data["contractLayout"]) : <any>undefined;
            this.contractLayoutId = _data["contractLayoutId"];
            if (Array.isArray(_data["labors"])) {
                this.labors = [] as any;
                for (let item of _data["labors"])
                    this.labors.push(LaborDto.fromJS(item));
            }
            this.jobTitle = _data["jobTitle"] ? JobTitleDto.fromJS(_data["jobTitle"]) : <any>undefined;
            this.jobTitleId = _data["jobTitleId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractGeneralInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractGeneralInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractType"] = this.contractType ? this.contractType.toJSON() : <any>undefined;
        data["contractTypeId"] = this.contractTypeId;
        data["contractLayout"] = this.contractLayout ? this.contractLayout.toJSON() : <any>undefined;
        data["contractLayoutId"] = this.contractLayoutId;
        if (Array.isArray(this.labors)) {
            data["labors"] = [];
            for (let item of this.labors)
                data["labors"].push(item.toJSON());
        }
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["jobTitleId"] = this.jobTitleId;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractGeneralInfoDto {
        const json = this.toJSON();
        let result = new ContractGeneralInfoDto();
        result.init(json);
        return result;
    }
}

export interface IContractGeneralInfoDto {
    contractType: ContractTypeDto;
    contractTypeId: number | undefined;
    contractLayout: ContractLayoutDto;
    contractLayoutId: string | undefined;
    labors: LaborDto[] | undefined;
    jobTitle: JobTitleDto;
    jobTitleId: string | undefined;
    id: string;
}

export class UpdateWorkPermitInfoDto implements IUpdateWorkPermitInfoDto {
    visaNumber: string;
    expireDate: moment.Moment;
    permitNumber: string | undefined;
    files: WorkPermitFileDto[] | undefined;
    id: string;

    constructor(data?: IUpdateWorkPermitInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visaNumber = _data["visaNumber"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.permitNumber = _data["permitNumber"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(WorkPermitFileDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkPermitInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkPermitInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visaNumber"] = this.visaNumber;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["permitNumber"] = this.permitNumber;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkPermitInfoDto {
        const json = this.toJSON();
        let result = new UpdateWorkPermitInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkPermitInfoDto {
    visaNumber: string;
    expireDate: moment.Moment;
    permitNumber: string | undefined;
    files: WorkPermitFileDto[] | undefined;
    id: string;
}

export class ContractSalaryAllowanceDto implements IContractSalaryAllowanceDto {
    salaryAllowances: SalaryAllowanceDto[] | undefined;
    id: string;

    constructor(data?: IContractSalaryAllowanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["salaryAllowances"])) {
                this.salaryAllowances = [] as any;
                for (let item of _data["salaryAllowances"])
                    this.salaryAllowances.push(SalaryAllowanceDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractSalaryAllowanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSalaryAllowanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.salaryAllowances)) {
            data["salaryAllowances"] = [];
            for (let item of this.salaryAllowances)
                data["salaryAllowances"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): ContractSalaryAllowanceDto {
        const json = this.toJSON();
        let result = new ContractSalaryAllowanceDto();
        result.init(json);
        return result;
    }
}

export interface IContractSalaryAllowanceDto {
    salaryAllowances: SalaryAllowanceDto[] | undefined;
    id: string;
}

export class ContractSalaryInfoDto implements IContractSalaryInfoDto {
    salary: number;
    salaryStructure: SalaryStructureDto;
    salaryStructureId: string | undefined;
    salaryType: SalaryTypeDto;
    salaryTypeId: number | undefined;
    salaryBonusType: SalaryBonusTypeDto;
    salaryBonusTypeId: number | undefined;
    salaryAdvance: number;
    id: string;

    constructor(data?: IContractSalaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salary = _data["salary"];
            this.salaryStructure = _data["salaryStructure"] ? SalaryStructureDto.fromJS(_data["salaryStructure"]) : <any>undefined;
            this.salaryStructureId = _data["salaryStructureId"];
            this.salaryType = _data["salaryType"] ? SalaryTypeDto.fromJS(_data["salaryType"]) : <any>undefined;
            this.salaryTypeId = _data["salaryTypeId"];
            this.salaryBonusType = _data["salaryBonusType"] ? SalaryBonusTypeDto.fromJS(_data["salaryBonusType"]) : <any>undefined;
            this.salaryBonusTypeId = _data["salaryBonusTypeId"];
            this.salaryAdvance = _data["salaryAdvance"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractSalaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSalaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salary"] = this.salary;
        data["salaryStructure"] = this.salaryStructure ? this.salaryStructure.toJSON() : <any>undefined;
        data["salaryStructureId"] = this.salaryStructureId;
        data["salaryType"] = this.salaryType ? this.salaryType.toJSON() : <any>undefined;
        data["salaryTypeId"] = this.salaryTypeId;
        data["salaryBonusType"] = this.salaryBonusType ? this.salaryBonusType.toJSON() : <any>undefined;
        data["salaryBonusTypeId"] = this.salaryBonusTypeId;
        data["salaryAdvance"] = this.salaryAdvance;
        data["id"] = this.id;
        return data;
    }

    clone(): ContractSalaryInfoDto {
        const json = this.toJSON();
        let result = new ContractSalaryInfoDto();
        result.init(json);
        return result;
    }
}

export interface IContractSalaryInfoDto {
    salary: number;
    salaryStructure: SalaryStructureDto;
    salaryStructureId: string | undefined;
    salaryType: SalaryTypeDto;
    salaryTypeId: number | undefined;
    salaryBonusType: SalaryBonusTypeDto;
    salaryBonusTypeId: number | undefined;
    salaryAdvance: number;
    id: string;
}

export class ContractLayoutDtoPagedResultDto implements IContractLayoutDtoPagedResultDto {
    totalCount: number;
    items: ContractLayoutDto[] | undefined;

    constructor(data?: IContractLayoutDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ContractLayoutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractLayoutDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractLayoutDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ContractLayoutDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ContractLayoutDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IContractLayoutDtoPagedResultDto {
    totalCount: number;
    items: ContractLayoutDto[] | undefined;
}

export class CreateContractLayoutDto implements ICreateContractLayoutDto {
    name: string;
    code: string;
    description: string | undefined;
    companyId: string;

    constructor(data?: ICreateContractLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateContractLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateContractLayoutDto {
        const json = this.toJSON();
        let result = new CreateContractLayoutDto();
        result.init(json);
        return result;
    }
}

export interface ICreateContractLayoutDto {
    name: string;
    code: string;
    description: string | undefined;
    companyId: string;
}

export class UpdateContractLayoutDto implements IUpdateContractLayoutDto {
    name: string;
    code: string;
    description: string | undefined;
    companyId: string;
    id: string;

    constructor(data?: IUpdateContractLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateContractLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateContractLayoutDto {
        const json = this.toJSON();
        let result = new UpdateContractLayoutDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateContractLayoutDto {
    name: string;
    code: string;
    description: string | undefined;
    companyId: string;
    id: string;
}

export class ContractorDtoPagedResultDto implements IContractorDtoPagedResultDto {
    totalCount: number;
    items: ContractorDto[] | undefined;

    constructor(data?: IContractorDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ContractorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractorDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractorDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ContractorDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ContractorDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IContractorDtoPagedResultDto {
    totalCount: number;
    items: ContractorDto[] | undefined;
}

export class CreateContractorDto implements ICreateContractorDto {
    dni: string;
    name: string;
    businessName: string;
    legalRepresentativeDni: string;
    legalRepresentativeName: string;
    phone: string;
    email: string;
    address: CreateAddressDto;
    folio: number;
    chore: string | undefined;
    tenantId: number;

    constructor(data?: ICreateContractorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dni = _data["dni"];
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.legalRepresentativeDni = _data["legalRepresentativeDni"];
            this.legalRepresentativeName = _data["legalRepresentativeName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"] ? CreateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.folio = _data["folio"];
            this.chore = _data["chore"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateContractorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dni"] = this.dni;
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["legalRepresentativeDni"] = this.legalRepresentativeDni;
        data["legalRepresentativeName"] = this.legalRepresentativeName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["folio"] = this.folio;
        data["chore"] = this.chore;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): CreateContractorDto {
        const json = this.toJSON();
        let result = new CreateContractorDto();
        result.init(json);
        return result;
    }
}

export interface ICreateContractorDto {
    dni: string;
    name: string;
    businessName: string;
    legalRepresentativeDni: string;
    legalRepresentativeName: string;
    phone: string;
    email: string;
    address: CreateAddressDto;
    folio: number;
    chore: string | undefined;
    tenantId: number;
}

export class UpdateContractorDto implements IUpdateContractorDto {
    dni: string;
    name: string;
    businessName: string;
    legalRepresentativeDni: string;
    legalRepresentativeName: string;
    phone: string;
    email: string;
    address: UpdateAddressDto;
    folio: number;
    chore: string | undefined;
    documentsId: string[] | undefined;
    id: string;

    constructor(data?: IUpdateContractorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dni = _data["dni"];
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.legalRepresentativeDni = _data["legalRepresentativeDni"];
            this.legalRepresentativeName = _data["legalRepresentativeName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.folio = _data["folio"];
            this.chore = _data["chore"];
            if (Array.isArray(_data["documentsId"])) {
                this.documentsId = [] as any;
                for (let item of _data["documentsId"])
                    this.documentsId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateContractorDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dni"] = this.dni;
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["legalRepresentativeDni"] = this.legalRepresentativeDni;
        data["legalRepresentativeName"] = this.legalRepresentativeName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["folio"] = this.folio;
        data["chore"] = this.chore;
        if (Array.isArray(this.documentsId)) {
            data["documentsId"] = [];
            for (let item of this.documentsId)
                data["documentsId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateContractorDto {
        const json = this.toJSON();
        let result = new UpdateContractorDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateContractorDto {
    dni: string;
    name: string;
    businessName: string;
    legalRepresentativeDni: string;
    legalRepresentativeName: string;
    phone: string;
    email: string;
    address: UpdateAddressDto;
    folio: number;
    chore: string | undefined;
    documentsId: string[] | undefined;
    id: string;
}

export class ContractTypeDtoPagedResultDto implements IContractTypeDtoPagedResultDto {
    totalCount: number;
    items: ContractTypeDto[] | undefined;

    constructor(data?: IContractTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ContractTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ContractTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ContractTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IContractTypeDtoPagedResultDto {
    totalCount: number;
    items: ContractTypeDto[] | undefined;
}

export class CreateContractTypeDto implements ICreateContractTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateContractTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateContractTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateContractTypeDto {
        const json = this.toJSON();
        let result = new CreateContractTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateContractTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
}

export class UpdateContractTypeDto implements IUpdateContractTypeDto {
    name: string;
    description: string | undefined;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateContractTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateContractTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateContractTypeDto {
        const json = this.toJSON();
        let result = new UpdateContractTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateContractTypeDto {
    name: string;
    description: string | undefined;
    countryCode: string;
    id: number;
}

export class CorrelativeDtoPagedResultDto implements ICorrelativeDtoPagedResultDto {
    totalCount: number;
    items: CorrelativeDto[] | undefined;

    constructor(data?: ICorrelativeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CorrelativeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CorrelativeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CorrelativeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CorrelativeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CorrelativeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICorrelativeDtoPagedResultDto {
    totalCount: number;
    items: CorrelativeDto[] | undefined;
}

export class CreateAgriculturalFileDto implements ICreateAgriculturalFileDto {
    surface: number;
    varietyId: number;
    plantingDate: moment.Moment;
    plants: number;
    rows: number;
    businessLineId: number;
    stageId: number;
    id: string;

    constructor(data?: ICreateAgriculturalFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surface = _data["surface"];
            this.varietyId = _data["varietyId"];
            this.plantingDate = _data["plantingDate"] ? moment(_data["plantingDate"].toString()) : <any>undefined;
            this.plants = _data["plants"];
            this.rows = _data["rows"];
            this.businessLineId = _data["businessLineId"];
            this.stageId = _data["stageId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateAgriculturalFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAgriculturalFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surface"] = this.surface;
        data["varietyId"] = this.varietyId;
        data["plantingDate"] = this.plantingDate ? this.plantingDate.toISOString() : <any>undefined;
        data["plants"] = this.plants;
        data["rows"] = this.rows;
        data["businessLineId"] = this.businessLineId;
        data["stageId"] = this.stageId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateAgriculturalFileDto {
        const json = this.toJSON();
        let result = new CreateAgriculturalFileDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAgriculturalFileDto {
    surface: number;
    varietyId: number;
    plantingDate: moment.Moment;
    plants: number;
    rows: number;
    businessLineId: number;
    stageId: number;
    id: string;
}

export class CreateCostCenterDto implements ICreateCostCenterDto {
    name: string | undefined;
    code: string | undefined;
    farmId: string;
    typeId: number;
    isInvestment: boolean;
    isDistributable: boolean;
    isDeleted: boolean;
    tagsArray: string[] | undefined;
    agriculturalFile: CreateAgriculturalFileDto;
    id: string;

    constructor(data?: ICreateCostCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.farmId = _data["farmId"];
            this.typeId = _data["typeId"];
            this.isInvestment = _data["isInvestment"];
            this.isDistributable = _data["isDistributable"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["tagsArray"])) {
                this.tagsArray = [] as any;
                for (let item of _data["tagsArray"])
                    this.tagsArray.push(item);
            }
            this.agriculturalFile = _data["agriculturalFile"] ? CreateAgriculturalFileDto.fromJS(_data["agriculturalFile"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCostCenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCostCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["farmId"] = this.farmId;
        data["typeId"] = this.typeId;
        data["isInvestment"] = this.isInvestment;
        data["isDistributable"] = this.isDistributable;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.tagsArray)) {
            data["tagsArray"] = [];
            for (let item of this.tagsArray)
                data["tagsArray"].push(item);
        }
        data["agriculturalFile"] = this.agriculturalFile ? this.agriculturalFile.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateCostCenterDto {
        const json = this.toJSON();
        let result = new CreateCostCenterDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCostCenterDto {
    name: string | undefined;
    code: string | undefined;
    farmId: string;
    typeId: number;
    isInvestment: boolean;
    isDistributable: boolean;
    isDeleted: boolean;
    tagsArray: string[] | undefined;
    agriculturalFile: CreateAgriculturalFileDto;
    id: string;
}

export class SimpleVarietyDto implements ISimpleVarietyDto {
    name: string | undefined;
    businessName: string | undefined;
    speciesId: number;
    speciesName: string | undefined;
    id: number;

    constructor(data?: ISimpleVarietyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.speciesId = _data["speciesId"];
            this.speciesName = _data["speciesName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleVarietyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleVarietyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["speciesId"] = this.speciesId;
        data["speciesName"] = this.speciesName;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleVarietyDto {
        const json = this.toJSON();
        let result = new SimpleVarietyDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleVarietyDto {
    name: string | undefined;
    businessName: string | undefined;
    speciesId: number;
    speciesName: string | undefined;
    id: number;
}

export class AgriculturalFileDto implements IAgriculturalFileDto {
    surface: number;
    variety: SimpleVarietyDto;
    plantingDate: moment.Moment;
    plants: number;
    rows: number;
    businessLineId: number;
    businessLineName: string | undefined;
    businessLineLocalizationKey: string | undefined;
    stageId: number;
    stageName: string | undefined;
    stageLocalizationKey: string | undefined;
    id: string;

    constructor(data?: IAgriculturalFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surface = _data["surface"];
            this.variety = _data["variety"] ? SimpleVarietyDto.fromJS(_data["variety"]) : <any>undefined;
            this.plantingDate = _data["plantingDate"] ? moment(_data["plantingDate"].toString()) : <any>undefined;
            this.plants = _data["plants"];
            this.rows = _data["rows"];
            this.businessLineId = _data["businessLineId"];
            this.businessLineName = _data["businessLineName"];
            this.businessLineLocalizationKey = _data["businessLineLocalizationKey"];
            this.stageId = _data["stageId"];
            this.stageName = _data["stageName"];
            this.stageLocalizationKey = _data["stageLocalizationKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AgriculturalFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgriculturalFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surface"] = this.surface;
        data["variety"] = this.variety ? this.variety.toJSON() : <any>undefined;
        data["plantingDate"] = this.plantingDate ? this.plantingDate.toISOString() : <any>undefined;
        data["plants"] = this.plants;
        data["rows"] = this.rows;
        data["businessLineId"] = this.businessLineId;
        data["businessLineName"] = this.businessLineName;
        data["businessLineLocalizationKey"] = this.businessLineLocalizationKey;
        data["stageId"] = this.stageId;
        data["stageName"] = this.stageName;
        data["stageLocalizationKey"] = this.stageLocalizationKey;
        data["id"] = this.id;
        return data;
    }

    clone(): AgriculturalFileDto {
        const json = this.toJSON();
        let result = new AgriculturalFileDto();
        result.init(json);
        return result;
    }
}

export interface IAgriculturalFileDto {
    surface: number;
    variety: SimpleVarietyDto;
    plantingDate: moment.Moment;
    plants: number;
    rows: number;
    businessLineId: number;
    businessLineName: string | undefined;
    businessLineLocalizationKey: string | undefined;
    stageId: number;
    stageName: string | undefined;
    stageLocalizationKey: string | undefined;
    id: string;
}

export class CostCenterDto implements ICostCenterDto {
    name: string | undefined;
    code: string | undefined;
    farmId: string;
    farmName: string | undefined;
    typeId: number;
    typeName: string | undefined;
    typeLocalizationKey: string | undefined;
    isInvestment: boolean;
    isDistributable: boolean;
    isDeleted: boolean;
    tags: TagDto[] | undefined;
    agriculturalFile: AgriculturalFileDto;
    id: string;

    constructor(data?: ICostCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.farmId = _data["farmId"];
            this.farmName = _data["farmName"];
            this.typeId = _data["typeId"];
            this.typeName = _data["typeName"];
            this.typeLocalizationKey = _data["typeLocalizationKey"];
            this.isInvestment = _data["isInvestment"];
            this.isDistributable = _data["isDistributable"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.agriculturalFile = _data["agriculturalFile"] ? AgriculturalFileDto.fromJS(_data["agriculturalFile"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CostCenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["farmId"] = this.farmId;
        data["farmName"] = this.farmName;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["typeLocalizationKey"] = this.typeLocalizationKey;
        data["isInvestment"] = this.isInvestment;
        data["isDistributable"] = this.isDistributable;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["agriculturalFile"] = this.agriculturalFile ? this.agriculturalFile.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): CostCenterDto {
        const json = this.toJSON();
        let result = new CostCenterDto();
        result.init(json);
        return result;
    }
}

export interface ICostCenterDto {
    name: string | undefined;
    code: string | undefined;
    farmId: string;
    farmName: string | undefined;
    typeId: number;
    typeName: string | undefined;
    typeLocalizationKey: string | undefined;
    isInvestment: boolean;
    isDistributable: boolean;
    isDeleted: boolean;
    tags: TagDto[] | undefined;
    agriculturalFile: AgriculturalFileDto;
    id: string;
}

export class UpdateCostCenterDto implements IUpdateCostCenterDto {
    name: string | undefined;
    code: string | undefined;
    farmId: string;
    typeId: number;
    isInvestment: boolean;
    isDistributable: boolean;
    isDeleted: boolean;
    tags: TagDto[] | undefined;
    agriculturalFile: CreateAgriculturalFileDto;
    id: string;

    constructor(data?: IUpdateCostCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.farmId = _data["farmId"];
            this.typeId = _data["typeId"];
            this.isInvestment = _data["isInvestment"];
            this.isDistributable = _data["isDistributable"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.agriculturalFile = _data["agriculturalFile"] ? CreateAgriculturalFileDto.fromJS(_data["agriculturalFile"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCostCenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCostCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["farmId"] = this.farmId;
        data["typeId"] = this.typeId;
        data["isInvestment"] = this.isInvestment;
        data["isDistributable"] = this.isDistributable;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["agriculturalFile"] = this.agriculturalFile ? this.agriculturalFile.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCostCenterDto {
        const json = this.toJSON();
        let result = new UpdateCostCenterDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCostCenterDto {
    name: string | undefined;
    code: string | undefined;
    farmId: string;
    typeId: number;
    isInvestment: boolean;
    isDistributable: boolean;
    isDeleted: boolean;
    tags: TagDto[] | undefined;
    agriculturalFile: CreateAgriculturalFileDto;
    id: string;
}

export class CostCenterDtoPagedResultDto implements ICostCenterDtoPagedResultDto {
    totalCount: number;
    items: CostCenterDto[] | undefined;

    constructor(data?: ICostCenterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CostCenterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CostCenterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostCenterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CostCenterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CostCenterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICostCenterDtoPagedResultDto {
    totalCount: number;
    items: CostCenterDto[] | undefined;
}

export class BussinesLineDto implements IBussinesLineDto {
    name: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IBussinesLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BussinesLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new BussinesLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): BussinesLineDto {
        const json = this.toJSON();
        let result = new BussinesLineDto();
        result.init(json);
        return result;
    }
}

export interface IBussinesLineDto {
    name: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class BussinesLineDtoPagedResultDto implements IBussinesLineDtoPagedResultDto {
    totalCount: number;
    items: BussinesLineDto[] | undefined;

    constructor(data?: IBussinesLineDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BussinesLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BussinesLineDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BussinesLineDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): BussinesLineDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BussinesLineDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBussinesLineDtoPagedResultDto {
    totalCount: number;
    items: BussinesLineDto[] | undefined;
}

export class StageDto implements IStageDto {
    name: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): StageDto {
        const json = this.toJSON();
        let result = new StageDto();
        result.init(json);
        return result;
    }
}

export interface IStageDto {
    name: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class StageDtoPagedResultDto implements IStageDtoPagedResultDto {
    totalCount: number;
    items: StageDto[] | undefined;

    constructor(data?: IStageDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(StageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StageDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StageDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StageDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StageDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStageDtoPagedResultDto {
    totalCount: number;
    items: StageDto[] | undefined;
}

export class CostCenterFilterDto implements ICostCenterFilterDto {
    name: string | undefined;
    id: string;

    constructor(data?: ICostCenterFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CostCenterFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostCenterFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): CostCenterFilterDto {
        const json = this.toJSON();
        let result = new CostCenterFilterDto();
        result.init(json);
        return result;
    }
}

export interface ICostCenterFilterDto {
    name: string | undefined;
    id: string;
}

export class CostCenterFilterDtoPagedResultDto implements ICostCenterFilterDtoPagedResultDto {
    totalCount: number;
    items: CostCenterFilterDto[] | undefined;

    constructor(data?: ICostCenterFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CostCenterFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CostCenterFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostCenterFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CostCenterFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CostCenterFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICostCenterFilterDtoPagedResultDto {
    totalCount: number;
    items: CostCenterFilterDto[] | undefined;
}

export class CreateCostCenterTypeDto implements ICreateCostCenterTypeDto {
    name: string | undefined;
    id: number;

    constructor(data?: ICreateCostCenterTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCostCenterTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCostCenterTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateCostCenterTypeDto {
        const json = this.toJSON();
        let result = new CreateCostCenterTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCostCenterTypeDto {
    name: string | undefined;
    id: number;
}

export class CostCenterTypeDto implements ICostCenterTypeDto {
    name: string | undefined;
    id: number;

    constructor(data?: ICostCenterTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CostCenterTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostCenterTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): CostCenterTypeDto {
        const json = this.toJSON();
        let result = new CostCenterTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICostCenterTypeDto {
    name: string | undefined;
    id: number;
}

export class CostCenterTypeDtoPagedResultDto implements ICostCenterTypeDtoPagedResultDto {
    totalCount: number;
    items: CostCenterTypeDto[] | undefined;

    constructor(data?: ICostCenterTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CostCenterTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CostCenterTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostCenterTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CostCenterTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CostCenterTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICostCenterTypeDtoPagedResultDto {
    totalCount: number;
    items: CostCenterTypeDto[] | undefined;
}

export class CreateCountryDto implements ICreateCountryDto {
    code: string;
    name: string;
    id: number;

    constructor(data?: ICreateCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateCountryDto {
        const json = this.toJSON();
        let result = new CreateCountryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCountryDto {
    code: string;
    name: string;
    id: number;
}

export class CountryDto implements ICountryDto {
    name: string;
    code: string | undefined;
    id: number;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): CountryDto {
        const json = this.toJSON();
        let result = new CountryDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDto {
    name: string;
    code: string | undefined;
    id: number;
}

export class CountryDtoPagedResultDto implements ICountryDtoPagedResultDto {
    totalCount: number;
    items: CountryDto[] | undefined;

    constructor(data?: ICountryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CountryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CountryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CountryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDtoPagedResultDto {
    totalCount: number;
    items: CountryDto[] | undefined;
}

export class CreateCurrencyDto implements ICreateCurrencyDto {
    name: string;
    code: string;
    symbol: string | undefined;
    id: number;

    constructor(data?: ICreateCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.symbol = _data["symbol"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["symbol"] = this.symbol;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateCurrencyDto {
        const json = this.toJSON();
        let result = new CreateCurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCurrencyDto {
    name: string;
    code: string;
    symbol: string | undefined;
    id: number;
}

export class CurrencyDtoPagedResultDto implements ICurrencyDtoPagedResultDto {
    totalCount: number;
    items: CurrencyDto[] | undefined;

    constructor(data?: ICurrencyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CurrencyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CurrencyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CurrencyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CurrencyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyDtoPagedResultDto {
    totalCount: number;
    items: CurrencyDto[] | undefined;
}

export class DepartmentFilterDto implements IDepartmentFilterDto {
    name: string;
    id: string;

    constructor(data?: IDepartmentFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DepartmentFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): DepartmentFilterDto {
        const json = this.toJSON();
        let result = new DepartmentFilterDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentFilterDto {
    name: string;
    id: string;
}

export class DepartmentFilterDtoPagedResultDto implements IDepartmentFilterDtoPagedResultDto {
    totalCount: number;
    items: DepartmentFilterDto[] | undefined;

    constructor(data?: IDepartmentFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DepartmentFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DepartmentFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DepartmentFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentFilterDtoPagedResultDto {
    totalCount: number;
    items: DepartmentFilterDto[] | undefined;
}

export class DepartmentDtoPagedResultDto implements IDepartmentDtoPagedResultDto {
    totalCount: number;
    items: DepartmentDto[] | undefined;

    constructor(data?: IDepartmentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DepartmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DepartmentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DepartmentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDtoPagedResultDto {
    totalCount: number;
    items: DepartmentDto[] | undefined;
}

export class CreateDepartmentDto implements ICreateDepartmentDto {
    name: string;
    description: string | undefined;
    supervisorId: string | undefined;
    companyId: string;

    constructor(data?: ICreateDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.supervisorId = _data["supervisorId"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["supervisorId"] = this.supervisorId;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateDepartmentDto {
        const json = this.toJSON();
        let result = new CreateDepartmentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDepartmentDto {
    name: string;
    description: string | undefined;
    supervisorId: string | undefined;
    companyId: string;
}

export class UpdateDepartmentDto implements IUpdateDepartmentDto {
    name: string;
    description: string | undefined;
    supervisorId: string | undefined;
    id: string;

    constructor(data?: IUpdateDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.supervisorId = _data["supervisorId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["supervisorId"] = this.supervisorId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateDepartmentDto {
        const json = this.toJSON();
        let result = new UpdateDepartmentDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateDepartmentDto {
    name: string;
    description: string | undefined;
    supervisorId: string | undefined;
    id: string;
}

export class CreateDocumentStatusDto implements ICreateDocumentStatusDto {
    stateId: number;

    constructor(data?: ICreateDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stateId = _data["stateId"];
        }
    }

    static fromJS(data: any): CreateDocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateId"] = this.stateId;
        return data;
    }

    clone(): CreateDocumentStatusDto {
        const json = this.toJSON();
        let result = new CreateDocumentStatusDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDocumentStatusDto {
    stateId: number;
}

export class DocumentStatusDto implements IDocumentStatusDto {
    stateId: number;
    isActive: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stateId = _data["stateId"];
            this.isActive = _data["isActive"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateId"] = this.stateId;
        data["isActive"] = this.isActive;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): DocumentStatusDto {
        const json = this.toJSON();
        let result = new DocumentStatusDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentStatusDto {
    stateId: number;
    isActive: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateDocumentStatusDto implements IUpdateDocumentStatusDto {
    stateId: number;
    isActive: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IUpdateDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stateId = _data["stateId"];
            this.isActive = _data["isActive"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateDocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateId"] = this.stateId;
        data["isActive"] = this.isActive;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateDocumentStatusDto {
        const json = this.toJSON();
        let result = new UpdateDocumentStatusDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateDocumentStatusDto {
    stateId: number;
    isActive: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class DocumentStatusDtoPagedResultDto implements IDocumentStatusDtoPagedResultDto {
    totalCount: number;
    items: DocumentStatusDto[] | undefined;

    constructor(data?: IDocumentStatusDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DocumentStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentStatusDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentStatusDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DocumentStatusDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DocumentStatusDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentStatusDtoPagedResultDto {
    totalCount: number;
    items: DocumentStatusDto[] | undefined;
}

export class DriverLicenceTypeDto implements IDriverLicenceTypeDto {
    name: string;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IDriverLicenceTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DriverLicenceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicenceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): DriverLicenceTypeDto {
        const json = this.toJSON();
        let result = new DriverLicenceTypeDto();
        result.init(json);
        return result;
    }
}

export interface IDriverLicenceTypeDto {
    name: string;
    langKey: string;
    countryCode: string;
    id: number;
}

export class DriverLicenseInfoDto implements IDriverLicenseInfoDto {
    driverLicenceTypes: DriverLicenceTypeDto[] | undefined;
    driverLicenceNumber: string | undefined;
    expireDate: moment.Moment;
    id: string;

    constructor(data?: IDriverLicenseInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["driverLicenceTypes"])) {
                this.driverLicenceTypes = [] as any;
                for (let item of _data["driverLicenceTypes"])
                    this.driverLicenceTypes.push(DriverLicenceTypeDto.fromJS(item));
            }
            this.driverLicenceNumber = _data["driverLicenceNumber"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DriverLicenseInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicenseInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.driverLicenceTypes)) {
            data["driverLicenceTypes"] = [];
            for (let item of this.driverLicenceTypes)
                data["driverLicenceTypes"].push(item.toJSON());
        }
        data["driverLicenceNumber"] = this.driverLicenceNumber;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): DriverLicenseInfoDto {
        const json = this.toJSON();
        let result = new DriverLicenseInfoDto();
        result.init(json);
        return result;
    }
}

export interface IDriverLicenseInfoDto {
    driverLicenceTypes: DriverLicenceTypeDto[] | undefined;
    driverLicenceNumber: string | undefined;
    expireDate: moment.Moment;
    id: string;
}

export class UpdateDriverLicenseInfoDto implements IUpdateDriverLicenseInfoDto {
    driverLicenceTypeIds: number[] | undefined;
    driverLicenceNumber: string | undefined;
    expireDate: moment.Moment;
    id: string;

    constructor(data?: IUpdateDriverLicenseInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["driverLicenceTypeIds"])) {
                this.driverLicenceTypeIds = [] as any;
                for (let item of _data["driverLicenceTypeIds"])
                    this.driverLicenceTypeIds.push(item);
            }
            this.driverLicenceNumber = _data["driverLicenceNumber"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateDriverLicenseInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDriverLicenseInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.driverLicenceTypeIds)) {
            data["driverLicenceTypeIds"] = [];
            for (let item of this.driverLicenceTypeIds)
                data["driverLicenceTypeIds"].push(item);
        }
        data["driverLicenceNumber"] = this.driverLicenceNumber;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateDriverLicenseInfoDto {
        const json = this.toJSON();
        let result = new UpdateDriverLicenseInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateDriverLicenseInfoDto {
    driverLicenceTypeIds: number[] | undefined;
    driverLicenceNumber: string | undefined;
    expireDate: moment.Moment;
    id: string;
}

export class DriverLicenseInfoDtoPagedResultDto implements IDriverLicenseInfoDtoPagedResultDto {
    totalCount: number;
    items: DriverLicenseInfoDto[] | undefined;

    constructor(data?: IDriverLicenseInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DriverLicenseInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DriverLicenseInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicenseInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DriverLicenseInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DriverLicenseInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDriverLicenseInfoDtoPagedResultDto {
    totalCount: number;
    items: DriverLicenseInfoDto[] | undefined;
}

export class CreateDriverLicenseInfoDto implements ICreateDriverLicenseInfoDto {
    driverLicenceTypeIds: number[] | undefined;
    driverLicenceNumber: string | undefined;
    expireDate: moment.Moment;

    constructor(data?: ICreateDriverLicenseInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["driverLicenceTypeIds"])) {
                this.driverLicenceTypeIds = [] as any;
                for (let item of _data["driverLicenceTypeIds"])
                    this.driverLicenceTypeIds.push(item);
            }
            this.driverLicenceNumber = _data["driverLicenceNumber"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateDriverLicenseInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDriverLicenseInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.driverLicenceTypeIds)) {
            data["driverLicenceTypeIds"] = [];
            for (let item of this.driverLicenceTypeIds)
                data["driverLicenceTypeIds"].push(item);
        }
        data["driverLicenceNumber"] = this.driverLicenceNumber;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): CreateDriverLicenseInfoDto {
        const json = this.toJSON();
        let result = new CreateDriverLicenseInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDriverLicenseInfoDto {
    driverLicenceTypeIds: number[] | undefined;
    driverLicenceNumber: string | undefined;
    expireDate: moment.Moment;
}

export class CreateDriverLicenseTypeDto implements ICreateDriverLicenseTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateDriverLicenseTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateDriverLicenseTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDriverLicenseTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateDriverLicenseTypeDto {
        const json = this.toJSON();
        let result = new CreateDriverLicenseTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDriverLicenseTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
}

export class UpdateDriverLicenseTypeDto implements IUpdateDriverLicenseTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateDriverLicenseTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateDriverLicenseTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDriverLicenseTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateDriverLicenseTypeDto {
        const json = this.toJSON();
        let result = new UpdateDriverLicenseTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateDriverLicenseTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class DriverLicenceTypeDtoPagedResultDto implements IDriverLicenceTypeDtoPagedResultDto {
    totalCount: number;
    items: DriverLicenceTypeDto[] | undefined;

    constructor(data?: IDriverLicenceTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DriverLicenceTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DriverLicenceTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicenceTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): DriverLicenceTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DriverLicenceTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDriverLicenceTypeDtoPagedResultDto {
    totalCount: number;
    items: DriverLicenceTypeDto[] | undefined;
}

export class CreateEconomicActivityInput implements ICreateEconomicActivityInput {
    code: string;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    businessAreaId: number;
    id: number;

    constructor(data?: ICreateEconomicActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.businessAreaId = _data["businessAreaId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateEconomicActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEconomicActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["businessAreaId"] = this.businessAreaId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateEconomicActivityInput {
        const json = this.toJSON();
        let result = new CreateEconomicActivityInput();
        result.init(json);
        return result;
    }
}

export interface ICreateEconomicActivityInput {
    code: string;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    businessAreaId: number;
    id: number;
}

export class UpdateEconomicActivityInput implements IUpdateEconomicActivityInput {
    code: string;
    description: string;
    langKey: string | undefined;
    countryCode: string | undefined;
    businessAreaId: number | undefined;
    id: number;

    constructor(data?: IUpdateEconomicActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.businessAreaId = _data["businessAreaId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateEconomicActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEconomicActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["businessAreaId"] = this.businessAreaId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateEconomicActivityInput {
        const json = this.toJSON();
        let result = new UpdateEconomicActivityInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateEconomicActivityInput {
    code: string;
    description: string;
    langKey: string | undefined;
    countryCode: string | undefined;
    businessAreaId: number | undefined;
    id: number;
}

export class EconomicActivityDtoPagedResultDto implements IEconomicActivityDtoPagedResultDto {
    totalCount: number;
    items: EconomicActivityDto[] | undefined;

    constructor(data?: IEconomicActivityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EconomicActivityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EconomicActivityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EconomicActivityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): EconomicActivityDtoPagedResultDto {
        const json = this.toJSON();
        let result = new EconomicActivityDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IEconomicActivityDtoPagedResultDto {
    totalCount: number;
    items: EconomicActivityDto[] | undefined;
}

export class EntranceDto implements IEntranceDto {
    name: string | undefined;
    description: string | undefined;
    farm: FarmDto;
    id: string;

    constructor(data?: IEntranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.farm = _data["farm"] ? FarmDto.fromJS(_data["farm"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["farm"] = this.farm ? this.farm.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): EntranceDto {
        const json = this.toJSON();
        let result = new EntranceDto();
        result.init(json);
        return result;
    }
}

export interface IEntranceDto {
    name: string | undefined;
    description: string | undefined;
    farm: FarmDto;
    id: string;
}

export class EntranceDtoPagedResultDto implements IEntranceDtoPagedResultDto {
    totalCount: number;
    items: EntranceDto[] | undefined;

    constructor(data?: IEntranceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EntranceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntranceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntranceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): EntranceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new EntranceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IEntranceDtoPagedResultDto {
    totalCount: number;
    items: EntranceDto[] | undefined;
}

export class CreateEntranceDto implements ICreateEntranceDto {
    name: string;
    description: string | undefined;
    farmId: string;

    constructor(data?: ICreateEntranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.farmId = _data["farmId"];
        }
    }

    static fromJS(data: any): CreateEntranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["farmId"] = this.farmId;
        return data;
    }

    clone(): CreateEntranceDto {
        const json = this.toJSON();
        let result = new CreateEntranceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateEntranceDto {
    name: string;
    description: string | undefined;
    farmId: string;
}

export class UpdateEntranceDto implements IUpdateEntranceDto {
    name: string | undefined;
    description: string | undefined;
    id: string;

    constructor(data?: IUpdateEntranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateEntranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateEntranceDto {
        const json = this.toJSON();
        let result = new UpdateEntranceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEntranceDto {
    name: string | undefined;
    description: string | undefined;
    id: string;
}

export class CreateFamilyDependentDto implements ICreateFamilyDependentDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    identificationNumber: string | undefined;
    student: boolean;
    relationshipId: number | undefined;
    familyDependentTypeId: number | undefined;
    genreId: string;
    birthDate: moment.Moment;
    registerDate: moment.Moment;
    finishDate: moment.Moment;
    workerId: string;
    id: string;

    constructor(data?: ICreateFamilyDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            this.identificationNumber = _data["identificationNumber"];
            this.student = _data["student"];
            this.relationshipId = _data["relationshipId"];
            this.familyDependentTypeId = _data["familyDependentTypeId"];
            this.genreId = _data["genreId"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? moment(_data["registerDate"].toString()) : <any>undefined;
            this.finishDate = _data["finishDate"] ? moment(_data["finishDate"].toString()) : <any>undefined;
            this.workerId = _data["workerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateFamilyDependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFamilyDependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["identificationNumber"] = this.identificationNumber;
        data["student"] = this.student;
        data["relationshipId"] = this.relationshipId;
        data["familyDependentTypeId"] = this.familyDependentTypeId;
        data["genreId"] = this.genreId;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["workerId"] = this.workerId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateFamilyDependentDto {
        const json = this.toJSON();
        let result = new CreateFamilyDependentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateFamilyDependentDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    identificationNumber: string | undefined;
    student: boolean;
    relationshipId: number | undefined;
    familyDependentTypeId: number | undefined;
    genreId: string;
    birthDate: moment.Moment;
    registerDate: moment.Moment;
    finishDate: moment.Moment;
    workerId: string;
    id: string;
}

export class RelationshipDto implements IRelationshipDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    id: number;

    constructor(data?: IRelationshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RelationshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelationshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): RelationshipDto {
        const json = this.toJSON();
        let result = new RelationshipDto();
        result.init(json);
        return result;
    }
}

export interface IRelationshipDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    id: number;
}

export class FamilyDependentTypeDto implements IFamilyDependentTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    id: number;

    constructor(data?: IFamilyDependentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FamilyDependentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyDependentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): FamilyDependentTypeDto {
        const json = this.toJSON();
        let result = new FamilyDependentTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFamilyDependentTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    id: number;
}

export class GenreDto implements IGenreDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: string;

    constructor(data?: IGenreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GenreDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): GenreDto {
        const json = this.toJSON();
        let result = new GenreDto();
        result.init(json);
        return result;
    }
}

export interface IGenreDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: string;
}

export class FamilyDependentDto implements IFamilyDependentDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    readonly fullName: string | undefined;
    identificationNumber: string | undefined;
    student: boolean;
    relationship: RelationshipDto;
    relationshipId: number | undefined;
    familyDependentTypeId: number | undefined;
    familyDependentType: FamilyDependentTypeDto;
    genre: GenreDto;
    genreId: string;
    birthDate: moment.Moment;
    registerDate: moment.Moment;
    finishDate: moment.Moment;
    readonly age: number;
    workerId: string;
    id: string;

    constructor(data?: IFamilyDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
            this.identificationNumber = _data["identificationNumber"];
            this.student = _data["student"];
            this.relationship = _data["relationship"] ? RelationshipDto.fromJS(_data["relationship"]) : <any>undefined;
            this.relationshipId = _data["relationshipId"];
            this.familyDependentTypeId = _data["familyDependentTypeId"];
            this.familyDependentType = _data["familyDependentType"] ? FamilyDependentTypeDto.fromJS(_data["familyDependentType"]) : <any>undefined;
            this.genre = _data["genre"] ? GenreDto.fromJS(_data["genre"]) : <any>undefined;
            this.genreId = _data["genreId"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? moment(_data["registerDate"].toString()) : <any>undefined;
            this.finishDate = _data["finishDate"] ? moment(_data["finishDate"].toString()) : <any>undefined;
            (<any>this).age = _data["age"];
            this.workerId = _data["workerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FamilyDependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyDependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["identificationNumber"] = this.identificationNumber;
        data["student"] = this.student;
        data["relationship"] = this.relationship ? this.relationship.toJSON() : <any>undefined;
        data["relationshipId"] = this.relationshipId;
        data["familyDependentTypeId"] = this.familyDependentTypeId;
        data["familyDependentType"] = this.familyDependentType ? this.familyDependentType.toJSON() : <any>undefined;
        data["genre"] = this.genre ? this.genre.toJSON() : <any>undefined;
        data["genreId"] = this.genreId;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["workerId"] = this.workerId;
        data["id"] = this.id;
        return data;
    }

    clone(): FamilyDependentDto {
        const json = this.toJSON();
        let result = new FamilyDependentDto();
        result.init(json);
        return result;
    }
}

export interface IFamilyDependentDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    identificationNumber: string | undefined;
    student: boolean;
    relationship: RelationshipDto;
    relationshipId: number | undefined;
    familyDependentTypeId: number | undefined;
    familyDependentType: FamilyDependentTypeDto;
    genre: GenreDto;
    genreId: string;
    birthDate: moment.Moment;
    registerDate: moment.Moment;
    finishDate: moment.Moment;
    age: number;
    workerId: string;
    id: string;
}

export class FamilyDependentDtoPagedResultDto implements IFamilyDependentDtoPagedResultDto {
    totalCount: number;
    items: FamilyDependentDto[] | undefined;

    constructor(data?: IFamilyDependentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FamilyDependentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FamilyDependentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyDependentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FamilyDependentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FamilyDependentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFamilyDependentDtoPagedResultDto {
    totalCount: number;
    items: FamilyDependentDto[] | undefined;
}

export class FamilySectionDto implements IFamilySectionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IFamilySectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FamilySectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilySectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): FamilySectionDto {
        const json = this.toJSON();
        let result = new FamilySectionDto();
        result.init(json);
        return result;
    }
}

export interface IFamilySectionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class InsertMethodDto implements IInsertMethodDto {
    name: string;
    langKey: string;
    description: string;
    id: number;

    constructor(data?: IInsertMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.langKey = _data["langKey"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InsertMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["langKey"] = this.langKey;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): InsertMethodDto {
        const json = this.toJSON();
        let result = new InsertMethodDto();
        result.init(json);
        return result;
    }
}

export interface IInsertMethodDto {
    name: string;
    langKey: string;
    description: string;
    id: number;
}

export class FamilyDependentInfoDto implements IFamilyDependentInfoDto {
    familySection: FamilySectionDto;
    insertMethod: InsertMethodDto;
    id: string;

    constructor(data?: IFamilyDependentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.familySection = _data["familySection"] ? FamilySectionDto.fromJS(_data["familySection"]) : <any>undefined;
            this.insertMethod = _data["insertMethod"] ? InsertMethodDto.fromJS(_data["insertMethod"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FamilyDependentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyDependentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["familySection"] = this.familySection ? this.familySection.toJSON() : <any>undefined;
        data["insertMethod"] = this.insertMethod ? this.insertMethod.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): FamilyDependentInfoDto {
        const json = this.toJSON();
        let result = new FamilyDependentInfoDto();
        result.init(json);
        return result;
    }
}

export interface IFamilyDependentInfoDto {
    familySection: FamilySectionDto;
    insertMethod: InsertMethodDto;
    id: string;
}

export class FamilyDependentInfoDtoPagedResultDto implements IFamilyDependentInfoDtoPagedResultDto {
    totalCount: number;
    items: FamilyDependentInfoDto[] | undefined;

    constructor(data?: IFamilyDependentInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FamilyDependentInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FamilyDependentInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyDependentInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FamilyDependentInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FamilyDependentInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFamilyDependentInfoDtoPagedResultDto {
    totalCount: number;
    items: FamilyDependentInfoDto[] | undefined;
}

export class CreateFamilyDependentInfoDto implements ICreateFamilyDependentInfoDto {
    familySectionId: number | undefined;
    insertMethodId: number | undefined;

    constructor(data?: ICreateFamilyDependentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.familySectionId = _data["familySectionId"];
            this.insertMethodId = _data["insertMethodId"];
        }
    }

    static fromJS(data: any): CreateFamilyDependentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFamilyDependentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["familySectionId"] = this.familySectionId;
        data["insertMethodId"] = this.insertMethodId;
        return data;
    }

    clone(): CreateFamilyDependentInfoDto {
        const json = this.toJSON();
        let result = new CreateFamilyDependentInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateFamilyDependentInfoDto {
    familySectionId: number | undefined;
    insertMethodId: number | undefined;
}

export class UpdateFamilyDependentInfoDto implements IUpdateFamilyDependentInfoDto {
    familySectionId: number | undefined;
    insertMethodId: number | undefined;
    id: string;

    constructor(data?: IUpdateFamilyDependentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.familySectionId = _data["familySectionId"];
            this.insertMethodId = _data["insertMethodId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateFamilyDependentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFamilyDependentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["familySectionId"] = this.familySectionId;
        data["insertMethodId"] = this.insertMethodId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateFamilyDependentInfoDto {
        const json = this.toJSON();
        let result = new UpdateFamilyDependentInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFamilyDependentInfoDto {
    familySectionId: number | undefined;
    insertMethodId: number | undefined;
    id: string;
}

export class CreateFamilyDependentTypeDto implements ICreateFamilyDependentTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;

    constructor(data?: ICreateFamilyDependentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateFamilyDependentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFamilyDependentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateFamilyDependentTypeDto {
        const json = this.toJSON();
        let result = new CreateFamilyDependentTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateFamilyDependentTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
}

export class UpdateFamilyDependentTypeDto implements IUpdateFamilyDependentTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    id: number;

    constructor(data?: IUpdateFamilyDependentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateFamilyDependentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFamilyDependentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateFamilyDependentTypeDto {
        const json = this.toJSON();
        let result = new UpdateFamilyDependentTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFamilyDependentTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    id: number;
}

export class FamilyDependentTypeDtoPagedResultDto implements IFamilyDependentTypeDtoPagedResultDto {
    totalCount: number;
    items: FamilyDependentTypeDto[] | undefined;

    constructor(data?: IFamilyDependentTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FamilyDependentTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FamilyDependentTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilyDependentTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FamilyDependentTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FamilyDependentTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFamilyDependentTypeDtoPagedResultDto {
    totalCount: number;
    items: FamilyDependentTypeDto[] | undefined;
}

export class FamilySectionDtoPagedResultDto implements IFamilySectionDtoPagedResultDto {
    totalCount: number;
    items: FamilySectionDto[] | undefined;

    constructor(data?: IFamilySectionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FamilySectionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FamilySectionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FamilySectionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FamilySectionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FamilySectionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFamilySectionDtoPagedResultDto {
    totalCount: number;
    items: FamilySectionDto[] | undefined;
}

export class CreateFarmDto implements ICreateFarmDto {
    name: string;
    code: string;
    phone: string;
    email: string | undefined;
    tagsArray: string[] | undefined;
    address: CreateAddressDto;
    companyId: string;
    id: string;

    constructor(data?: ICreateFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            if (Array.isArray(_data["tagsArray"])) {
                this.tagsArray = [] as any;
                for (let item of _data["tagsArray"])
                    this.tagsArray.push(item);
            }
            this.address = _data["address"] ? CreateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateFarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["phone"] = this.phone;
        data["email"] = this.email;
        if (Array.isArray(this.tagsArray)) {
            data["tagsArray"] = [];
            for (let item of this.tagsArray)
                data["tagsArray"].push(item);
        }
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateFarmDto {
        const json = this.toJSON();
        let result = new CreateFarmDto();
        result.init(json);
        return result;
    }
}

export interface ICreateFarmDto {
    name: string;
    code: string;
    phone: string;
    email: string | undefined;
    tagsArray: string[] | undefined;
    address: CreateAddressDto;
    companyId: string;
    id: string;
}

export class FarmDtoPagedResultDto implements IFarmDtoPagedResultDto {
    totalCount: number;
    items: FarmDto[] | undefined;

    constructor(data?: IFarmDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FarmDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FarmDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FarmDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FarmDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFarmDtoPagedResultDto {
    totalCount: number;
    items: FarmDto[] | undefined;
}

export class FarmSimpleDto implements IFarmSimpleDto {
    name: string | undefined;
    code: string | undefined;
    id: string;

    constructor(data?: IFarmSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FarmSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): FarmSimpleDto {
        const json = this.toJSON();
        let result = new FarmSimpleDto();
        result.init(json);
        return result;
    }
}

export interface IFarmSimpleDto {
    name: string | undefined;
    code: string | undefined;
    id: string;
}

export class FarmSimpleDtoPagedResultDto implements IFarmSimpleDtoPagedResultDto {
    totalCount: number;
    items: FarmSimpleDto[] | undefined;

    constructor(data?: IFarmSimpleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FarmSimpleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FarmSimpleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmSimpleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FarmSimpleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FarmSimpleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFarmSimpleDtoPagedResultDto {
    totalCount: number;
    items: FarmSimpleDto[] | undefined;
}

export class UpdateFarmContactDto implements IUpdateFarmContactDto {
    phone: string | undefined;
    email: string | undefined;
    addressId: string;
    address: UpdateAddressDto;
    id: string;

    constructor(data?: IUpdateFarmContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.addressId = _data["addressId"];
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateFarmContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFarmContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["addressId"] = this.addressId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateFarmContactDto {
        const json = this.toJSON();
        let result = new UpdateFarmContactDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFarmContactDto {
    phone: string | undefined;
    email: string | undefined;
    addressId: string;
    address: UpdateAddressDto;
    id: string;
}

export class UpdateFarmMainDto implements IUpdateFarmMainDto {
    name: string | undefined;
    code: string | undefined;
    readonly companyId: string;
    tags: string[] | undefined;
    id: string;

    constructor(data?: IUpdateFarmMainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            (<any>this).companyId = _data["companyId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateFarmMainDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFarmMainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateFarmMainDto {
        const json = this.toJSON();
        let result = new UpdateFarmMainDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFarmMainDto {
    name: string | undefined;
    code: string | undefined;
    companyId: string;
    tags: string[] | undefined;
    id: string;
}

export class FarmMainDto implements IFarmMainDto {
    name: string | undefined;
    code: string | undefined;
    company: FarmCompanyDto;
    tenantId: number;
    tags: TagDto[] | undefined;
    companyId: string;
    isDeleted: boolean;
    id: string;

    constructor(data?: IFarmMainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.company = _data["company"] ? FarmCompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.companyId = _data["companyId"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FarmMainDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmMainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["companyId"] = this.companyId;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): FarmMainDto {
        const json = this.toJSON();
        let result = new FarmMainDto();
        result.init(json);
        return result;
    }
}

export interface IFarmMainDto {
    name: string | undefined;
    code: string | undefined;
    company: FarmCompanyDto;
    tenantId: number;
    tags: TagDto[] | undefined;
    companyId: string;
    isDeleted: boolean;
    id: string;
}

export class FarmContactDto implements IFarmContactDto {
    phone: string | undefined;
    email: string | undefined;
    address: AddressDto;
    id: string;

    constructor(data?: IFarmContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FarmContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): FarmContactDto {
        const json = this.toJSON();
        let result = new FarmContactDto();
        result.init(json);
        return result;
    }
}

export interface IFarmContactDto {
    phone: string | undefined;
    email: string | undefined;
    address: AddressDto;
    id: string;
}

export class FarmFilterDto implements IFarmFilterDto {
    name: string | undefined;
    code: string | undefined;
    company: FarmCompanyDto;
    id: string;

    constructor(data?: IFarmFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.company = _data["company"] ? FarmCompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FarmFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): FarmFilterDto {
        const json = this.toJSON();
        let result = new FarmFilterDto();
        result.init(json);
        return result;
    }
}

export interface IFarmFilterDto {
    name: string | undefined;
    code: string | undefined;
    company: FarmCompanyDto;
    id: string;
}

export class FarmFilterDtoPagedResultDto implements IFarmFilterDtoPagedResultDto {
    totalCount: number;
    items: FarmFilterDto[] | undefined;

    constructor(data?: IFarmFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FarmFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FarmFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FarmFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FarmFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FarmFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFarmFilterDtoPagedResultDto {
    totalCount: number;
    items: FarmFilterDto[] | undefined;
}

export class UpdateFarmDto implements IUpdateFarmDto {
    name: string | undefined;
    code: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    tenantId: number;
    addressId: string;
    address: UpdateAddressDto;
    tags: TagDto[] | undefined;
    isDeleted: boolean;
    id: string;

    constructor(data?: IUpdateFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.tenantId = _data["tenantId"];
            this.addressId = _data["addressId"];
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateFarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["tenantId"] = this.tenantId;
        data["addressId"] = this.addressId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateFarmDto {
        const json = this.toJSON();
        let result = new UpdateFarmDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFarmDto {
    name: string | undefined;
    code: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    tenantId: number;
    addressId: string;
    address: UpdateAddressDto;
    tags: TagDto[] | undefined;
    isDeleted: boolean;
    id: string;
}

export class CreateFeatureDto implements ICreateFeatureDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    order: number;
    mainProductId: number;

    constructor(data?: ICreateFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.order = _data["order"];
            this.mainProductId = _data["mainProductId"];
        }
    }

    static fromJS(data: any): CreateFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["order"] = this.order;
        data["mainProductId"] = this.mainProductId;
        return data;
    }

    clone(): CreateFeatureDto {
        const json = this.toJSON();
        let result = new CreateFeatureDto();
        result.init(json);
        return result;
    }
}

export interface ICreateFeatureDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    order: number;
    mainProductId: number;
}

export class FeatureDto implements IFeatureDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    icon: string | undefined;
    order: number;
    mainProduct: MainProductDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.icon = _data["icon"];
            this.order = _data["order"];
            this.mainProduct = _data["mainProduct"] ? MainProductDto.fromJS(_data["mainProduct"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["icon"] = this.icon;
        data["order"] = this.order;
        data["mainProduct"] = this.mainProduct ? this.mainProduct.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): FeatureDto {
        const json = this.toJSON();
        let result = new FeatureDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    icon: string | undefined;
    order: number;
    mainProduct: MainProductDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateFeatureDto implements IUpdateFeatureDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    order: number;
    mainProductId: number;
    id: string;

    constructor(data?: IUpdateFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.order = _data["order"];
            this.mainProductId = _data["mainProductId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["order"] = this.order;
        data["mainProductId"] = this.mainProductId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateFeatureDto {
        const json = this.toJSON();
        let result = new UpdateFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFeatureDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    order: number;
    mainProductId: number;
    id: string;
}

export class FeatureDtoPagedResultDto implements IFeatureDtoPagedResultDto {
    totalCount: number;
    items: FeatureDto[] | undefined;

    constructor(data?: IFeatureDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeatureDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FeatureDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FeatureDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureDtoPagedResultDto {
    totalCount: number;
    items: FeatureDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class ModulePermissionDto implements IModulePermissionDto {
    moduleId: string;
    permissionName: string | undefined;
    permission: PermissionDto;
    id: string;

    constructor(data?: IModulePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moduleId = _data["moduleId"];
            this.permissionName = _data["permissionName"];
            this.permission = _data["permission"] ? PermissionDto.fromJS(_data["permission"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModulePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModulePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleId"] = this.moduleId;
        data["permissionName"] = this.permissionName;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ModulePermissionDto {
        const json = this.toJSON();
        let result = new ModulePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IModulePermissionDto {
    moduleId: string;
    permissionName: string | undefined;
    permission: PermissionDto;
    id: string;
}

export class ModulePermissionDtoPagedResultDto implements IModulePermissionDtoPagedResultDto {
    totalCount: number;
    items: ModulePermissionDto[] | undefined;

    constructor(data?: IModulePermissionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ModulePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModulePermissionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModulePermissionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ModulePermissionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ModulePermissionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IModulePermissionDtoPagedResultDto {
    totalCount: number;
    items: ModulePermissionDto[] | undefined;
}

export class CreateGenreDto implements ICreateGenreDto {
    name: string;
    description: string | undefined;
    langKey: string;

    constructor(data?: ICreateGenreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
        }
    }

    static fromJS(data: any): CreateGenreDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGenreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        return data;
    }

    clone(): CreateGenreDto {
        const json = this.toJSON();
        let result = new CreateGenreDto();
        result.init(json);
        return result;
    }
}

export interface ICreateGenreDto {
    name: string;
    description: string | undefined;
    langKey: string;
}

export class UpdateGenreDto implements IUpdateGenreDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: string;

    constructor(data?: IUpdateGenreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateGenreDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGenreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateGenreDto {
        const json = this.toJSON();
        let result = new UpdateGenreDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateGenreDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: string;
}

export class GenreDtoPagedResultDto implements IGenreDtoPagedResultDto {
    totalCount: number;
    items: GenreDto[] | undefined;

    constructor(data?: IGenreDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(GenreDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GenreDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenreDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GenreDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GenreDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGenreDtoPagedResultDto {
    totalCount: number;
    items: GenreDto[] | undefined;
}

export class CreateHealthAgreementDto implements ICreateHealthAgreementDto {
    name: string;
    description: string | undefined;
    currencyId: number;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateHealthAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.currencyId = _data["currencyId"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateHealthAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHealthAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["currencyId"] = this.currencyId;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateHealthAgreementDto {
        const json = this.toJSON();
        let result = new CreateHealthAgreementDto();
        result.init(json);
        return result;
    }
}

export interface ICreateHealthAgreementDto {
    name: string;
    description: string | undefined;
    currencyId: number;
    langKey: string;
    countryCode: string;
}

export class HealthAgreementDto implements IHealthAgreementDto {
    name: string;
    description: string | undefined;
    currency: CurrencyDto;
    currencyId: number;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IHealthAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HealthAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): HealthAgreementDto {
        const json = this.toJSON();
        let result = new HealthAgreementDto();
        result.init(json);
        return result;
    }
}

export interface IHealthAgreementDto {
    name: string;
    description: string | undefined;
    currency: CurrencyDto;
    currencyId: number;
    langKey: string;
    countryCode: string;
    id: number;
}

export class UpdateHealthAgreementDto implements IUpdateHealthAgreementDto {
    name: string;
    description: string | undefined;
    currencyId: number;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateHealthAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.currencyId = _data["currencyId"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateHealthAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHealthAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["currencyId"] = this.currencyId;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateHealthAgreementDto {
        const json = this.toJSON();
        let result = new UpdateHealthAgreementDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateHealthAgreementDto {
    name: string;
    description: string | undefined;
    currencyId: number;
    langKey: string;
    countryCode: string;
    id: number;
}

export class HealthAgreementDtoPagedResultDto implements IHealthAgreementDtoPagedResultDto {
    totalCount: number;
    items: HealthAgreementDto[] | undefined;

    constructor(data?: IHealthAgreementDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HealthAgreementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HealthAgreementDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthAgreementDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): HealthAgreementDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HealthAgreementDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHealthAgreementDtoPagedResultDto {
    totalCount: number;
    items: HealthAgreementDto[] | undefined;
}

export class HealthInstitutionDto implements IHealthInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IHealthInstitutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HealthInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): HealthInstitutionDto {
        const json = this.toJSON();
        let result = new HealthInstitutionDto();
        result.init(json);
        return result;
    }
}

export interface IHealthInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class HealthInfoDto implements IHealthInfoDto {
    healthInstitution: HealthInstitutionDto;
    fun: string | undefined;
    healthAgreement: HealthAgreementDto;
    healAgreementValue: number;
    health: boolean;
    id: string;

    constructor(data?: IHealthInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.healthInstitution = _data["healthInstitution"] ? HealthInstitutionDto.fromJS(_data["healthInstitution"]) : <any>undefined;
            this.fun = _data["fun"];
            this.healthAgreement = _data["healthAgreement"] ? HealthAgreementDto.fromJS(_data["healthAgreement"]) : <any>undefined;
            this.healAgreementValue = _data["healAgreementValue"];
            this.health = _data["health"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HealthInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["healthInstitution"] = this.healthInstitution ? this.healthInstitution.toJSON() : <any>undefined;
        data["fun"] = this.fun;
        data["healthAgreement"] = this.healthAgreement ? this.healthAgreement.toJSON() : <any>undefined;
        data["healAgreementValue"] = this.healAgreementValue;
        data["health"] = this.health;
        data["id"] = this.id;
        return data;
    }

    clone(): HealthInfoDto {
        const json = this.toJSON();
        let result = new HealthInfoDto();
        result.init(json);
        return result;
    }
}

export interface IHealthInfoDto {
    healthInstitution: HealthInstitutionDto;
    fun: string | undefined;
    healthAgreement: HealthAgreementDto;
    healAgreementValue: number;
    health: boolean;
    id: string;
}

export class HealthInfoDtoPagedResultDto implements IHealthInfoDtoPagedResultDto {
    totalCount: number;
    items: HealthInfoDto[] | undefined;

    constructor(data?: IHealthInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HealthInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HealthInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): HealthInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HealthInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHealthInfoDtoPagedResultDto {
    totalCount: number;
    items: HealthInfoDto[] | undefined;
}

export class CreateHealthInfoDto implements ICreateHealthInfoDto {
    healthInstitutionId: number;
    fun: string | undefined;
    healthAgreementId: number;
    healAgreementValue: number;
    health: boolean;

    constructor(data?: ICreateHealthInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.healthInstitutionId = _data["healthInstitutionId"];
            this.fun = _data["fun"];
            this.healthAgreementId = _data["healthAgreementId"];
            this.healAgreementValue = _data["healAgreementValue"];
            this.health = _data["health"];
        }
    }

    static fromJS(data: any): CreateHealthInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHealthInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["healthInstitutionId"] = this.healthInstitutionId;
        data["fun"] = this.fun;
        data["healthAgreementId"] = this.healthAgreementId;
        data["healAgreementValue"] = this.healAgreementValue;
        data["health"] = this.health;
        return data;
    }

    clone(): CreateHealthInfoDto {
        const json = this.toJSON();
        let result = new CreateHealthInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateHealthInfoDto {
    healthInstitutionId: number;
    fun: string | undefined;
    healthAgreementId: number;
    healAgreementValue: number;
    health: boolean;
}

export class UpdateHealthInfoDto implements IUpdateHealthInfoDto {
    healthInstitutionId: number;
    fun: string | undefined;
    healthAgreementId: number;
    healAgreementValue: number;
    health: boolean;
    id: string;

    constructor(data?: IUpdateHealthInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.healthInstitutionId = _data["healthInstitutionId"];
            this.fun = _data["fun"];
            this.healthAgreementId = _data["healthAgreementId"];
            this.healAgreementValue = _data["healAgreementValue"];
            this.health = _data["health"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateHealthInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHealthInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["healthInstitutionId"] = this.healthInstitutionId;
        data["fun"] = this.fun;
        data["healthAgreementId"] = this.healthAgreementId;
        data["healAgreementValue"] = this.healAgreementValue;
        data["health"] = this.health;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateHealthInfoDto {
        const json = this.toJSON();
        let result = new UpdateHealthInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateHealthInfoDto {
    healthInstitutionId: number;
    fun: string | undefined;
    healthAgreementId: number;
    healAgreementValue: number;
    health: boolean;
    id: string;
}

export class CreateHealthInstitutionDto implements ICreateHealthInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateHealthInstitutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateHealthInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHealthInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateHealthInstitutionDto {
        const json = this.toJSON();
        let result = new CreateHealthInstitutionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateHealthInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
}

export class UpdateHealthInstitutionDto implements IUpdateHealthInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateHealthInstitutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateHealthInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHealthInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateHealthInstitutionDto {
        const json = this.toJSON();
        let result = new UpdateHealthInstitutionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateHealthInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class HealthInstitutionDtoPagedResultDto implements IHealthInstitutionDtoPagedResultDto {
    totalCount: number;
    items: HealthInstitutionDto[] | undefined;

    constructor(data?: IHealthInstitutionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HealthInstitutionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HealthInstitutionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthInstitutionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): HealthInstitutionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HealthInstitutionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHealthInstitutionDtoPagedResultDto {
    totalCount: number;
    items: HealthInstitutionDto[] | undefined;
}

export class HeavyweightWorkTypeDto implements IHeavyweightWorkTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IHeavyweightWorkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HeavyweightWorkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new HeavyweightWorkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): HeavyweightWorkTypeDto {
        const json = this.toJSON();
        let result = new HeavyweightWorkTypeDto();
        result.init(json);
        return result;
    }
}

export interface IHeavyweightWorkTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class HeavyweightWorkTypeDtoPagedResultDto implements IHeavyweightWorkTypeDtoPagedResultDto {
    totalCount: number;
    items: HeavyweightWorkTypeDto[] | undefined;

    constructor(data?: IHeavyweightWorkTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HeavyweightWorkTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HeavyweightWorkTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HeavyweightWorkTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): HeavyweightWorkTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HeavyweightWorkTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHeavyweightWorkTypeDtoPagedResultDto {
    totalCount: number;
    items: HeavyweightWorkTypeDto[] | undefined;
}

export class IdentificationTypeDto implements IIdentificationTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    tenantId: number;
    id: string;

    constructor(data?: IIdentificationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IdentificationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentificationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): IdentificationTypeDto {
        const json = this.toJSON();
        let result = new IdentificationTypeDto();
        result.init(json);
        return result;
    }
}

export interface IIdentificationTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    tenantId: number;
    id: string;
}

export class IdentificationTypeDtoPagedResultDto implements IIdentificationTypeDtoPagedResultDto {
    totalCount: number;
    items: IdentificationTypeDto[] | undefined;

    constructor(data?: IIdentificationTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(IdentificationTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentificationTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentificationTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): IdentificationTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new IdentificationTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IIdentificationTypeDtoPagedResultDto {
    totalCount: number;
    items: IdentificationTypeDto[] | undefined;
}

export class InsertMethodDtoPagedResultDto implements IInsertMethodDtoPagedResultDto {
    totalCount: number;
    items: InsertMethodDto[] | undefined;

    constructor(data?: IInsertMethodDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(InsertMethodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsertMethodDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertMethodDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): InsertMethodDtoPagedResultDto {
        const json = this.toJSON();
        let result = new InsertMethodDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IInsertMethodDtoPagedResultDto {
    totalCount: number;
    items: InsertMethodDto[] | undefined;
}

export class CreateInstitutionTypeDto implements ICreateInstitutionTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: ICreateInstitutionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateInstitutionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInstitutionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateInstitutionTypeDto {
        const json = this.toJSON();
        let result = new CreateInstitutionTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInstitutionTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class InstitutionTypeDto implements IInstitutionTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IInstitutionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InstitutionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): InstitutionTypeDto {
        const json = this.toJSON();
        let result = new InstitutionTypeDto();
        result.init(json);
        return result;
    }
}

export interface IInstitutionTypeDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class InstitutionTypeDtoPagedResultDto implements IInstitutionTypeDtoPagedResultDto {
    totalCount: number;
    items: InstitutionTypeDto[] | undefined;

    constructor(data?: IInstitutionTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(InstitutionTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InstitutionTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): InstitutionTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new InstitutionTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IInstitutionTypeDtoPagedResultDto {
    totalCount: number;
    items: InstitutionTypeDto[] | undefined;
}

export class CreateJobTitleDto implements ICreateJobTitleDto {
    name: string;
    description: string | undefined;
    companyId: string;
    supervisorId: string | undefined;

    constructor(data?: ICreateJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.companyId = _data["companyId"];
            this.supervisorId = _data["supervisorId"];
        }
    }

    static fromJS(data: any): CreateJobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["companyId"] = this.companyId;
        data["supervisorId"] = this.supervisorId;
        return data;
    }

    clone(): CreateJobTitleDto {
        const json = this.toJSON();
        let result = new CreateJobTitleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateJobTitleDto {
    name: string;
    description: string | undefined;
    companyId: string;
    supervisorId: string | undefined;
}

export class UpdateJobTitleDto implements IUpdateJobTitleDto {
    name: string;
    description: string | undefined;
    supervisorId: string | undefined;
    id: string;

    constructor(data?: IUpdateJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.supervisorId = _data["supervisorId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateJobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["supervisorId"] = this.supervisorId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateJobTitleDto {
        const json = this.toJSON();
        let result = new UpdateJobTitleDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateJobTitleDto {
    name: string;
    description: string | undefined;
    supervisorId: string | undefined;
    id: string;
}

export class JobTitleDtoPagedResultDto implements IJobTitleDtoPagedResultDto {
    totalCount: number;
    items: JobTitleDto[] | undefined;

    constructor(data?: IJobTitleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(JobTitleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobTitleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobTitleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): JobTitleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new JobTitleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IJobTitleDtoPagedResultDto {
    totalCount: number;
    items: JobTitleDto[] | undefined;
}

export class CreateLaborDto implements ICreateLaborDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    activityId: string;
    farmIds: string[] | undefined;

    constructor(data?: ICreateLaborDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.activityId = _data["activityId"];
            if (Array.isArray(_data["farmIds"])) {
                this.farmIds = [] as any;
                for (let item of _data["farmIds"])
                    this.farmIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateLaborDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLaborDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["activityId"] = this.activityId;
        if (Array.isArray(this.farmIds)) {
            data["farmIds"] = [];
            for (let item of this.farmIds)
                data["farmIds"].push(item);
        }
        return data;
    }

    clone(): CreateLaborDto {
        const json = this.toJSON();
        let result = new CreateLaborDto();
        result.init(json);
        return result;
    }
}

export interface ICreateLaborDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    activityId: string;
    farmIds: string[] | undefined;
}

export class UpdateLaborDto implements IUpdateLaborDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    activityId: string;
    farmIds: string[] | undefined;
    id: string;

    constructor(data?: IUpdateLaborDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.activityId = _data["activityId"];
            if (Array.isArray(_data["farmIds"])) {
                this.farmIds = [] as any;
                for (let item of _data["farmIds"])
                    this.farmIds.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateLaborDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLaborDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["activityId"] = this.activityId;
        if (Array.isArray(this.farmIds)) {
            data["farmIds"] = [];
            for (let item of this.farmIds)
                data["farmIds"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateLaborDto {
        const json = this.toJSON();
        let result = new UpdateLaborDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateLaborDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    activityId: string;
    farmIds: string[] | undefined;
    id: string;
}

export class LaborDtoPagedResultDto implements ILaborDtoPagedResultDto {
    totalCount: number;
    items: LaborDto[] | undefined;

    constructor(data?: ILaborDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LaborDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LaborDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LaborDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LaborDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LaborDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILaborDtoPagedResultDto {
    totalCount: number;
    items: LaborDto[] | undefined;
}

export class CreateLegalRepresentativeDto implements ICreateLegalRepresentativeDto {
    name: string;
    rut: string;
    email: string;
    tenantId: number;
    id: string;

    constructor(data?: ICreateLegalRepresentativeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.rut = _data["rut"];
            this.email = _data["email"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateLegalRepresentativeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLegalRepresentativeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["rut"] = this.rut;
        data["email"] = this.email;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateLegalRepresentativeDto {
        const json = this.toJSON();
        let result = new CreateLegalRepresentativeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateLegalRepresentativeDto {
    name: string;
    rut: string;
    email: string;
    tenantId: number;
    id: string;
}

export class LegalRepresentativeDto implements ILegalRepresentativeDto {
    name: string;
    rut: string;
    email: string;
    tenantId: number;
    id: string;

    constructor(data?: ILegalRepresentativeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.rut = _data["rut"];
            this.email = _data["email"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LegalRepresentativeDto {
        data = typeof data === 'object' ? data : {};
        let result = new LegalRepresentativeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["rut"] = this.rut;
        data["email"] = this.email;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): LegalRepresentativeDto {
        const json = this.toJSON();
        let result = new LegalRepresentativeDto();
        result.init(json);
        return result;
    }
}

export interface ILegalRepresentativeDto {
    name: string;
    rut: string;
    email: string;
    tenantId: number;
    id: string;
}

export class LegalRepresentativeDtoPagedResultDto implements ILegalRepresentativeDtoPagedResultDto {
    totalCount: number;
    items: LegalRepresentativeDto[] | undefined;

    constructor(data?: ILegalRepresentativeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LegalRepresentativeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LegalRepresentativeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LegalRepresentativeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LegalRepresentativeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LegalRepresentativeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILegalRepresentativeDtoPagedResultDto {
    totalCount: number;
    items: LegalRepresentativeDto[] | undefined;
}

export class CreateMacroActivityDto implements ICreateMacroActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    farmIds: string[] | undefined;

    constructor(data?: ICreateMacroActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            if (Array.isArray(_data["farmIds"])) {
                this.farmIds = [] as any;
                for (let item of _data["farmIds"])
                    this.farmIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateMacroActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMacroActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        if (Array.isArray(this.farmIds)) {
            data["farmIds"] = [];
            for (let item of this.farmIds)
                data["farmIds"].push(item);
        }
        return data;
    }

    clone(): CreateMacroActivityDto {
        const json = this.toJSON();
        let result = new CreateMacroActivityDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMacroActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    farmIds: string[] | undefined;
}

export class MacroActivityActivityDto implements IMacroActivityActivityDto {
    name: string | undefined;
    code: string | undefined;
    id: string;

    constructor(data?: IMacroActivityActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MacroActivityActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new MacroActivityActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): MacroActivityActivityDto {
        const json = this.toJSON();
        let result = new MacroActivityActivityDto();
        result.init(json);
        return result;
    }
}

export interface IMacroActivityActivityDto {
    name: string | undefined;
    code: string | undefined;
    id: string;
}

export class MacroActivityDto implements IMacroActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    farms: FarmDto[] | undefined;
    activities: MacroActivityActivityDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IMacroActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities.push(MacroActivityActivityDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MacroActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new MacroActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): MacroActivityDto {
        const json = this.toJSON();
        let result = new MacroActivityDto();
        result.init(json);
        return result;
    }
}

export interface IMacroActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    farms: FarmDto[] | undefined;
    activities: MacroActivityActivityDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateMacroActivityDto implements IUpdateMacroActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    farmIds: string[] | undefined;
    id: string;

    constructor(data?: IUpdateMacroActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            if (Array.isArray(_data["farmIds"])) {
                this.farmIds = [] as any;
                for (let item of _data["farmIds"])
                    this.farmIds.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateMacroActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMacroActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        if (Array.isArray(this.farmIds)) {
            data["farmIds"] = [];
            for (let item of this.farmIds)
                data["farmIds"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateMacroActivityDto {
        const json = this.toJSON();
        let result = new UpdateMacroActivityDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateMacroActivityDto {
    name: string | undefined;
    code: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    countryCode: string | undefined;
    farmIds: string[] | undefined;
    id: string;
}

export class MacroActivityDtoPagedResultDto implements IMacroActivityDtoPagedResultDto {
    totalCount: number;
    items: MacroActivityDto[] | undefined;

    constructor(data?: IMacroActivityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MacroActivityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MacroActivityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MacroActivityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): MacroActivityDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MacroActivityDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMacroActivityDtoPagedResultDto {
    totalCount: number;
    items: MacroActivityDto[] | undefined;
}

export class MainProductDtoPagedResultDto implements IMainProductDtoPagedResultDto {
    totalCount: number;
    items: MainProductDto[] | undefined;

    constructor(data?: IMainProductDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MainProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainProductDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainProductDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): MainProductDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MainProductDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMainProductDtoPagedResultDto {
    totalCount: number;
    items: MainProductDto[] | undefined;
}

export class CreateMainProductDto implements ICreateMainProductDto {
    name: string;
    code: string;
    logo: string;
    descripctionKey: string;

    constructor(data?: ICreateMainProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.logo = _data["logo"];
            this.descripctionKey = _data["descripctionKey"];
        }
    }

    static fromJS(data: any): CreateMainProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMainProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["logo"] = this.logo;
        data["descripctionKey"] = this.descripctionKey;
        return data;
    }

    clone(): CreateMainProductDto {
        const json = this.toJSON();
        let result = new CreateMainProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMainProductDto {
    name: string;
    code: string;
    logo: string;
    descripctionKey: string;
}

export class UpdateMainProductDto implements IUpdateMainProductDto {
    name: string;
    code: string;
    logo: string;
    descripctionKey: string;
    id: number;

    constructor(data?: IUpdateMainProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.logo = _data["logo"];
            this.descripctionKey = _data["descripctionKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateMainProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMainProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["logo"] = this.logo;
        data["descripctionKey"] = this.descripctionKey;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateMainProductDto {
        const json = this.toJSON();
        let result = new UpdateMainProductDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateMainProductDto {
    name: string;
    code: string;
    logo: string;
    descripctionKey: string;
    id: number;
}

export class CreateMaritalStatusDto implements ICreateMaritalStatusDto {
    name: string;
    description: string | undefined;
    langKey: string;

    constructor(data?: ICreateMaritalStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
        }
    }

    static fromJS(data: any): CreateMaritalStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMaritalStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        return data;
    }

    clone(): CreateMaritalStatusDto {
        const json = this.toJSON();
        let result = new CreateMaritalStatusDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMaritalStatusDto {
    name: string;
    description: string | undefined;
    langKey: string;
}

export class MaritalStatusDto implements IMaritalStatusDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: string;

    constructor(data?: IMaritalStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaritalStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaritalStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): MaritalStatusDto {
        const json = this.toJSON();
        let result = new MaritalStatusDto();
        result.init(json);
        return result;
    }
}

export interface IMaritalStatusDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: string;
}

export class UpdateMaritalStatusDto implements IUpdateMaritalStatusDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: string;

    constructor(data?: IUpdateMaritalStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateMaritalStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMaritalStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateMaritalStatusDto {
        const json = this.toJSON();
        let result = new UpdateMaritalStatusDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateMaritalStatusDto {
    name: string;
    description: string | undefined;
    langKey: string;
    id: string;
}

export class MaritalStatusDtoPagedResultDto implements IMaritalStatusDtoPagedResultDto {
    totalCount: number;
    items: MaritalStatusDto[] | undefined;

    constructor(data?: IMaritalStatusDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MaritalStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaritalStatusDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaritalStatusDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): MaritalStatusDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MaritalStatusDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMaritalStatusDtoPagedResultDto {
    totalCount: number;
    items: MaritalStatusDto[] | undefined;
}

export class CreateMeasureUnitDto implements ICreateMeasureUnitDto {
    name: string | undefined;
    code: string | undefined;
    id: number;

    constructor(data?: ICreateMeasureUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateMeasureUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMeasureUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateMeasureUnitDto {
        const json = this.toJSON();
        let result = new CreateMeasureUnitDto();
        result.init(json);
        return result;
    }
}

export interface ICreateMeasureUnitDto {
    name: string | undefined;
    code: string | undefined;
    id: number;
}

export class MeasureUnitDto implements IMeasureUnitDto {
    name: string | undefined;
    code: string | undefined;
    id: number;

    constructor(data?: IMeasureUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MeasureUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeasureUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): MeasureUnitDto {
        const json = this.toJSON();
        let result = new MeasureUnitDto();
        result.init(json);
        return result;
    }
}

export interface IMeasureUnitDto {
    name: string | undefined;
    code: string | undefined;
    id: number;
}

export class MeasureUnitDtoPagedResultDto implements IMeasureUnitDtoPagedResultDto {
    totalCount: number;
    items: MeasureUnitDto[] | undefined;

    constructor(data?: IMeasureUnitDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MeasureUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MeasureUnitDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeasureUnitDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): MeasureUnitDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MeasureUnitDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMeasureUnitDtoPagedResultDto {
    totalCount: number;
    items: MeasureUnitDto[] | undefined;
}

export class CreateModulePermissionDto implements ICreateModulePermissionDto {
    permissionName: string | undefined;

    constructor(data?: ICreateModulePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionName = _data["permissionName"];
        }
    }

    static fromJS(data: any): CreateModulePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModulePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionName"] = this.permissionName;
        return data;
    }

    clone(): CreateModulePermissionDto {
        const json = this.toJSON();
        let result = new CreateModulePermissionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateModulePermissionDto {
    permissionName: string | undefined;
}

export class CreateModuleDto implements ICreateModuleDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    icon: string | undefined;
    order: number;
    permissions: CreateModulePermissionDto[] | undefined;
    featureId: string;

    constructor(data?: ICreateModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.icon = _data["icon"];
            this.order = _data["order"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(CreateModulePermissionDto.fromJS(item));
            }
            this.featureId = _data["featureId"];
        }
    }

    static fromJS(data: any): CreateModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["icon"] = this.icon;
        data["order"] = this.order;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["featureId"] = this.featureId;
        return data;
    }

    clone(): CreateModuleDto {
        const json = this.toJSON();
        let result = new CreateModuleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateModuleDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    icon: string | undefined;
    order: number;
    permissions: CreateModulePermissionDto[] | undefined;
    featureId: string;
}

export class ModulePermissionSimpleDto implements IModulePermissionSimpleDto {
    permissionName: string | undefined;
    permission: PermissionDto;
    id: string;

    constructor(data?: IModulePermissionSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionName = _data["permissionName"];
            this.permission = _data["permission"] ? PermissionDto.fromJS(_data["permission"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModulePermissionSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModulePermissionSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionName"] = this.permissionName;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ModulePermissionSimpleDto {
        const json = this.toJSON();
        let result = new ModulePermissionSimpleDto();
        result.init(json);
        return result;
    }
}

export interface IModulePermissionSimpleDto {
    permissionName: string | undefined;
    permission: PermissionDto;
    id: string;
}

export class ParentDto implements IParentDto {
    name: string;
    url: string;
    permissionId: number;
    id: string;

    constructor(data?: IParentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.url = _data["url"];
            this.permissionId = _data["permissionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ParentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["url"] = this.url;
        data["permissionId"] = this.permissionId;
        data["id"] = this.id;
        return data;
    }

    clone(): ParentDto {
        const json = this.toJSON();
        let result = new ParentDto();
        result.init(json);
        return result;
    }
}

export interface IParentDto {
    name: string;
    url: string;
    permissionId: number;
    id: string;
}

export class ChildrenChildDto implements IChildrenChildDto {
    name: string;
    description: string;
    langKey: string;
    url: string;
    permissionName: string | undefined;
    parentId: string | undefined;
    id: string;

    constructor(data?: IChildrenChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.url = _data["url"];
            this.permissionName = _data["permissionName"];
            this.parentId = _data["parentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChildrenChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChildrenChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["url"] = this.url;
        data["permissionName"] = this.permissionName;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data;
    }

    clone(): ChildrenChildDto {
        const json = this.toJSON();
        let result = new ChildrenChildDto();
        result.init(json);
        return result;
    }
}

export interface IChildrenChildDto {
    name: string;
    description: string;
    langKey: string;
    url: string;
    permissionName: string | undefined;
    parentId: string | undefined;
    id: string;
}

export class ChildrenDto implements IChildrenDto {
    name: string;
    description: string;
    langKey: string;
    url: string;
    permissionName: string | undefined;
    parentId: string | undefined;
    childrens: ChildrenChildDto[] | undefined;
    id: string;

    constructor(data?: IChildrenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.url = _data["url"];
            this.permissionName = _data["permissionName"];
            this.parentId = _data["parentId"];
            if (Array.isArray(_data["childrens"])) {
                this.childrens = [] as any;
                for (let item of _data["childrens"])
                    this.childrens.push(ChildrenChildDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChildrenDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChildrenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["url"] = this.url;
        data["permissionName"] = this.permissionName;
        data["parentId"] = this.parentId;
        if (Array.isArray(this.childrens)) {
            data["childrens"] = [];
            for (let item of this.childrens)
                data["childrens"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): ChildrenDto {
        const json = this.toJSON();
        let result = new ChildrenDto();
        result.init(json);
        return result;
    }
}

export interface IChildrenDto {
    name: string;
    description: string;
    langKey: string;
    url: string;
    permissionName: string | undefined;
    parentId: string | undefined;
    childrens: ChildrenChildDto[] | undefined;
    id: string;
}

export class PathDto implements IPathDto {
    name: string;
    description: string | undefined;
    langKey: string;
    url: string;
    order: number;
    permission: PermissionDto;
    permissionName: string | undefined;
    parent: ParentDto;
    parentId: string | undefined;
    childrens: ChildrenDto[] | undefined;
    moduleId: string;
    moduleName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IPathDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.url = _data["url"];
            this.order = _data["order"];
            this.permission = _data["permission"] ? PermissionDto.fromJS(_data["permission"]) : <any>undefined;
            this.permissionName = _data["permissionName"];
            this.parent = _data["parent"] ? ParentDto.fromJS(_data["parent"]) : <any>undefined;
            this.parentId = _data["parentId"];
            if (Array.isArray(_data["childrens"])) {
                this.childrens = [] as any;
                for (let item of _data["childrens"])
                    this.childrens.push(ChildrenDto.fromJS(item));
            }
            this.moduleId = _data["moduleId"];
            this.moduleName = _data["moduleName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PathDto {
        data = typeof data === 'object' ? data : {};
        let result = new PathDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["url"] = this.url;
        data["order"] = this.order;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        data["permissionName"] = this.permissionName;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["parentId"] = this.parentId;
        if (Array.isArray(this.childrens)) {
            data["childrens"] = [];
            for (let item of this.childrens)
                data["childrens"].push(item.toJSON());
        }
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): PathDto {
        const json = this.toJSON();
        let result = new PathDto();
        result.init(json);
        return result;
    }
}

export interface IPathDto {
    name: string;
    description: string | undefined;
    langKey: string;
    url: string;
    order: number;
    permission: PermissionDto;
    permissionName: string | undefined;
    parent: ParentDto;
    parentId: string | undefined;
    childrens: ChildrenDto[] | undefined;
    moduleId: string;
    moduleName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class ModuleDto implements IModuleDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    icon: string | undefined;
    order: number;
    requiredModules: ModuleDto[] | undefined;
    permissions: ModulePermissionSimpleDto[] | undefined;
    paths: PathDto[] | undefined;
    featureId: string;
    featureName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.icon = _data["icon"];
            this.order = _data["order"];
            if (Array.isArray(_data["requiredModules"])) {
                this.requiredModules = [] as any;
                for (let item of _data["requiredModules"])
                    this.requiredModules.push(ModuleDto.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(ModulePermissionSimpleDto.fromJS(item));
            }
            if (Array.isArray(_data["paths"])) {
                this.paths = [] as any;
                for (let item of _data["paths"])
                    this.paths.push(PathDto.fromJS(item));
            }
            this.featureId = _data["featureId"];
            this.featureName = _data["featureName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["icon"] = this.icon;
        data["order"] = this.order;
        if (Array.isArray(this.requiredModules)) {
            data["requiredModules"] = [];
            for (let item of this.requiredModules)
                data["requiredModules"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.paths)) {
            data["paths"] = [];
            for (let item of this.paths)
                data["paths"].push(item.toJSON());
        }
        data["featureId"] = this.featureId;
        data["featureName"] = this.featureName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ModuleDto {
        const json = this.toJSON();
        let result = new ModuleDto();
        result.init(json);
        return result;
    }
}

export interface IModuleDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    icon: string | undefined;
    order: number;
    requiredModules: ModuleDto[] | undefined;
    permissions: ModulePermissionSimpleDto[] | undefined;
    paths: PathDto[] | undefined;
    featureId: string;
    featureName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateModuleDto implements IUpdateModuleDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    icon: string | undefined;
    order: number;
    featureId: string;
    id: string;

    constructor(data?: IUpdateModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.icon = _data["icon"];
            this.order = _data["order"];
            this.featureId = _data["featureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["icon"] = this.icon;
        data["order"] = this.order;
        data["featureId"] = this.featureId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateModuleDto {
        const json = this.toJSON();
        let result = new UpdateModuleDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateModuleDto {
    name: string | undefined;
    description: string | undefined;
    langKey: string | undefined;
    icon: string | undefined;
    order: number;
    featureId: string;
    id: string;
}

export class UpdateModulePermissionDto implements IUpdateModulePermissionDto {
    permissionName: string | undefined;
    id: string;

    constructor(data?: IUpdateModulePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionName = _data["permissionName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateModulePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModulePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionName"] = this.permissionName;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateModulePermissionDto {
        const json = this.toJSON();
        let result = new UpdateModulePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateModulePermissionDto {
    permissionName: string | undefined;
    id: string;
}

export class UpdatePermissionModuleDto implements IUpdatePermissionModuleDto {
    permissions: UpdateModulePermissionDto[] | undefined;
    id: string;

    constructor(data?: IUpdatePermissionModuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UpdateModulePermissionDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePermissionModuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionModuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePermissionModuleDto {
        const json = this.toJSON();
        let result = new UpdatePermissionModuleDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePermissionModuleDto {
    permissions: UpdateModulePermissionDto[] | undefined;
    id: string;
}

export class ModuleDtoPagedResultDto implements IModuleDtoPagedResultDto {
    totalCount: number;
    items: ModuleDto[] | undefined;

    constructor(data?: IModuleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ModuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ModuleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ModuleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IModuleDtoPagedResultDto {
    totalCount: number;
    items: ModuleDto[] | undefined;
}

export class PathDtoPagedResultDto implements IPathDtoPagedResultDto {
    totalCount: number;
    items: PathDto[] | undefined;

    constructor(data?: IPathDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PathDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PathDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PathDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PathDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PathDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPathDtoPagedResultDto {
    totalCount: number;
    items: PathDto[] | undefined;
}

export class ModuleSimpleDto implements IModuleSimpleDto {
    name: string | undefined;
    order: number;
    icon: string | undefined;
    description: string | undefined;
    featureId: string;
    id: string;

    constructor(data?: IModuleSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.order = _data["order"];
            this.icon = _data["icon"];
            this.description = _data["description"];
            this.featureId = _data["featureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        data["icon"] = this.icon;
        data["description"] = this.description;
        data["featureId"] = this.featureId;
        data["id"] = this.id;
        return data;
    }

    clone(): ModuleSimpleDto {
        const json = this.toJSON();
        let result = new ModuleSimpleDto();
        result.init(json);
        return result;
    }
}

export interface IModuleSimpleDto {
    name: string | undefined;
    order: number;
    icon: string | undefined;
    description: string | undefined;
    featureId: string;
    id: string;
}

export class ModuleSimpleDtoPagedResultDto implements IModuleSimpleDtoPagedResultDto {
    totalCount: number;
    items: ModuleSimpleDto[] | undefined;

    constructor(data?: IModuleSimpleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ModuleSimpleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleSimpleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSimpleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ModuleSimpleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ModuleSimpleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IModuleSimpleDtoPagedResultDto {
    totalCount: number;
    items: ModuleSimpleDto[] | undefined;
}

export class CreateNoticeTypeAccountTypeDto implements ICreateNoticeTypeAccountTypeDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: ICreateNoticeTypeAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.localizationKey = _data["localizationKey"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateNoticeTypeAccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoticeTypeAccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["localizationKey"] = this.localizationKey;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateNoticeTypeAccountTypeDto {
        const json = this.toJSON();
        let result = new CreateNoticeTypeAccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateNoticeTypeAccountTypeDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class NoticeTypeDto implements INoticeTypeDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: INoticeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.localizationKey = _data["localizationKey"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NoticeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["localizationKey"] = this.localizationKey;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): NoticeTypeDto {
        const json = this.toJSON();
        let result = new NoticeTypeDto();
        result.init(json);
        return result;
    }
}

export interface INoticeTypeDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class NoticeTypeDtoPagedResultDto implements INoticeTypeDtoPagedResultDto {
    totalCount: number;
    items: NoticeTypeDto[] | undefined;

    constructor(data?: INoticeTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NoticeTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NoticeTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): NoticeTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NoticeTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INoticeTypeDtoPagedResultDto {
    totalCount: number;
    items: NoticeTypeDto[] | undefined;
}

export class CreatePathDto implements ICreatePathDto {
    name: string;
    description: string | undefined;
    langKey: string;
    url: string;
    permissionName: string;
    order: number;
    parentId: string | undefined;
    moduleId: string;

    constructor(data?: ICreatePathDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.url = _data["url"];
            this.permissionName = _data["permissionName"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.moduleId = _data["moduleId"];
        }
    }

    static fromJS(data: any): CreatePathDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePathDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["url"] = this.url;
        data["permissionName"] = this.permissionName;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["moduleId"] = this.moduleId;
        return data;
    }

    clone(): CreatePathDto {
        const json = this.toJSON();
        let result = new CreatePathDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePathDto {
    name: string;
    description: string | undefined;
    langKey: string;
    url: string;
    permissionName: string;
    order: number;
    parentId: string | undefined;
    moduleId: string;
}

export class UpdatePathDto implements IUpdatePathDto {
    name: string;
    description: string | undefined;
    url: string;
    permissionName: string;
    order: number;
    id: string;

    constructor(data?: IUpdatePathDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.permissionName = _data["permissionName"];
            this.order = _data["order"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePathDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePathDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["url"] = this.url;
        data["permissionName"] = this.permissionName;
        data["order"] = this.order;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePathDto {
        const json = this.toJSON();
        let result = new UpdatePathDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePathDto {
    name: string;
    description: string | undefined;
    url: string;
    permissionName: string;
    order: number;
    id: string;
}

export class CreatePaymentConceptDto implements ICreatePaymentConceptDto {
    name: string;
    description: string | undefined;
    code: string;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreatePaymentConceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.code = _data["code"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreatePaymentConceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentConceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["code"] = this.code;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreatePaymentConceptDto {
        const json = this.toJSON();
        let result = new CreatePaymentConceptDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentConceptDto {
    name: string;
    description: string | undefined;
    code: string;
    langKey: string;
    countryCode: string;
}

export class PaymentConceptDto implements IPaymentConceptDto {
    name: string;
    description: string | undefined;
    code: string;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IPaymentConceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.code = _data["code"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentConceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentConceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["code"] = this.code;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): PaymentConceptDto {
        const json = this.toJSON();
        let result = new PaymentConceptDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentConceptDto {
    name: string;
    description: string | undefined;
    code: string;
    langKey: string;
    countryCode: string;
    id: number;
}

export class UpdatePaymentConceptDto implements IUpdatePaymentConceptDto {
    name: string;
    description: string | undefined;
    code: string;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IUpdatePaymentConceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.code = _data["code"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePaymentConceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentConceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["code"] = this.code;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePaymentConceptDto {
        const json = this.toJSON();
        let result = new UpdatePaymentConceptDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePaymentConceptDto {
    name: string;
    description: string | undefined;
    code: string;
    langKey: string;
    countryCode: string;
    id: number;
}

export class PaymentConceptDtoPagedResultDto implements IPaymentConceptDtoPagedResultDto {
    totalCount: number;
    items: PaymentConceptDto[] | undefined;

    constructor(data?: IPaymentConceptDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PaymentConceptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentConceptDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentConceptDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaymentConceptDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentConceptDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentConceptDtoPagedResultDto {
    totalCount: number;
    items: PaymentConceptDto[] | undefined;
}

export class CreatePaymentMethodAccountTypeDto implements ICreatePaymentMethodAccountTypeDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: ICreatePaymentMethodAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.localizationKey = _data["localizationKey"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreatePaymentMethodAccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentMethodAccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["localizationKey"] = this.localizationKey;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): CreatePaymentMethodAccountTypeDto {
        const json = this.toJSON();
        let result = new CreatePaymentMethodAccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentMethodAccountTypeDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class PaymentMethodDtoPagedResultDto implements IPaymentMethodDtoPagedResultDto {
    totalCount: number;
    items: PaymentMethodDto[] | undefined;

    constructor(data?: IPaymentMethodDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PaymentMethodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentMethodDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaymentMethodDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentMethodDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentMethodDtoPagedResultDto {
    totalCount: number;
    items: PaymentMethodDto[] | undefined;
}

export class PaymentTypeDtoPagedResultDto implements IPaymentTypeDtoPagedResultDto {
    totalCount: number;
    items: PaymentTypeDto[] | undefined;

    constructor(data?: IPaymentTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PaymentTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaymentTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentTypeDtoPagedResultDto {
    totalCount: number;
    items: PaymentTypeDto[] | undefined;
}

export class CreatePayrollConceptDto implements ICreatePayrollConceptDto {
    name: string;
    code: string;
    description: string | undefined;
    sequence: number;
    payrollConceptTypeId: number;
    taxable: boolean;
    payrollConceptPeriodicityId: number;
    calculationMethodId: number;
    overDraft: boolean;
    periodEnd: boolean;
    endDate: moment.Moment | undefined;
    accountId: string;

    constructor(data?: ICreatePayrollConceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.sequence = _data["sequence"];
            this.payrollConceptTypeId = _data["payrollConceptTypeId"];
            this.taxable = _data["taxable"];
            this.payrollConceptPeriodicityId = _data["payrollConceptPeriodicityId"];
            this.calculationMethodId = _data["calculationMethodId"];
            this.overDraft = _data["overDraft"];
            this.periodEnd = _data["periodEnd"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): CreatePayrollConceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePayrollConceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["sequence"] = this.sequence;
        data["payrollConceptTypeId"] = this.payrollConceptTypeId;
        data["taxable"] = this.taxable;
        data["payrollConceptPeriodicityId"] = this.payrollConceptPeriodicityId;
        data["calculationMethodId"] = this.calculationMethodId;
        data["overDraft"] = this.overDraft;
        data["periodEnd"] = this.periodEnd;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        return data;
    }

    clone(): CreatePayrollConceptDto {
        const json = this.toJSON();
        let result = new CreatePayrollConceptDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePayrollConceptDto {
    name: string;
    code: string;
    description: string | undefined;
    sequence: number;
    payrollConceptTypeId: number;
    taxable: boolean;
    payrollConceptPeriodicityId: number;
    calculationMethodId: number;
    overDraft: boolean;
    periodEnd: boolean;
    endDate: moment.Moment | undefined;
    accountId: string;
}

export class PayrollConceptTypeDto implements IPayrollConceptTypeDto {
    name: string;
    code: string | undefined;
    description: string;
    langKey: string;
    id: number;

    constructor(data?: IPayrollConceptTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PayrollConceptTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollConceptTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): PayrollConceptTypeDto {
        const json = this.toJSON();
        let result = new PayrollConceptTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPayrollConceptTypeDto {
    name: string;
    code: string | undefined;
    description: string;
    langKey: string;
    id: number;
}

export class PayrollConceptPeriodicityDto implements IPayrollConceptPeriodicityDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    langKey: string;
    id: number;

    constructor(data?: IPayrollConceptPeriodicityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PayrollConceptPeriodicityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollConceptPeriodicityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): PayrollConceptPeriodicityDto {
        const json = this.toJSON();
        let result = new PayrollConceptPeriodicityDto();
        result.init(json);
        return result;
    }
}

export interface IPayrollConceptPeriodicityDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    langKey: string;
    id: number;
}

export class PayrollConceptCalculationMethodDto implements IPayrollConceptCalculationMethodDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    langKey: string;
    id: number;

    constructor(data?: IPayrollConceptCalculationMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PayrollConceptCalculationMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollConceptCalculationMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["id"] = this.id;
        return data;
    }

    clone(): PayrollConceptCalculationMethodDto {
        const json = this.toJSON();
        let result = new PayrollConceptCalculationMethodDto();
        result.init(json);
        return result;
    }
}

export interface IPayrollConceptCalculationMethodDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    langKey: string;
    id: number;
}

export class PayrollConceptDto implements IPayrollConceptDto {
    name: string;
    code: string;
    description: string | undefined;
    sequence: number;
    conceptType: PayrollConceptTypeDto;
    payrollConceptTypeId: number;
    taxable: boolean;
    conceptPeriodicity: PayrollConceptPeriodicityDto;
    payrollConceptPeriodicityId: number;
    calculationMethod: PayrollConceptCalculationMethodDto;
    calculationMethodId: number;
    overDraft: boolean;
    periodEnd: boolean;
    endDate: moment.Moment | undefined;
    tenantId: number | undefined;
    account: AccountDto;
    accountId: string | undefined;
    id: string;

    constructor(data?: IPayrollConceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.sequence = _data["sequence"];
            this.conceptType = _data["conceptType"] ? PayrollConceptTypeDto.fromJS(_data["conceptType"]) : <any>undefined;
            this.payrollConceptTypeId = _data["payrollConceptTypeId"];
            this.taxable = _data["taxable"];
            this.conceptPeriodicity = _data["conceptPeriodicity"] ? PayrollConceptPeriodicityDto.fromJS(_data["conceptPeriodicity"]) : <any>undefined;
            this.payrollConceptPeriodicityId = _data["payrollConceptPeriodicityId"];
            this.calculationMethod = _data["calculationMethod"] ? PayrollConceptCalculationMethodDto.fromJS(_data["calculationMethod"]) : <any>undefined;
            this.calculationMethodId = _data["calculationMethodId"];
            this.overDraft = _data["overDraft"];
            this.periodEnd = _data["periodEnd"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.account = _data["account"] ? AccountDto.fromJS(_data["account"]) : <any>undefined;
            this.accountId = _data["accountId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PayrollConceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollConceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["sequence"] = this.sequence;
        data["conceptType"] = this.conceptType ? this.conceptType.toJSON() : <any>undefined;
        data["payrollConceptTypeId"] = this.payrollConceptTypeId;
        data["taxable"] = this.taxable;
        data["conceptPeriodicity"] = this.conceptPeriodicity ? this.conceptPeriodicity.toJSON() : <any>undefined;
        data["payrollConceptPeriodicityId"] = this.payrollConceptPeriodicityId;
        data["calculationMethod"] = this.calculationMethod ? this.calculationMethod.toJSON() : <any>undefined;
        data["calculationMethodId"] = this.calculationMethodId;
        data["overDraft"] = this.overDraft;
        data["periodEnd"] = this.periodEnd;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["accountId"] = this.accountId;
        data["id"] = this.id;
        return data;
    }

    clone(): PayrollConceptDto {
        const json = this.toJSON();
        let result = new PayrollConceptDto();
        result.init(json);
        return result;
    }
}

export interface IPayrollConceptDto {
    name: string;
    code: string;
    description: string | undefined;
    sequence: number;
    conceptType: PayrollConceptTypeDto;
    payrollConceptTypeId: number;
    taxable: boolean;
    conceptPeriodicity: PayrollConceptPeriodicityDto;
    payrollConceptPeriodicityId: number;
    calculationMethod: PayrollConceptCalculationMethodDto;
    calculationMethodId: number;
    overDraft: boolean;
    periodEnd: boolean;
    endDate: moment.Moment | undefined;
    tenantId: number | undefined;
    account: AccountDto;
    accountId: string | undefined;
    id: string;
}

export class PayrollConceptDtoPagedResultDto implements IPayrollConceptDtoPagedResultDto {
    totalCount: number;
    items: PayrollConceptDto[] | undefined;

    constructor(data?: IPayrollConceptDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PayrollConceptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PayrollConceptDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollConceptDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PayrollConceptDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PayrollConceptDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPayrollConceptDtoPagedResultDto {
    totalCount: number;
    items: PayrollConceptDto[] | undefined;
}

export class UpdatePayrollConceptDto implements IUpdatePayrollConceptDto {
    name: string;
    code: string;
    description: string | undefined;
    sequence: number;
    payrollConceptTypeId: number;
    taxable: boolean;
    payrollConceptPeriodicityId: number;
    calculationMethodId: number;
    overDraft: boolean;
    periodEnd: boolean;
    endDate: moment.Moment | undefined;
    accountId: string;
    id: string;

    constructor(data?: IUpdatePayrollConceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.sequence = _data["sequence"];
            this.payrollConceptTypeId = _data["payrollConceptTypeId"];
            this.taxable = _data["taxable"];
            this.payrollConceptPeriodicityId = _data["payrollConceptPeriodicityId"];
            this.calculationMethodId = _data["calculationMethodId"];
            this.overDraft = _data["overDraft"];
            this.periodEnd = _data["periodEnd"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.accountId = _data["accountId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePayrollConceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePayrollConceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["sequence"] = this.sequence;
        data["payrollConceptTypeId"] = this.payrollConceptTypeId;
        data["taxable"] = this.taxable;
        data["payrollConceptPeriodicityId"] = this.payrollConceptPeriodicityId;
        data["calculationMethodId"] = this.calculationMethodId;
        data["overDraft"] = this.overDraft;
        data["periodEnd"] = this.periodEnd;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["accountId"] = this.accountId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePayrollConceptDto {
        const json = this.toJSON();
        let result = new UpdatePayrollConceptDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePayrollConceptDto {
    name: string;
    code: string;
    description: string | undefined;
    sequence: number;
    payrollConceptTypeId: number;
    taxable: boolean;
    payrollConceptPeriodicityId: number;
    calculationMethodId: number;
    overDraft: boolean;
    periodEnd: boolean;
    endDate: moment.Moment | undefined;
    accountId: string;
    id: string;
}

export class PayrollConceptFilterDto implements IPayrollConceptFilterDto {
    name: string;
    code: string;
    id: string;

    constructor(data?: IPayrollConceptFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PayrollConceptFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollConceptFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): PayrollConceptFilterDto {
        const json = this.toJSON();
        let result = new PayrollConceptFilterDto();
        result.init(json);
        return result;
    }
}

export interface IPayrollConceptFilterDto {
    name: string;
    code: string;
    id: string;
}

export class PayrollConceptFilterDtoPagedResultDto implements IPayrollConceptFilterDtoPagedResultDto {
    totalCount: number;
    items: PayrollConceptFilterDto[] | undefined;

    constructor(data?: IPayrollConceptFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PayrollConceptFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PayrollConceptFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayrollConceptFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PayrollConceptFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PayrollConceptFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPayrollConceptFilterDtoPagedResultDto {
    totalCount: number;
    items: PayrollConceptFilterDto[] | undefined;
}

export class CreateProductStockDto implements ICreateProductStockDto {
    measureUnitId: number;
    minimunStock: number;
    maximunStock: number;
    id: string;

    constructor(data?: ICreateProductStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.measureUnitId = _data["measureUnitId"];
            this.minimunStock = _data["minimunStock"];
            this.maximunStock = _data["maximunStock"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateProductStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["measureUnitId"] = this.measureUnitId;
        data["minimunStock"] = this.minimunStock;
        data["maximunStock"] = this.maximunStock;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateProductStockDto {
        const json = this.toJSON();
        let result = new CreateProductStockDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductStockDto {
    measureUnitId: number;
    minimunStock: number;
    maximunStock: number;
    id: string;
}

export class CreateSalePriceDto implements ICreateSalePriceDto {
    currencyId: number;
    price: number;
    minAmount: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    productId: string;
    id: string;

    constructor(data?: ICreateSalePriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"];
            this.price = _data["price"];
            this.minAmount = _data["minAmount"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateSalePriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSalePriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId;
        data["price"] = this.price;
        data["minAmount"] = this.minAmount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateSalePriceDto {
        const json = this.toJSON();
        let result = new CreateSalePriceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSalePriceDto {
    currencyId: number;
    price: number;
    minAmount: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    productId: string;
    id: string;
}

export class CreateProductDto implements ICreateProductDto {
    code: string | undefined;
    name: string | undefined;
    subFamilyId: string;
    productFeatureIds: number[] | undefined;
    activeIngredientIds: string[] | undefined;
    requiresTechnicalApproval: boolean;
    productStock: CreateProductStockDto;
    salePrices: CreateSalePriceDto[] | undefined;
    tagsArray: string[] | undefined;
    purchaseNotice: string | undefined;
    saleNotice: string | undefined;
    inventoryNotice: string | undefined;
    id: string;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.subFamilyId = _data["subFamilyId"];
            if (Array.isArray(_data["productFeatureIds"])) {
                this.productFeatureIds = [] as any;
                for (let item of _data["productFeatureIds"])
                    this.productFeatureIds.push(item);
            }
            if (Array.isArray(_data["activeIngredientIds"])) {
                this.activeIngredientIds = [] as any;
                for (let item of _data["activeIngredientIds"])
                    this.activeIngredientIds.push(item);
            }
            this.requiresTechnicalApproval = _data["requiresTechnicalApproval"];
            this.productStock = _data["productStock"] ? CreateProductStockDto.fromJS(_data["productStock"]) : <any>undefined;
            if (Array.isArray(_data["salePrices"])) {
                this.salePrices = [] as any;
                for (let item of _data["salePrices"])
                    this.salePrices.push(CreateSalePriceDto.fromJS(item));
            }
            if (Array.isArray(_data["tagsArray"])) {
                this.tagsArray = [] as any;
                for (let item of _data["tagsArray"])
                    this.tagsArray.push(item);
            }
            this.purchaseNotice = _data["purchaseNotice"];
            this.saleNotice = _data["saleNotice"];
            this.inventoryNotice = _data["inventoryNotice"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["subFamilyId"] = this.subFamilyId;
        if (Array.isArray(this.productFeatureIds)) {
            data["productFeatureIds"] = [];
            for (let item of this.productFeatureIds)
                data["productFeatureIds"].push(item);
        }
        if (Array.isArray(this.activeIngredientIds)) {
            data["activeIngredientIds"] = [];
            for (let item of this.activeIngredientIds)
                data["activeIngredientIds"].push(item);
        }
        data["requiresTechnicalApproval"] = this.requiresTechnicalApproval;
        data["productStock"] = this.productStock ? this.productStock.toJSON() : <any>undefined;
        if (Array.isArray(this.salePrices)) {
            data["salePrices"] = [];
            for (let item of this.salePrices)
                data["salePrices"].push(item.toJSON());
        }
        if (Array.isArray(this.tagsArray)) {
            data["tagsArray"] = [];
            for (let item of this.tagsArray)
                data["tagsArray"].push(item);
        }
        data["purchaseNotice"] = this.purchaseNotice;
        data["saleNotice"] = this.saleNotice;
        data["inventoryNotice"] = this.inventoryNotice;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateProductDto {
        const json = this.toJSON();
        let result = new CreateProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductDto {
    code: string | undefined;
    name: string | undefined;
    subFamilyId: string;
    productFeatureIds: number[] | undefined;
    activeIngredientIds: string[] | undefined;
    requiresTechnicalApproval: boolean;
    productStock: CreateProductStockDto;
    salePrices: CreateSalePriceDto[] | undefined;
    tagsArray: string[] | undefined;
    purchaseNotice: string | undefined;
    saleNotice: string | undefined;
    inventoryNotice: string | undefined;
    id: string;
}

export class ProductFeatureDto implements IProductFeatureDto {
    name: string;
    descriptionKey: string;
    id: number;

    constructor(data?: IProductFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.descriptionKey = _data["descriptionKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["descriptionKey"] = this.descriptionKey;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductFeatureDto {
        const json = this.toJSON();
        let result = new ProductFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IProductFeatureDto {
    name: string;
    descriptionKey: string;
    id: number;
}

export class ProductActiveIngredientDto implements IProductActiveIngredientDto {
    code: string | undefined;
    name: string | undefined;
    id: string;

    constructor(data?: IProductActiveIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductActiveIngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductActiveIngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductActiveIngredientDto {
        const json = this.toJSON();
        let result = new ProductActiveIngredientDto();
        result.init(json);
        return result;
    }
}

export interface IProductActiveIngredientDto {
    code: string | undefined;
    name: string | undefined;
    id: string;
}

export class ProductStockDto implements IProductStockDto {
    measureUnitId: number;
    measureUnitName: string | undefined;
    minimunStock: number;
    maximunStock: number;
    id: string;

    constructor(data?: IProductStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.measureUnitId = _data["measureUnitId"];
            this.measureUnitName = _data["measureUnitName"];
            this.minimunStock = _data["minimunStock"];
            this.maximunStock = _data["maximunStock"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["measureUnitId"] = this.measureUnitId;
        data["measureUnitName"] = this.measureUnitName;
        data["minimunStock"] = this.minimunStock;
        data["maximunStock"] = this.maximunStock;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductStockDto {
        const json = this.toJSON();
        let result = new ProductStockDto();
        result.init(json);
        return result;
    }
}

export interface IProductStockDto {
    measureUnitId: number;
    measureUnitName: string | undefined;
    minimunStock: number;
    maximunStock: number;
    id: string;
}

export class SalePriceDto implements ISalePriceDto {
    currencyId: number;
    currencyName: string | undefined;
    price: number;
    minAmount: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    productId: string;
    id: string;

    constructor(data?: ISalePriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.price = _data["price"];
            this.minAmount = _data["minAmount"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SalePriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalePriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["price"] = this.price;
        data["minAmount"] = this.minAmount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }

    clone(): SalePriceDto {
        const json = this.toJSON();
        let result = new SalePriceDto();
        result.init(json);
        return result;
    }
}

export interface ISalePriceDto {
    currencyId: number;
    currencyName: string | undefined;
    price: number;
    minAmount: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    productId: string;
    id: string;
}

export class ProductDto implements IProductDto {
    code: string | undefined;
    name: string | undefined;
    subFamilyId: string;
    productFeatures: ProductFeatureDto[] | undefined;
    activeIngredients: ProductActiveIngredientDto[] | undefined;
    requiresTechnicalApproval: boolean;
    productStock: ProductStockDto;
    salePrices: SalePriceDto[] | undefined;
    tags: TagDto[] | undefined;
    purchaseNotice: string | undefined;
    saleNotice: string | undefined;
    inventoryNotice: string | undefined;
    tenantId: number;
    measureUnitId: number | undefined;
    id: string;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.subFamilyId = _data["subFamilyId"];
            if (Array.isArray(_data["productFeatures"])) {
                this.productFeatures = [] as any;
                for (let item of _data["productFeatures"])
                    this.productFeatures.push(ProductFeatureDto.fromJS(item));
            }
            if (Array.isArray(_data["activeIngredients"])) {
                this.activeIngredients = [] as any;
                for (let item of _data["activeIngredients"])
                    this.activeIngredients.push(ProductActiveIngredientDto.fromJS(item));
            }
            this.requiresTechnicalApproval = _data["requiresTechnicalApproval"];
            this.productStock = _data["productStock"] ? ProductStockDto.fromJS(_data["productStock"]) : <any>undefined;
            if (Array.isArray(_data["salePrices"])) {
                this.salePrices = [] as any;
                for (let item of _data["salePrices"])
                    this.salePrices.push(SalePriceDto.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.purchaseNotice = _data["purchaseNotice"];
            this.saleNotice = _data["saleNotice"];
            this.inventoryNotice = _data["inventoryNotice"];
            this.tenantId = _data["tenantId"];
            this.measureUnitId = _data["measureUnitId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["subFamilyId"] = this.subFamilyId;
        if (Array.isArray(this.productFeatures)) {
            data["productFeatures"] = [];
            for (let item of this.productFeatures)
                data["productFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.activeIngredients)) {
            data["activeIngredients"] = [];
            for (let item of this.activeIngredients)
                data["activeIngredients"].push(item.toJSON());
        }
        data["requiresTechnicalApproval"] = this.requiresTechnicalApproval;
        data["productStock"] = this.productStock ? this.productStock.toJSON() : <any>undefined;
        if (Array.isArray(this.salePrices)) {
            data["salePrices"] = [];
            for (let item of this.salePrices)
                data["salePrices"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["purchaseNotice"] = this.purchaseNotice;
        data["saleNotice"] = this.saleNotice;
        data["inventoryNotice"] = this.inventoryNotice;
        data["tenantId"] = this.tenantId;
        data["measureUnitId"] = this.measureUnitId;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductDto {
        const json = this.toJSON();
        let result = new ProductDto();
        result.init(json);
        return result;
    }
}

export interface IProductDto {
    code: string | undefined;
    name: string | undefined;
    subFamilyId: string;
    productFeatures: ProductFeatureDto[] | undefined;
    activeIngredients: ProductActiveIngredientDto[] | undefined;
    requiresTechnicalApproval: boolean;
    productStock: ProductStockDto;
    salePrices: SalePriceDto[] | undefined;
    tags: TagDto[] | undefined;
    purchaseNotice: string | undefined;
    saleNotice: string | undefined;
    inventoryNotice: string | undefined;
    tenantId: number;
    measureUnitId: number | undefined;
    id: string;
}

export class ProductDtoPagedResultDto implements IProductDtoPagedResultDto {
    totalCount: number;
    items: ProductDto[] | undefined;

    constructor(data?: IProductDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductDtoPagedResultDto {
    totalCount: number;
    items: ProductDto[] | undefined;
}

export class CreateProductCategoryDto implements ICreateProductCategoryDto {
    code: string;
    name: string;
    description: string;
    productClassificationId: number;
    id: number;

    constructor(data?: ICreateProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.productClassificationId = _data["productClassificationId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["productClassificationId"] = this.productClassificationId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateProductCategoryDto {
        const json = this.toJSON();
        let result = new CreateProductCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductCategoryDto {
    code: string;
    name: string;
    description: string;
    productClassificationId: number;
    id: number;
}

export class ProductCategoryDto implements IProductCategoryDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    productClassificationName: string | undefined;
    tenantId: number | undefined;
    id: number;

    constructor(data?: IProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.productClassificationName = _data["productClassificationName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["productClassificationName"] = this.productClassificationName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductCategoryDto {
        const json = this.toJSON();
        let result = new ProductCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IProductCategoryDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    productClassificationName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class ProductCategoryDtoPagedResultDto implements IProductCategoryDtoPagedResultDto {
    totalCount: number;
    items: ProductCategoryDto[] | undefined;

    constructor(data?: IProductCategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductCategoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductCategoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductCategoryDtoPagedResultDto {
    totalCount: number;
    items: ProductCategoryDto[] | undefined;
}

export class CreateProductCategoryHoldingDto implements ICreateProductCategoryHoldingDto {
    productCategoryId: number;
    id: string;

    constructor(data?: ICreateProductCategoryHoldingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCategoryId = _data["productCategoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateProductCategoryHoldingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryHoldingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCategoryId"] = this.productCategoryId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateProductCategoryHoldingDto {
        const json = this.toJSON();
        let result = new CreateProductCategoryHoldingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductCategoryHoldingDto {
    productCategoryId: number;
    id: string;
}

export class ProductCategoryHoldingDto implements IProductCategoryHoldingDto {
    productCategoryId: number;
    id: string;

    constructor(data?: IProductCategoryHoldingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCategoryId = _data["productCategoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductCategoryHoldingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryHoldingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCategoryId"] = this.productCategoryId;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductCategoryHoldingDto {
        const json = this.toJSON();
        let result = new ProductCategoryHoldingDto();
        result.init(json);
        return result;
    }
}

export interface IProductCategoryHoldingDto {
    productCategoryId: number;
    id: string;
}

export class ProductCategoryHoldingDtoPagedResultDto implements IProductCategoryHoldingDtoPagedResultDto {
    totalCount: number;
    items: ProductCategoryHoldingDto[] | undefined;

    constructor(data?: IProductCategoryHoldingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductCategoryHoldingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryHoldingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryHoldingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductCategoryHoldingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductCategoryHoldingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductCategoryHoldingDtoPagedResultDto {
    totalCount: number;
    items: ProductCategoryHoldingDto[] | undefined;
}

export class CreateProductClassificationTypeDto implements ICreateProductClassificationTypeDto {
    name: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: ICreateProductClassificationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateProductClassificationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductClassificationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateProductClassificationTypeDto {
        const json = this.toJSON();
        let result = new CreateProductClassificationTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductClassificationTypeDto {
    name: string | undefined;
    description: string | undefined;
    id: number;
}

export class ProductClassificationDto implements IProductClassificationDto {
    name: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IProductClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductClassificationDto {
        const json = this.toJSON();
        let result = new ProductClassificationDto();
        result.init(json);
        return result;
    }
}

export interface IProductClassificationDto {
    name: string | undefined;
    description: string | undefined;
    id: number;
}

export class ProductClassificationDtoPagedResultDto implements IProductClassificationDtoPagedResultDto {
    totalCount: number;
    items: ProductClassificationDto[] | undefined;

    constructor(data?: IProductClassificationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductClassificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductClassificationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassificationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductClassificationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductClassificationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductClassificationDtoPagedResultDto {
    totalCount: number;
    items: ProductClassificationDto[] | undefined;
}

export class CreateProductFamilyDto implements ICreateProductFamilyDto {
    name: string | undefined;
    code: string | undefined;
    productCategoryID: number;
    farmsId: string[] | undefined;
    tenantId: number | undefined;
    id: string;

    constructor(data?: ICreateProductFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.productCategoryID = _data["productCategoryID"];
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateProductFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["productCategoryID"] = this.productCategoryID;
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateProductFamilyDto {
        const json = this.toJSON();
        let result = new CreateProductFamilyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductFamilyDto {
    name: string | undefined;
    code: string | undefined;
    productCategoryID: number;
    farmsId: string[] | undefined;
    tenantId: number | undefined;
    id: string;
}

export class ProductFamilyDto implements IProductFamilyDto {
    name: string | undefined;
    code: string | undefined;
    productCategoryId: number;
    farms: FarmDto[] | undefined;
    tenantId: number | undefined;
    id: string;

    constructor(data?: IProductFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.productCategoryId = _data["productCategoryId"];
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["productCategoryId"] = this.productCategoryId;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductFamilyDto {
        const json = this.toJSON();
        let result = new ProductFamilyDto();
        result.init(json);
        return result;
    }
}

export interface IProductFamilyDto {
    name: string | undefined;
    code: string | undefined;
    productCategoryId: number;
    farms: FarmDto[] | undefined;
    tenantId: number | undefined;
    id: string;
}

export class ProductFamilyDtoPagedResultDto implements IProductFamilyDtoPagedResultDto {
    totalCount: number;
    items: ProductFamilyDto[] | undefined;

    constructor(data?: IProductFamilyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductFamilyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductFamilyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFamilyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductFamilyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductFamilyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductFamilyDtoPagedResultDto {
    totalCount: number;
    items: ProductFamilyDto[] | undefined;
}

export class SimpleCompanyDto implements ISimpleCompanyDto {
    name: string | undefined;
    code: number;
    businessName: string | undefined;
    logo: string | undefined;
    id: string;

    constructor(data?: ISimpleCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.logo = _data["logo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["logo"] = this.logo;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleCompanyDto {
        const json = this.toJSON();
        let result = new SimpleCompanyDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleCompanyDto {
    name: string | undefined;
    code: number;
    businessName: string | undefined;
    logo: string | undefined;
    id: string;
}

export class CreateProductFamilyHoldingDto implements ICreateProductFamilyHoldingDto {
    productFamilyId: string;
    id: string;

    constructor(data?: ICreateProductFamilyHoldingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productFamilyId = _data["productFamilyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateProductFamilyHoldingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductFamilyHoldingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productFamilyId"] = this.productFamilyId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateProductFamilyHoldingDto {
        const json = this.toJSON();
        let result = new CreateProductFamilyHoldingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductFamilyHoldingDto {
    productFamilyId: string;
    id: string;
}

export class ProductFamilyHoldingDto implements IProductFamilyHoldingDto {
    productFamilyId: string;
    id: string;

    constructor(data?: IProductFamilyHoldingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productFamilyId = _data["productFamilyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductFamilyHoldingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFamilyHoldingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productFamilyId"] = this.productFamilyId;
        data["id"] = this.id;
        return data;
    }

    clone(): ProductFamilyHoldingDto {
        const json = this.toJSON();
        let result = new ProductFamilyHoldingDto();
        result.init(json);
        return result;
    }
}

export interface IProductFamilyHoldingDto {
    productFamilyId: string;
    id: string;
}

export class ProductFamilyHoldingDtoPagedResultDto implements IProductFamilyHoldingDtoPagedResultDto {
    totalCount: number;
    items: ProductFamilyHoldingDto[] | undefined;

    constructor(data?: IProductFamilyHoldingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductFamilyHoldingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductFamilyHoldingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFamilyHoldingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductFamilyHoldingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductFamilyHoldingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductFamilyHoldingDtoPagedResultDto {
    totalCount: number;
    items: ProductFamilyHoldingDto[] | undefined;
}

export class CreateProductFeatureTypeDto implements ICreateProductFeatureTypeDto {
    name: string;
    descriptionKey: string;
    id: number;

    constructor(data?: ICreateProductFeatureTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.descriptionKey = _data["descriptionKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateProductFeatureTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductFeatureTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["descriptionKey"] = this.descriptionKey;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateProductFeatureTypeDto {
        const json = this.toJSON();
        let result = new CreateProductFeatureTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductFeatureTypeDto {
    name: string;
    descriptionKey: string;
    id: number;
}

export class ProductFeatureDtoPagedResultDto implements IProductFeatureDtoPagedResultDto {
    totalCount: number;
    items: ProductFeatureDto[] | undefined;

    constructor(data?: IProductFeatureDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductFeatureDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFeatureDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductFeatureDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductFeatureDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductFeatureDtoPagedResultDto {
    totalCount: number;
    items: ProductFeatureDto[] | undefined;
}

export class ProductStockDtoPagedResultDto implements IProductStockDtoPagedResultDto {
    totalCount: number;
    items: ProductStockDto[] | undefined;

    constructor(data?: IProductStockDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductStockDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductStockDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStockDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ProductStockDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductStockDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductStockDtoPagedResultDto {
    totalCount: number;
    items: ProductStockDto[] | undefined;
}

export class CreatePurchaseDocumentDetailDto implements ICreatePurchaseDocumentDetailDto {
    productId: string | undefined;
    quantity: number;
    price: number;
    productCode: string | undefined;
    productDescription: string | undefined;
    measureUnitId: number | undefined;

    constructor(data?: ICreatePurchaseDocumentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.productCode = _data["productCode"];
            this.productDescription = _data["productDescription"];
            this.measureUnitId = _data["measureUnitId"];
        }
    }

    static fromJS(data: any): CreatePurchaseDocumentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseDocumentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["productCode"] = this.productCode;
        data["productDescription"] = this.productDescription;
        data["measureUnitId"] = this.measureUnitId;
        return data;
    }

    clone(): CreatePurchaseDocumentDetailDto {
        const json = this.toJSON();
        let result = new CreatePurchaseDocumentDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePurchaseDocumentDetailDto {
    productId: string | undefined;
    quantity: number;
    price: number;
    productCode: string | undefined;
    productDescription: string | undefined;
    measureUnitId: number | undefined;
}

export class SimpleFileDto implements ISimpleFileDto {
    base64: string | undefined;

    constructor(data?: ISimpleFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64 = _data["base64"];
        }
    }

    static fromJS(data: any): SimpleFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64"] = this.base64;
        return data;
    }

    clone(): SimpleFileDto {
        const json = this.toJSON();
        let result = new SimpleFileDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleFileDto {
    base64: string | undefined;
}

export class CreateFileDetailDto implements ICreateFileDetailDto {
    name: string | undefined;
    documentTypeId: number;
    mimeType: string | undefined;
    documentFile: SimpleFileDto;

    constructor(data?: ICreateFileDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.documentTypeId = _data["documentTypeId"];
            this.mimeType = _data["mimeType"];
            this.documentFile = _data["documentFile"] ? SimpleFileDto.fromJS(_data["documentFile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateFileDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFileDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["documentTypeId"] = this.documentTypeId;
        data["mimeType"] = this.mimeType;
        data["documentFile"] = this.documentFile ? this.documentFile.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateFileDetailDto {
        const json = this.toJSON();
        let result = new CreateFileDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateFileDetailDto {
    name: string | undefined;
    documentTypeId: number;
    mimeType: string | undefined;
    documentFile: SimpleFileDto;
}

export class CreateForumDto implements ICreateForumDto {
    comment: CreateCommentDto;
    files: CreateFileDetailDto[] | undefined;

    constructor(data?: ICreateForumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"] ? CreateCommentDto.fromJS(_data["comment"]) : <any>undefined;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(CreateFileDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateForumDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateForumDto {
        const json = this.toJSON();
        let result = new CreateForumDto();
        result.init(json);
        return result;
    }
}

export interface ICreateForumDto {
    comment: CreateCommentDto;
    files: CreateFileDetailDto[] | undefined;
}

export class CreatePurchaseDocumentDto implements ICreatePurchaseDocumentDto {
    correlativeId: string;
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    purchaseDocumentDetails: CreatePurchaseDocumentDetailDto[] | undefined;
    forums: CreateForumDto[] | undefined;

    constructor(data?: ICreatePurchaseDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlativeId = _data["correlativeId"];
            this.farmId = _data["farmId"];
            this.warehouseId = _data["warehouseId"];
            this.suggestedDate = _data["suggestedDate"] ? moment(_data["suggestedDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["purchaseDocumentDetails"])) {
                this.purchaseDocumentDetails = [] as any;
                for (let item of _data["purchaseDocumentDetails"])
                    this.purchaseDocumentDetails.push(CreatePurchaseDocumentDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["forums"])) {
                this.forums = [] as any;
                for (let item of _data["forums"])
                    this.forums.push(CreateForumDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePurchaseDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlativeId"] = this.correlativeId;
        data["farmId"] = this.farmId;
        data["warehouseId"] = this.warehouseId;
        data["suggestedDate"] = this.suggestedDate ? this.suggestedDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.purchaseDocumentDetails)) {
            data["purchaseDocumentDetails"] = [];
            for (let item of this.purchaseDocumentDetails)
                data["purchaseDocumentDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.forums)) {
            data["forums"] = [];
            for (let item of this.forums)
                data["forums"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreatePurchaseDocumentDto {
        const json = this.toJSON();
        let result = new CreatePurchaseDocumentDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePurchaseDocumentDto {
    correlativeId: string;
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    purchaseDocumentDetails: CreatePurchaseDocumentDetailDto[] | undefined;
    forums: CreateForumDto[] | undefined;
}

export class FileDetailDto implements IFileDetailDto {
    name: string | undefined;
    path: string | undefined;
    documentTypeId: number;
    mimeType: string | undefined;
    documentFile: SimpleFileDto;
    id: string;

    constructor(data?: IFileDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.path = _data["path"];
            this.documentTypeId = _data["documentTypeId"];
            this.mimeType = _data["mimeType"];
            this.documentFile = _data["documentFile"] ? SimpleFileDto.fromJS(_data["documentFile"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FileDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["path"] = this.path;
        data["documentTypeId"] = this.documentTypeId;
        data["mimeType"] = this.mimeType;
        data["documentFile"] = this.documentFile ? this.documentFile.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): FileDetailDto {
        const json = this.toJSON();
        let result = new FileDetailDto();
        result.init(json);
        return result;
    }
}

export interface IFileDetailDto {
    name: string | undefined;
    path: string | undefined;
    documentTypeId: number;
    mimeType: string | undefined;
    documentFile: SimpleFileDto;
    id: string;
}

export class SimpleForumDto implements ISimpleForumDto {
    commentId: string | undefined;
    files: FileDetailDto[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ISimpleForumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(FileDetailDto.fromJS(item));
            }
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleForumDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleForumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleForumDto {
        const json = this.toJSON();
        let result = new SimpleForumDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleForumDto {
    commentId: string | undefined;
    files: FileDetailDto[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class SimplePurchaseDocumentLogDto implements ISimplePurchaseDocumentLogDto {
    actionType: ActionTypeDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ISimplePurchaseDocumentLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionType = _data["actionType"] ? ActionTypeDto.fromJS(_data["actionType"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimplePurchaseDocumentLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePurchaseDocumentLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this.actionType ? this.actionType.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): SimplePurchaseDocumentLogDto {
        const json = this.toJSON();
        let result = new SimplePurchaseDocumentLogDto();
        result.init(json);
        return result;
    }
}

export interface ISimplePurchaseDocumentLogDto {
    actionType: ActionTypeDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class SimplePurchaseDocumentDetailDto implements ISimplePurchaseDocumentDetailDto {
    productId: string | undefined;
    quantity: number;
    price: number;
    productCode: string | undefined;
    productDescription: string | undefined;
    measurementUnitId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ISimplePurchaseDocumentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.productCode = _data["productCode"];
            this.productDescription = _data["productDescription"];
            this.measurementUnitId = _data["measurementUnitId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimplePurchaseDocumentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePurchaseDocumentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["productCode"] = this.productCode;
        data["productDescription"] = this.productDescription;
        data["measurementUnitId"] = this.measurementUnitId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): SimplePurchaseDocumentDetailDto {
        const json = this.toJSON();
        let result = new SimplePurchaseDocumentDetailDto();
        result.init(json);
        return result;
    }
}

export interface ISimplePurchaseDocumentDetailDto {
    productId: string | undefined;
    quantity: number;
    price: number;
    productCode: string | undefined;
    productDescription: string | undefined;
    measurementUnitId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class SupplierWayPayDto implements ISupplierWayPayDto {
    name: string | undefined;
    localizationKey: string | undefined;
    id: number;

    constructor(data?: ISupplierWayPayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.localizationKey = _data["localizationKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SupplierWayPayDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierWayPayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["localizationKey"] = this.localizationKey;
        data["id"] = this.id;
        return data;
    }

    clone(): SupplierWayPayDto {
        const json = this.toJSON();
        let result = new SupplierWayPayDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierWayPayDto {
    name: string | undefined;
    localizationKey: string | undefined;
    id: number;
}

export class SupplierDto implements ISupplierDto {
    rut: string;
    name: string;
    businessName: string;
    code: string;
    companies: SimpleCompanyDto[] | undefined;
    currencyId: number;
    currencyName: string | undefined;
    isProvider: boolean;
    isProducer: boolean;
    isRelatedCompany: boolean;
    isActive: boolean;
    address: AddressDto;
    phone: string | undefined;
    webSite: string | undefined;
    email: string;
    wayPay: SupplierWayPayDto;
    termDays: number | undefined;
    noticeTypeId: number | undefined;
    noticeMessage: string | undefined;
    tags: TagDto[] | undefined;
    tenantId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ISupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rut = _data["rut"];
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.code = _data["code"];
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies.push(SimpleCompanyDto.fromJS(item));
            }
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.isProvider = _data["isProvider"];
            this.isProducer = _data["isProducer"];
            this.isRelatedCompany = _data["isRelatedCompany"];
            this.isActive = _data["isActive"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.phone = _data["phone"];
            this.webSite = _data["webSite"];
            this.email = _data["email"];
            this.wayPay = _data["wayPay"] ? SupplierWayPayDto.fromJS(_data["wayPay"]) : <any>undefined;
            this.termDays = _data["termDays"];
            this.noticeTypeId = _data["noticeTypeId"];
            this.noticeMessage = _data["noticeMessage"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rut"] = this.rut;
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["code"] = this.code;
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item.toJSON());
        }
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["isProvider"] = this.isProvider;
        data["isProducer"] = this.isProducer;
        data["isRelatedCompany"] = this.isRelatedCompany;
        data["isActive"] = this.isActive;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["webSite"] = this.webSite;
        data["email"] = this.email;
        data["wayPay"] = this.wayPay ? this.wayPay.toJSON() : <any>undefined;
        data["termDays"] = this.termDays;
        data["noticeTypeId"] = this.noticeTypeId;
        data["noticeMessage"] = this.noticeMessage;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): SupplierDto {
        const json = this.toJSON();
        let result = new SupplierDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierDto {
    rut: string;
    name: string;
    businessName: string;
    code: string;
    companies: SimpleCompanyDto[] | undefined;
    currencyId: number;
    currencyName: string | undefined;
    isProvider: boolean;
    isProducer: boolean;
    isRelatedCompany: boolean;
    isActive: boolean;
    address: AddressDto;
    phone: string | undefined;
    webSite: string | undefined;
    email: string;
    wayPay: SupplierWayPayDto;
    termDays: number | undefined;
    noticeTypeId: number | undefined;
    noticeMessage: string | undefined;
    tags: TagDto[] | undefined;
    tenantId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class PurchaseDocumentDto implements IPurchaseDocumentDto {
    correlativeId: string;
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    forums: SimpleForumDto[] | undefined;
    purchaseDocumentLogs: SimplePurchaseDocumentLogDto[] | undefined;
    purchaseDocumentDetails: SimplePurchaseDocumentDetailDto[] | undefined;
    documentStatuses: DocumentStatusDto[] | undefined;
    suppliers: SupplierDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IPurchaseDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlativeId = _data["correlativeId"];
            this.farmId = _data["farmId"];
            this.warehouseId = _data["warehouseId"];
            this.suggestedDate = _data["suggestedDate"] ? moment(_data["suggestedDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["forums"])) {
                this.forums = [] as any;
                for (let item of _data["forums"])
                    this.forums.push(SimpleForumDto.fromJS(item));
            }
            if (Array.isArray(_data["purchaseDocumentLogs"])) {
                this.purchaseDocumentLogs = [] as any;
                for (let item of _data["purchaseDocumentLogs"])
                    this.purchaseDocumentLogs.push(SimplePurchaseDocumentLogDto.fromJS(item));
            }
            if (Array.isArray(_data["purchaseDocumentDetails"])) {
                this.purchaseDocumentDetails = [] as any;
                for (let item of _data["purchaseDocumentDetails"])
                    this.purchaseDocumentDetails.push(SimplePurchaseDocumentDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["documentStatuses"])) {
                this.documentStatuses = [] as any;
                for (let item of _data["documentStatuses"])
                    this.documentStatuses.push(DocumentStatusDto.fromJS(item));
            }
            if (Array.isArray(_data["suppliers"])) {
                this.suppliers = [] as any;
                for (let item of _data["suppliers"])
                    this.suppliers.push(SupplierDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlativeId"] = this.correlativeId;
        data["farmId"] = this.farmId;
        data["warehouseId"] = this.warehouseId;
        data["suggestedDate"] = this.suggestedDate ? this.suggestedDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.forums)) {
            data["forums"] = [];
            for (let item of this.forums)
                data["forums"].push(item.toJSON());
        }
        if (Array.isArray(this.purchaseDocumentLogs)) {
            data["purchaseDocumentLogs"] = [];
            for (let item of this.purchaseDocumentLogs)
                data["purchaseDocumentLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.purchaseDocumentDetails)) {
            data["purchaseDocumentDetails"] = [];
            for (let item of this.purchaseDocumentDetails)
                data["purchaseDocumentDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.documentStatuses)) {
            data["documentStatuses"] = [];
            for (let item of this.documentStatuses)
                data["documentStatuses"].push(item.toJSON());
        }
        if (Array.isArray(this.suppliers)) {
            data["suppliers"] = [];
            for (let item of this.suppliers)
                data["suppliers"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): PurchaseDocumentDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentDto {
    correlativeId: string;
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    forums: SimpleForumDto[] | undefined;
    purchaseDocumentLogs: SimplePurchaseDocumentLogDto[] | undefined;
    purchaseDocumentDetails: SimplePurchaseDocumentDetailDto[] | undefined;
    documentStatuses: DocumentStatusDto[] | undefined;
    suppliers: SupplierDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdatePurchaseDocumentDto implements IUpdatePurchaseDocumentDto {
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.farmId = _data["farmId"];
            this.warehouseId = _data["warehouseId"];
            this.suggestedDate = _data["suggestedDate"] ? moment(_data["suggestedDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["farmId"] = this.farmId;
        data["warehouseId"] = this.warehouseId;
        data["suggestedDate"] = this.suggestedDate ? this.suggestedDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentDto {
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    id: string;
}

export class ReopenDocumentStatusDto implements IReopenDocumentStatusDto {
    comment: string | undefined;
    id: string;

    constructor(data?: IReopenDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReopenDocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReopenDocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data;
    }

    clone(): ReopenDocumentStatusDto {
        const json = this.toJSON();
        let result = new ReopenDocumentStatusDto();
        result.init(json);
        return result;
    }
}

export interface IReopenDocumentStatusDto {
    comment: string | undefined;
    id: string;
}

export class UpdateLocalDocumentStatus implements IUpdateLocalDocumentStatus {
    documentStatus: CreateDocumentStatusDto;
    id: string;

    constructor(data?: IUpdateLocalDocumentStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentStatus = _data["documentStatus"] ? CreateDocumentStatusDto.fromJS(_data["documentStatus"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateLocalDocumentStatus {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLocalDocumentStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentStatus"] = this.documentStatus ? this.documentStatus.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateLocalDocumentStatus {
        const json = this.toJSON();
        let result = new UpdateLocalDocumentStatus();
        result.init(json);
        return result;
    }
}

export interface IUpdateLocalDocumentStatus {
    documentStatus: CreateDocumentStatusDto;
    id: string;
}

export class UpdateForumDto implements IUpdateForumDto {
    commentId: string | undefined;
    files: FileDetailDto[] | undefined;
    id: string;

    constructor(data?: IUpdateForumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(FileDetailDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateForumDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateForumDto {
        const json = this.toJSON();
        let result = new UpdateForumDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateForumDto {
    commentId: string | undefined;
    files: FileDetailDto[] | undefined;
    id: string;
}

export class UpdatePurchaseDocumentForumDto implements IUpdatePurchaseDocumentForumDto {
    forums: UpdateForumDto[] | undefined;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentForumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["forums"])) {
                this.forums = [] as any;
                for (let item of _data["forums"])
                    this.forums.push(UpdateForumDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentForumDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentForumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.forums)) {
            data["forums"] = [];
            for (let item of this.forums)
                data["forums"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentForumDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentForumDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentForumDto {
    forums: UpdateForumDto[] | undefined;
    id: string;
}

export class UpdatePurchaseDocumentDetailDto implements IUpdatePurchaseDocumentDetailDto {
    productId: string | undefined;
    quantity: number;
    price: number;
    productCode: string | undefined;
    productDescription: string | undefined;
    measureUnit: number | undefined;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.productCode = _data["productCode"];
            this.productDescription = _data["productDescription"];
            this.measureUnit = _data["measureUnit"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["productCode"] = this.productCode;
        data["productDescription"] = this.productDescription;
        data["measureUnit"] = this.measureUnit;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentDetailDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentDetailDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentDetailDto {
    productId: string | undefined;
    quantity: number;
    price: number;
    productCode: string | undefined;
    productDescription: string | undefined;
    measureUnit: number | undefined;
    id: string;
}

export class UpdatePurchaseDocumentProductDto implements IUpdatePurchaseDocumentProductDto {
    documentProduct: UpdatePurchaseDocumentDetailDto[] | undefined;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["documentProduct"])) {
                this.documentProduct = [] as any;
                for (let item of _data["documentProduct"])
                    this.documentProduct.push(UpdatePurchaseDocumentDetailDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.documentProduct)) {
            data["documentProduct"] = [];
            for (let item of this.documentProduct)
                data["documentProduct"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentProductDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentProductDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentProductDto {
    documentProduct: UpdatePurchaseDocumentDetailDto[] | undefined;
    id: string;
}

export class UpdatePurchaseDocumentSingleForumDto implements IUpdatePurchaseDocumentSingleForumDto {
    forum: UpdateForumDto;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentSingleForumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.forum = _data["forum"] ? UpdateForumDto.fromJS(_data["forum"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentSingleForumDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentSingleForumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forum"] = this.forum ? this.forum.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentSingleForumDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentSingleForumDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentSingleForumDto {
    forum: UpdateForumDto;
    id: string;
}

export class UpdatePurchaseDocumentSingleProductDto implements IUpdatePurchaseDocumentSingleProductDto {
    documentProduct: UpdatePurchaseDocumentDetailDto;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentSingleProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentProduct = _data["documentProduct"] ? UpdatePurchaseDocumentDetailDto.fromJS(_data["documentProduct"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentSingleProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentSingleProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentProduct"] = this.documentProduct ? this.documentProduct.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentSingleProductDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentSingleProductDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentSingleProductDto {
    documentProduct: UpdatePurchaseDocumentDetailDto;
    id: string;
}

export class PurchaseDocumentForumDto implements IPurchaseDocumentForumDto {
    forums: SimpleForumDto[] | undefined;
    id: string;

    constructor(data?: IPurchaseDocumentForumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["forums"])) {
                this.forums = [] as any;
                for (let item of _data["forums"])
                    this.forums.push(SimpleForumDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseDocumentForumDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentForumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.forums)) {
            data["forums"] = [];
            for (let item of this.forums)
                data["forums"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): PurchaseDocumentForumDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentForumDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentForumDto {
    forums: SimpleForumDto[] | undefined;
    id: string;
}

export class PurchaseDocumentProductDto implements IPurchaseDocumentProductDto {
    purchaseDocumentDetails: SimplePurchaseDocumentDetailDto[] | undefined;
    id: string;

    constructor(data?: IPurchaseDocumentProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["purchaseDocumentDetails"])) {
                this.purchaseDocumentDetails = [] as any;
                for (let item of _data["purchaseDocumentDetails"])
                    this.purchaseDocumentDetails.push(SimplePurchaseDocumentDetailDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseDocumentProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.purchaseDocumentDetails)) {
            data["purchaseDocumentDetails"] = [];
            for (let item of this.purchaseDocumentDetails)
                data["purchaseDocumentDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): PurchaseDocumentProductDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentProductDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentProductDto {
    purchaseDocumentDetails: SimplePurchaseDocumentDetailDto[] | undefined;
    id: string;
}

export class PurchaseDocumentStatusDto implements IPurchaseDocumentStatusDto {
    documentStatuses: DocumentStatusDto[] | undefined;
    id: string;

    constructor(data?: IPurchaseDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["documentStatuses"])) {
                this.documentStatuses = [] as any;
                for (let item of _data["documentStatuses"])
                    this.documentStatuses.push(DocumentStatusDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseDocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.documentStatuses)) {
            data["documentStatuses"] = [];
            for (let item of this.documentStatuses)
                data["documentStatuses"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): PurchaseDocumentStatusDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentStatusDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentStatusDto {
    documentStatuses: DocumentStatusDto[] | undefined;
    id: string;
}

export class PurchaseDocumentDtoPagedResultDto implements IPurchaseDocumentDtoPagedResultDto {
    totalCount: number;
    items: PurchaseDocumentDto[] | undefined;

    constructor(data?: IPurchaseDocumentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PurchaseDocumentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseDocumentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PurchaseDocumentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentDtoPagedResultDto {
    totalCount: number;
    items: PurchaseDocumentDto[] | undefined;
}

export class CreatePurchaseDocumentLogDetailDto implements ICreatePurchaseDocumentLogDetailDto {
    purchaseDocumentId: string;
    actionTypeId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ICreatePurchaseDocumentLogDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseDocumentId = _data["purchaseDocumentId"];
            this.actionTypeId = _data["actionTypeId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreatePurchaseDocumentLogDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseDocumentLogDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseDocumentId"] = this.purchaseDocumentId;
        data["actionTypeId"] = this.actionTypeId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreatePurchaseDocumentLogDetailDto {
        const json = this.toJSON();
        let result = new CreatePurchaseDocumentLogDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePurchaseDocumentLogDetailDto {
    purchaseDocumentId: string;
    actionTypeId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class PurchaseDocumentLogDetailDto implements IPurchaseDocumentLogDetailDto {
    purchaseDocumentId: string;
    actionType: ActionTypeDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IPurchaseDocumentLogDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseDocumentId = _data["purchaseDocumentId"];
            this.actionType = _data["actionType"] ? ActionTypeDto.fromJS(_data["actionType"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseDocumentLogDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentLogDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseDocumentId"] = this.purchaseDocumentId;
        data["actionType"] = this.actionType ? this.actionType.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): PurchaseDocumentLogDetailDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentLogDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentLogDetailDto {
    purchaseDocumentId: string;
    actionType: ActionTypeDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdatePurchaseDocumentLogDetailDto implements IUpdatePurchaseDocumentLogDetailDto {
    purchaseDocumentId: string;
    actionTypeId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentLogDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseDocumentId = _data["purchaseDocumentId"];
            this.actionTypeId = _data["actionTypeId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentLogDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentLogDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseDocumentId"] = this.purchaseDocumentId;
        data["actionTypeId"] = this.actionTypeId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentLogDetailDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentLogDetailDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentLogDetailDto {
    purchaseDocumentId: string;
    actionTypeId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class PurchaseDocumentLogDetailDtoPagedResultDto implements IPurchaseDocumentLogDetailDtoPagedResultDto {
    totalCount: number;
    items: PurchaseDocumentLogDetailDto[] | undefined;

    constructor(data?: IPurchaseDocumentLogDetailDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PurchaseDocumentLogDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseDocumentLogDetailDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentLogDetailDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PurchaseDocumentLogDetailDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentLogDetailDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentLogDetailDtoPagedResultDto {
    totalCount: number;
    items: PurchaseDocumentLogDetailDto[] | undefined;
}

export class CreatePurchaseDocumentQuoteDto implements ICreatePurchaseDocumentQuoteDto {
    correlativeId: string;
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    purchaseDocumentDetails: CreatePurchaseDocumentDetailDto[] | undefined;
    forums: CreateForumDto[] | undefined;
    suppliersId: string[] | undefined;

    constructor(data?: ICreatePurchaseDocumentQuoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlativeId = _data["correlativeId"];
            this.farmId = _data["farmId"];
            this.warehouseId = _data["warehouseId"];
            this.suggestedDate = _data["suggestedDate"] ? moment(_data["suggestedDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["purchaseDocumentDetails"])) {
                this.purchaseDocumentDetails = [] as any;
                for (let item of _data["purchaseDocumentDetails"])
                    this.purchaseDocumentDetails.push(CreatePurchaseDocumentDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["forums"])) {
                this.forums = [] as any;
                for (let item of _data["forums"])
                    this.forums.push(CreateForumDto.fromJS(item));
            }
            if (Array.isArray(_data["suppliersId"])) {
                this.suppliersId = [] as any;
                for (let item of _data["suppliersId"])
                    this.suppliersId.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePurchaseDocumentQuoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseDocumentQuoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlativeId"] = this.correlativeId;
        data["farmId"] = this.farmId;
        data["warehouseId"] = this.warehouseId;
        data["suggestedDate"] = this.suggestedDate ? this.suggestedDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.purchaseDocumentDetails)) {
            data["purchaseDocumentDetails"] = [];
            for (let item of this.purchaseDocumentDetails)
                data["purchaseDocumentDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.forums)) {
            data["forums"] = [];
            for (let item of this.forums)
                data["forums"].push(item.toJSON());
        }
        if (Array.isArray(this.suppliersId)) {
            data["suppliersId"] = [];
            for (let item of this.suppliersId)
                data["suppliersId"].push(item);
        }
        return data;
    }

    clone(): CreatePurchaseDocumentQuoteDto {
        const json = this.toJSON();
        let result = new CreatePurchaseDocumentQuoteDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePurchaseDocumentQuoteDto {
    correlativeId: string;
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    purchaseDocumentDetails: CreatePurchaseDocumentDetailDto[] | undefined;
    forums: CreateForumDto[] | undefined;
    suppliersId: string[] | undefined;
}

export class PurchaseDocumentQuoteDto implements IPurchaseDocumentQuoteDto {
    correlativeId: string;
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    forums: SimpleForumDto[] | undefined;
    purchaseDocumentLogs: SimplePurchaseDocumentLogDto[] | undefined;
    purchaseDocumentDetails: SimplePurchaseDocumentDetailDto[] | undefined;
    documentStatuses: DocumentStatusDto[] | undefined;
    suppliers: SupplierDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IPurchaseDocumentQuoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlativeId = _data["correlativeId"];
            this.farmId = _data["farmId"];
            this.warehouseId = _data["warehouseId"];
            this.suggestedDate = _data["suggestedDate"] ? moment(_data["suggestedDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["forums"])) {
                this.forums = [] as any;
                for (let item of _data["forums"])
                    this.forums.push(SimpleForumDto.fromJS(item));
            }
            if (Array.isArray(_data["purchaseDocumentLogs"])) {
                this.purchaseDocumentLogs = [] as any;
                for (let item of _data["purchaseDocumentLogs"])
                    this.purchaseDocumentLogs.push(SimplePurchaseDocumentLogDto.fromJS(item));
            }
            if (Array.isArray(_data["purchaseDocumentDetails"])) {
                this.purchaseDocumentDetails = [] as any;
                for (let item of _data["purchaseDocumentDetails"])
                    this.purchaseDocumentDetails.push(SimplePurchaseDocumentDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["documentStatuses"])) {
                this.documentStatuses = [] as any;
                for (let item of _data["documentStatuses"])
                    this.documentStatuses.push(DocumentStatusDto.fromJS(item));
            }
            if (Array.isArray(_data["suppliers"])) {
                this.suppliers = [] as any;
                for (let item of _data["suppliers"])
                    this.suppliers.push(SupplierDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseDocumentQuoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentQuoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlativeId"] = this.correlativeId;
        data["farmId"] = this.farmId;
        data["warehouseId"] = this.warehouseId;
        data["suggestedDate"] = this.suggestedDate ? this.suggestedDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.forums)) {
            data["forums"] = [];
            for (let item of this.forums)
                data["forums"].push(item.toJSON());
        }
        if (Array.isArray(this.purchaseDocumentLogs)) {
            data["purchaseDocumentLogs"] = [];
            for (let item of this.purchaseDocumentLogs)
                data["purchaseDocumentLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.purchaseDocumentDetails)) {
            data["purchaseDocumentDetails"] = [];
            for (let item of this.purchaseDocumentDetails)
                data["purchaseDocumentDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.documentStatuses)) {
            data["documentStatuses"] = [];
            for (let item of this.documentStatuses)
                data["documentStatuses"].push(item.toJSON());
        }
        if (Array.isArray(this.suppliers)) {
            data["suppliers"] = [];
            for (let item of this.suppliers)
                data["suppliers"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): PurchaseDocumentQuoteDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentQuoteDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentQuoteDto {
    correlativeId: string;
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    forums: SimpleForumDto[] | undefined;
    purchaseDocumentLogs: SimplePurchaseDocumentLogDto[] | undefined;
    purchaseDocumentDetails: SimplePurchaseDocumentDetailDto[] | undefined;
    documentStatuses: DocumentStatusDto[] | undefined;
    suppliers: SupplierDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdatePurchaseDocumentQuoteDto implements IUpdatePurchaseDocumentQuoteDto {
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentQuoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.farmId = _data["farmId"];
            this.warehouseId = _data["warehouseId"];
            this.suggestedDate = _data["suggestedDate"] ? moment(_data["suggestedDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentQuoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentQuoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["farmId"] = this.farmId;
        data["warehouseId"] = this.warehouseId;
        data["suggestedDate"] = this.suggestedDate ? this.suggestedDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentQuoteDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentQuoteDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentQuoteDto {
    farmId: string;
    warehouseId: string;
    suggestedDate: moment.Moment;
    description: string | undefined;
    id: string;
}

export class UpdatePurchaseDocumentQuoteSuppliersDto implements IUpdatePurchaseDocumentQuoteSuppliersDto {
    suppliersId: string[] | undefined;
    id: string;

    constructor(data?: IUpdatePurchaseDocumentQuoteSuppliersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["suppliersId"])) {
                this.suppliersId = [] as any;
                for (let item of _data["suppliersId"])
                    this.suppliersId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePurchaseDocumentQuoteSuppliersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseDocumentQuoteSuppliersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.suppliersId)) {
            data["suppliersId"] = [];
            for (let item of this.suppliersId)
                data["suppliersId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePurchaseDocumentQuoteSuppliersDto {
        const json = this.toJSON();
        let result = new UpdatePurchaseDocumentQuoteSuppliersDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePurchaseDocumentQuoteSuppliersDto {
    suppliersId: string[] | undefined;
    id: string;
}

export class PurchaseDocumentQuoteDtoPagedResultDto implements IPurchaseDocumentQuoteDtoPagedResultDto {
    totalCount: number;
    items: PurchaseDocumentQuoteDto[] | undefined;

    constructor(data?: IPurchaseDocumentQuoteDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PurchaseDocumentQuoteDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseDocumentQuoteDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseDocumentQuoteDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PurchaseDocumentQuoteDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PurchaseDocumentQuoteDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseDocumentQuoteDtoPagedResultDto {
    totalCount: number;
    items: PurchaseDocumentQuoteDto[] | undefined;
}

export class CreateRelationshipDto implements ICreateRelationshipDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateRelationshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateRelationshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRelationshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateRelationshipDto {
        const json = this.toJSON();
        let result = new CreateRelationshipDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRelationshipDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
}

export class UpdateRelationshipDto implements IUpdateRelationshipDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateRelationshipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRelationshipDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRelationshipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateRelationshipDto {
        const json = this.toJSON();
        let result = new UpdateRelationshipDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateRelationshipDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class RelationshipDtoPagedResultDto implements IRelationshipDtoPagedResultDto {
    totalCount: number;
    items: RelationshipDto[] | undefined;

    constructor(data?: IRelationshipDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RelationshipDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RelationshipDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelationshipDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RelationshipDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RelationshipDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRelationshipDtoPagedResultDto {
    totalCount: number;
    items: RelationshipDto[] | undefined;
}

export class RetirementTypeDto implements IRetirementTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IRetirementTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RetirementTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): RetirementTypeDto {
        const json = this.toJSON();
        let result = new RetirementTypeDto();
        result.init(json);
        return result;
    }
}

export interface IRetirementTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class RetirementInstitutionDto implements IRetirementInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IRetirementInstitutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RetirementInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): RetirementInstitutionDto {
        const json = this.toJSON();
        let result = new RetirementInstitutionDto();
        result.init(json);
        return result;
    }
}

export interface IRetirementInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class RetirementInfoDto implements IRetirementInfoDto {
    pensioner: boolean;
    retirementType: RetirementTypeDto;
    retirementInstitution: RetirementInstitutionDto;
    heavyweightWorkType: HeavyweightWorkTypeDto;
    retirement: boolean;
    id: string;

    constructor(data?: IRetirementInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pensioner = _data["pensioner"];
            this.retirementType = _data["retirementType"] ? RetirementTypeDto.fromJS(_data["retirementType"]) : <any>undefined;
            this.retirementInstitution = _data["retirementInstitution"] ? RetirementInstitutionDto.fromJS(_data["retirementInstitution"]) : <any>undefined;
            this.heavyweightWorkType = _data["heavyweightWorkType"] ? HeavyweightWorkTypeDto.fromJS(_data["heavyweightWorkType"]) : <any>undefined;
            this.retirement = _data["retirement"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RetirementInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pensioner"] = this.pensioner;
        data["retirementType"] = this.retirementType ? this.retirementType.toJSON() : <any>undefined;
        data["retirementInstitution"] = this.retirementInstitution ? this.retirementInstitution.toJSON() : <any>undefined;
        data["heavyweightWorkType"] = this.heavyweightWorkType ? this.heavyweightWorkType.toJSON() : <any>undefined;
        data["retirement"] = this.retirement;
        data["id"] = this.id;
        return data;
    }

    clone(): RetirementInfoDto {
        const json = this.toJSON();
        let result = new RetirementInfoDto();
        result.init(json);
        return result;
    }
}

export interface IRetirementInfoDto {
    pensioner: boolean;
    retirementType: RetirementTypeDto;
    retirementInstitution: RetirementInstitutionDto;
    heavyweightWorkType: HeavyweightWorkTypeDto;
    retirement: boolean;
    id: string;
}

export class RetirementInfoDtoPagedResultDto implements IRetirementInfoDtoPagedResultDto {
    totalCount: number;
    items: RetirementInfoDto[] | undefined;

    constructor(data?: IRetirementInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RetirementInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RetirementInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RetirementInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RetirementInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRetirementInfoDtoPagedResultDto {
    totalCount: number;
    items: RetirementInfoDto[] | undefined;
}

export class CreateRetirementInfoDto implements ICreateRetirementInfoDto {
    pensioner: boolean;
    retirementTypeId: number | undefined;
    retirementInstitutionId: number | undefined;
    heavyweightWorkTypeId: number | undefined;
    retirement: boolean;

    constructor(data?: ICreateRetirementInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pensioner = _data["pensioner"];
            this.retirementTypeId = _data["retirementTypeId"];
            this.retirementInstitutionId = _data["retirementInstitutionId"];
            this.heavyweightWorkTypeId = _data["heavyweightWorkTypeId"];
            this.retirement = _data["retirement"];
        }
    }

    static fromJS(data: any): CreateRetirementInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRetirementInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pensioner"] = this.pensioner;
        data["retirementTypeId"] = this.retirementTypeId;
        data["retirementInstitutionId"] = this.retirementInstitutionId;
        data["heavyweightWorkTypeId"] = this.heavyweightWorkTypeId;
        data["retirement"] = this.retirement;
        return data;
    }

    clone(): CreateRetirementInfoDto {
        const json = this.toJSON();
        let result = new CreateRetirementInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRetirementInfoDto {
    pensioner: boolean;
    retirementTypeId: number | undefined;
    retirementInstitutionId: number | undefined;
    heavyweightWorkTypeId: number | undefined;
    retirement: boolean;
}

export class UpdateRetirementInfoDto implements IUpdateRetirementInfoDto {
    pensioner: boolean;
    retirementTypeId: number | undefined;
    retirementInstitutionId: number | undefined;
    heavyweightWorkTypeId: number | undefined;
    retirement: boolean;
    id: string;

    constructor(data?: IUpdateRetirementInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pensioner = _data["pensioner"];
            this.retirementTypeId = _data["retirementTypeId"];
            this.retirementInstitutionId = _data["retirementInstitutionId"];
            this.heavyweightWorkTypeId = _data["heavyweightWorkTypeId"];
            this.retirement = _data["retirement"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRetirementInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRetirementInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pensioner"] = this.pensioner;
        data["retirementTypeId"] = this.retirementTypeId;
        data["retirementInstitutionId"] = this.retirementInstitutionId;
        data["heavyweightWorkTypeId"] = this.heavyweightWorkTypeId;
        data["retirement"] = this.retirement;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateRetirementInfoDto {
        const json = this.toJSON();
        let result = new UpdateRetirementInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateRetirementInfoDto {
    pensioner: boolean;
    retirementTypeId: number | undefined;
    retirementInstitutionId: number | undefined;
    heavyweightWorkTypeId: number | undefined;
    retirement: boolean;
    id: string;
}

export class CreateRetirementInstitutionDto implements ICreateRetirementInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateRetirementInstitutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateRetirementInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRetirementInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateRetirementInstitutionDto {
        const json = this.toJSON();
        let result = new CreateRetirementInstitutionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRetirementInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
}

export class UpdateRetirementInstitutionDto implements IUpdateRetirementInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateRetirementInstitutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRetirementInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRetirementInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateRetirementInstitutionDto {
        const json = this.toJSON();
        let result = new UpdateRetirementInstitutionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateRetirementInstitutionDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class RetirementInstitutionDtoPagedResultDto implements IRetirementInstitutionDtoPagedResultDto {
    totalCount: number;
    items: RetirementInstitutionDto[] | undefined;

    constructor(data?: IRetirementInstitutionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RetirementInstitutionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RetirementInstitutionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementInstitutionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RetirementInstitutionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RetirementInstitutionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRetirementInstitutionDtoPagedResultDto {
    totalCount: number;
    items: RetirementInstitutionDto[] | undefined;
}

export class RetirementRecordInfoDto implements IRetirementRecordInfoDto {
    date: moment.Moment | undefined;
    yearGap: number | undefined;
    monthGap: number | undefined;
    id: string;

    constructor(data?: IRetirementRecordInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.yearGap = _data["yearGap"];
            this.monthGap = _data["monthGap"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RetirementRecordInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementRecordInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["yearGap"] = this.yearGap;
        data["monthGap"] = this.monthGap;
        data["id"] = this.id;
        return data;
    }

    clone(): RetirementRecordInfoDto {
        const json = this.toJSON();
        let result = new RetirementRecordInfoDto();
        result.init(json);
        return result;
    }
}

export interface IRetirementRecordInfoDto {
    date: moment.Moment | undefined;
    yearGap: number | undefined;
    monthGap: number | undefined;
    id: string;
}

export class RetirementRecordInfoDtoPagedResultDto implements IRetirementRecordInfoDtoPagedResultDto {
    totalCount: number;
    items: RetirementRecordInfoDto[] | undefined;

    constructor(data?: IRetirementRecordInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RetirementRecordInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RetirementRecordInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementRecordInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RetirementRecordInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RetirementRecordInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRetirementRecordInfoDtoPagedResultDto {
    totalCount: number;
    items: RetirementRecordInfoDto[] | undefined;
}

export class CreateRetirementRecordInfoDto implements ICreateRetirementRecordInfoDto {
    date: moment.Moment | undefined;
    yearGap: number | undefined;
    monthGap: number | undefined;

    constructor(data?: ICreateRetirementRecordInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.yearGap = _data["yearGap"];
            this.monthGap = _data["monthGap"];
        }
    }

    static fromJS(data: any): CreateRetirementRecordInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRetirementRecordInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["yearGap"] = this.yearGap;
        data["monthGap"] = this.monthGap;
        return data;
    }

    clone(): CreateRetirementRecordInfoDto {
        const json = this.toJSON();
        let result = new CreateRetirementRecordInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRetirementRecordInfoDto {
    date: moment.Moment | undefined;
    yearGap: number | undefined;
    monthGap: number | undefined;
}

export class UpdateRetirementRecordInfoDto implements IUpdateRetirementRecordInfoDto {
    date: moment.Moment | undefined;
    yearGap: number | undefined;
    monthGap: number | undefined;
    id: string;

    constructor(data?: IUpdateRetirementRecordInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.yearGap = _data["yearGap"];
            this.monthGap = _data["monthGap"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRetirementRecordInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRetirementRecordInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["yearGap"] = this.yearGap;
        data["monthGap"] = this.monthGap;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateRetirementRecordInfoDto {
        const json = this.toJSON();
        let result = new UpdateRetirementRecordInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateRetirementRecordInfoDto {
    date: moment.Moment | undefined;
    yearGap: number | undefined;
    monthGap: number | undefined;
    id: string;
}

export class CreateRetirementTypeDto implements ICreateRetirementTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateRetirementTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateRetirementTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRetirementTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateRetirementTypeDto {
        const json = this.toJSON();
        let result = new CreateRetirementTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRetirementTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
}

export class UpdateRetirementTypeDto implements IUpdateRetirementTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateRetirementTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRetirementTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRetirementTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateRetirementTypeDto {
        const json = this.toJSON();
        let result = new UpdateRetirementTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateRetirementTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
    id: number;
}

export class RetirementTypeDtoPagedResultDto implements IRetirementTypeDtoPagedResultDto {
    totalCount: number;
    items: RetirementTypeDto[] | undefined;

    constructor(data?: IRetirementTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RetirementTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RetirementTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetirementTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RetirementTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RetirementTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRetirementTypeDtoPagedResultDto {
    totalCount: number;
    items: RetirementTypeDto[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    mainProductId: number;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.mainProductId = _data["mainProductId"];
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["mainProductId"] = this.mainProductId;
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    mainProductId: number;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    mainProduct: MainProductDto;
    mainProductId: number | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.mainProduct = _data["mainProduct"] ? MainProductDto.fromJS(_data["mainProduct"]) : <any>undefined;
            this.mainProductId = _data["mainProductId"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["mainProduct"] = this.mainProduct ? this.mainProduct.toJSON() : <any>undefined;
        data["mainProductId"] = this.mainProductId;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    mainProduct: MainProductDto;
    mainProductId: number | undefined;
    isDeleted: boolean;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class Int32EntityDto implements IInt32EntityDto {
    id: number;

    constructor(data?: IInt32EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int32EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int32EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int32EntityDto {
        const json = this.toJSON();
        let result = new Int32EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt32EntityDto {
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class RouteDto implements IRouteDto {
    name: string;
    description: string | undefined;
    company: CompanyDto;
    farms: FarmDto[] | undefined;
    id: string;

    constructor(data?: IRouteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RouteDto {
        data = typeof data === 'object' ? data : {};
        let result = new RouteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): RouteDto {
        const json = this.toJSON();
        let result = new RouteDto();
        result.init(json);
        return result;
    }
}

export interface IRouteDto {
    name: string;
    description: string | undefined;
    company: CompanyDto;
    farms: FarmDto[] | undefined;
    id: string;
}

export class RouteDtoPagedResultDto implements IRouteDtoPagedResultDto {
    totalCount: number;
    items: RouteDto[] | undefined;

    constructor(data?: IRouteDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RouteDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RouteDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RouteDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RouteDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RouteDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRouteDtoPagedResultDto {
    totalCount: number;
    items: RouteDto[] | undefined;
}

export class CreateRouteDto implements ICreateRouteDto {
    name: string;
    description: string | undefined;
    companyId: string;
    farmsId: string[] | undefined;

    constructor(data?: ICreateRouteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRouteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRouteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        return data;
    }

    clone(): CreateRouteDto {
        const json = this.toJSON();
        let result = new CreateRouteDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRouteDto {
    name: string;
    description: string | undefined;
    companyId: string;
    farmsId: string[] | undefined;
}

export class UpdateRouteDto implements IUpdateRouteDto {
    name: string;
    description: string | undefined;
    companyId: string;
    farmsId: string[] | undefined;
    id: string;

    constructor(data?: IUpdateRouteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateRouteDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRouteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateRouteDto {
        const json = this.toJSON();
        let result = new UpdateRouteDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateRouteDto {
    name: string;
    description: string | undefined;
    companyId: string;
    farmsId: string[] | undefined;
    id: string;
}

export class SalaryAllowanceDtoPagedResultDto implements ISalaryAllowanceDtoPagedResultDto {
    totalCount: number;
    items: SalaryAllowanceDto[] | undefined;

    constructor(data?: ISalaryAllowanceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SalaryAllowanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalaryAllowanceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryAllowanceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SalaryAllowanceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SalaryAllowanceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISalaryAllowanceDtoPagedResultDto {
    totalCount: number;
    items: SalaryAllowanceDto[] | undefined;
}

export class CreateSalaryAllowanceDto implements ICreateSalaryAllowanceDto {
    name: string;
    code: string;
    description: string | undefined;
    amount: number;
    taxable: boolean;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateSalaryAllowanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.taxable = _data["taxable"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateSalaryAllowanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSalaryAllowanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["taxable"] = this.taxable;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateSalaryAllowanceDto {
        const json = this.toJSON();
        let result = new CreateSalaryAllowanceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSalaryAllowanceDto {
    name: string;
    code: string;
    description: string | undefined;
    amount: number;
    taxable: boolean;
    langKey: string;
    countryCode: string;
}

export class UpdateSalaryAllowanceDto implements IUpdateSalaryAllowanceDto {
    name: string;
    code: string;
    description: string | undefined;
    amount: number;
    taxable: boolean;
    langKey: string;
    countryCode: string;
    id: string;

    constructor(data?: IUpdateSalaryAllowanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.taxable = _data["taxable"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSalaryAllowanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSalaryAllowanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["taxable"] = this.taxable;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateSalaryAllowanceDto {
        const json = this.toJSON();
        let result = new UpdateSalaryAllowanceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSalaryAllowanceDto {
    name: string;
    code: string;
    description: string | undefined;
    amount: number;
    taxable: boolean;
    langKey: string;
    countryCode: string;
    id: string;
}

export class SalaryBonusTypeDtoPagedResultDto implements ISalaryBonusTypeDtoPagedResultDto {
    totalCount: number;
    items: SalaryBonusTypeDto[] | undefined;

    constructor(data?: ISalaryBonusTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SalaryBonusTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalaryBonusTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryBonusTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SalaryBonusTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SalaryBonusTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISalaryBonusTypeDtoPagedResultDto {
    totalCount: number;
    items: SalaryBonusTypeDto[] | undefined;
}

export class CreateSalaryBonusTypeDto implements ICreateSalaryBonusTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateSalaryBonusTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateSalaryBonusTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSalaryBonusTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateSalaryBonusTypeDto {
        const json = this.toJSON();
        let result = new CreateSalaryBonusTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSalaryBonusTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
}

export class UpdateSalaryBonusTypeDto implements IUpdateSalaryBonusTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateSalaryBonusTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSalaryBonusTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSalaryBonusTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateSalaryBonusTypeDto {
        const json = this.toJSON();
        let result = new UpdateSalaryBonusTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSalaryBonusTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    countryCode: string;
    id: number;
}

export class SalaryStructureDtoPagedResultDto implements ISalaryStructureDtoPagedResultDto {
    totalCount: number;
    items: SalaryStructureDto[] | undefined;

    constructor(data?: ISalaryStructureDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SalaryStructureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalaryStructureDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryStructureDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SalaryStructureDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SalaryStructureDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISalaryStructureDtoPagedResultDto {
    totalCount: number;
    items: SalaryStructureDto[] | undefined;
}

export class CreateSalaryStructureDto implements ICreateSalaryStructureDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    companyId: string;

    constructor(data?: ICreateSalaryStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateSalaryStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSalaryStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateSalaryStructureDto {
        const json = this.toJSON();
        let result = new CreateSalaryStructureDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSalaryStructureDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    companyId: string;
}

export class UpdateSalaryStructureDto implements IUpdateSalaryStructureDto {
    name: string;
    code: string;
    description: string | undefined;
    id: string;

    constructor(data?: IUpdateSalaryStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSalaryStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSalaryStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateSalaryStructureDto {
        const json = this.toJSON();
        let result = new UpdateSalaryStructureDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSalaryStructureDto {
    name: string;
    code: string;
    description: string | undefined;
    id: string;
}

export class SalaryTypeDtoPagedResultDto implements ISalaryTypeDtoPagedResultDto {
    totalCount: number;
    items: SalaryTypeDto[] | undefined;

    constructor(data?: ISalaryTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SalaryTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalaryTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SalaryTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SalaryTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISalaryTypeDtoPagedResultDto {
    totalCount: number;
    items: SalaryTypeDto[] | undefined;
}

export class CreateSalaryTypeDto implements ICreateSalaryTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;

    constructor(data?: ICreateSalaryTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CreateSalaryTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSalaryTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["countryCode"] = this.countryCode;
        return data;
    }

    clone(): CreateSalaryTypeDto {
        const json = this.toJSON();
        let result = new CreateSalaryTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSalaryTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    langKey: string;
    countryCode: string;
}

export class UpdateSalaryTypeDto implements IUpdateSalaryTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    countryCode: string;
    id: number;

    constructor(data?: IUpdateSalaryTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSalaryTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSalaryTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateSalaryTypeDto {
        const json = this.toJSON();
        let result = new UpdateSalaryTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSalaryTypeDto {
    name: string;
    code: string;
    description: string | undefined;
    countryCode: string;
    id: number;
}

export class SalePriceDtoPagedResultDto implements ISalePriceDtoPagedResultDto {
    totalCount: number;
    items: SalePriceDto[] | undefined;

    constructor(data?: ISalePriceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SalePriceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalePriceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalePriceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SalePriceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SalePriceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISalePriceDtoPagedResultDto {
    totalCount: number;
    items: SalePriceDto[] | undefined;
}

export class SizeInfoDto implements ISizeInfoDto {
    shirtSize: string | undefined;
    pantSize: string | undefined;
    shoeSize: string | undefined;
    id: string;

    constructor(data?: ISizeInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shirtSize = _data["shirtSize"];
            this.pantSize = _data["pantSize"];
            this.shoeSize = _data["shoeSize"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SizeInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SizeInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shirtSize"] = this.shirtSize;
        data["pantSize"] = this.pantSize;
        data["shoeSize"] = this.shoeSize;
        data["id"] = this.id;
        return data;
    }

    clone(): SizeInfoDto {
        const json = this.toJSON();
        let result = new SizeInfoDto();
        result.init(json);
        return result;
    }
}

export interface ISizeInfoDto {
    shirtSize: string | undefined;
    pantSize: string | undefined;
    shoeSize: string | undefined;
    id: string;
}

export class WorkerInfoDto implements IWorkerInfoDto {
    internalCode: string | undefined;
    country: CountryDto;
    birthday: moment.Moment;
    genre: GenreDto;
    genreId: string;
    maritalStatus: MaritalStatusDto;
    maritalStatusId: string;
    academicInfo: AcademicInfoDto;
    academicInfoId: string;
    sizeInfo: SizeInfoDto;
    contactInfo: ContactInfoDto;
    driverLicenseInfo: DriverLicenseInfoDto;
    id: string;

    constructor(data?: IWorkerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalCode = _data["internalCode"];
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
            this.birthday = _data["birthday"] ? moment(_data["birthday"].toString()) : <any>undefined;
            this.genre = _data["genre"] ? GenreDto.fromJS(_data["genre"]) : <any>undefined;
            this.genreId = _data["genreId"];
            this.maritalStatus = _data["maritalStatus"] ? MaritalStatusDto.fromJS(_data["maritalStatus"]) : <any>undefined;
            this.maritalStatusId = _data["maritalStatusId"];
            this.academicInfo = _data["academicInfo"] ? AcademicInfoDto.fromJS(_data["academicInfo"]) : <any>undefined;
            this.academicInfoId = _data["academicInfoId"];
            this.sizeInfo = _data["sizeInfo"] ? SizeInfoDto.fromJS(_data["sizeInfo"]) : <any>undefined;
            this.contactInfo = _data["contactInfo"] ? ContactInfoDto.fromJS(_data["contactInfo"]) : <any>undefined;
            this.driverLicenseInfo = _data["driverLicenseInfo"] ? DriverLicenseInfoDto.fromJS(_data["driverLicenseInfo"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalCode"] = this.internalCode;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["genre"] = this.genre ? this.genre.toJSON() : <any>undefined;
        data["genreId"] = this.genreId;
        data["maritalStatus"] = this.maritalStatus ? this.maritalStatus.toJSON() : <any>undefined;
        data["maritalStatusId"] = this.maritalStatusId;
        data["academicInfo"] = this.academicInfo ? this.academicInfo.toJSON() : <any>undefined;
        data["academicInfoId"] = this.academicInfoId;
        data["sizeInfo"] = this.sizeInfo ? this.sizeInfo.toJSON() : <any>undefined;
        data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
        data["driverLicenseInfo"] = this.driverLicenseInfo ? this.driverLicenseInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkerInfoDto {
        const json = this.toJSON();
        let result = new WorkerInfoDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerInfoDto {
    internalCode: string | undefined;
    country: CountryDto;
    birthday: moment.Moment;
    genre: GenreDto;
    genreId: string;
    maritalStatus: MaritalStatusDto;
    maritalStatusId: string;
    academicInfo: AcademicInfoDto;
    academicInfoId: string;
    sizeInfo: SizeInfoDto;
    contactInfo: ContactInfoDto;
    driverLicenseInfo: DriverLicenseInfoDto;
    id: string;
}

export class VoluntaryRetirementSavingDto implements IVoluntaryRetirementSavingDto {
    paymentConcept: PaymentConceptDto;
    paymentConceptId: number;
    institutionType: InstitutionTypeDto;
    institutionTypeId: number;
    retirementInstitution: RetirementInstitutionDto;
    retirementInstitutionId: number;
    paymentMethod: PaymentMethodDto;
    paymentMethodId: number;
    taxReduction: boolean;
    paymentType: PaymentTypeDto;
    paymentTypeId: number;
    docNumber: string | undefined;
    amount: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    workerId: string;
    id: string;

    constructor(data?: IVoluntaryRetirementSavingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentConcept = _data["paymentConcept"] ? PaymentConceptDto.fromJS(_data["paymentConcept"]) : <any>undefined;
            this.paymentConceptId = _data["paymentConceptId"];
            this.institutionType = _data["institutionType"] ? InstitutionTypeDto.fromJS(_data["institutionType"]) : <any>undefined;
            this.institutionTypeId = _data["institutionTypeId"];
            this.retirementInstitution = _data["retirementInstitution"] ? RetirementInstitutionDto.fromJS(_data["retirementInstitution"]) : <any>undefined;
            this.retirementInstitutionId = _data["retirementInstitutionId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethodDto.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.paymentMethodId = _data["paymentMethodId"];
            this.taxReduction = _data["taxReduction"];
            this.paymentType = _data["paymentType"] ? PaymentTypeDto.fromJS(_data["paymentType"]) : <any>undefined;
            this.paymentTypeId = _data["paymentTypeId"];
            this.docNumber = _data["docNumber"];
            this.amount = _data["amount"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.workerId = _data["workerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VoluntaryRetirementSavingDto {
        data = typeof data === 'object' ? data : {};
        let result = new VoluntaryRetirementSavingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentConcept"] = this.paymentConcept ? this.paymentConcept.toJSON() : <any>undefined;
        data["paymentConceptId"] = this.paymentConceptId;
        data["institutionType"] = this.institutionType ? this.institutionType.toJSON() : <any>undefined;
        data["institutionTypeId"] = this.institutionTypeId;
        data["retirementInstitution"] = this.retirementInstitution ? this.retirementInstitution.toJSON() : <any>undefined;
        data["retirementInstitutionId"] = this.retirementInstitutionId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["paymentMethodId"] = this.paymentMethodId;
        data["taxReduction"] = this.taxReduction;
        data["paymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["paymentTypeId"] = this.paymentTypeId;
        data["docNumber"] = this.docNumber;
        data["amount"] = this.amount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["workerId"] = this.workerId;
        data["id"] = this.id;
        return data;
    }

    clone(): VoluntaryRetirementSavingDto {
        const json = this.toJSON();
        let result = new VoluntaryRetirementSavingDto();
        result.init(json);
        return result;
    }
}

export interface IVoluntaryRetirementSavingDto {
    paymentConcept: PaymentConceptDto;
    paymentConceptId: number;
    institutionType: InstitutionTypeDto;
    institutionTypeId: number;
    retirementInstitution: RetirementInstitutionDto;
    retirementInstitutionId: number;
    paymentMethod: PaymentMethodDto;
    paymentMethodId: number;
    taxReduction: boolean;
    paymentType: PaymentTypeDto;
    paymentTypeId: number;
    docNumber: string | undefined;
    amount: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    workerId: string;
    id: string;
}

export class WorkerDto implements IWorkerDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    readonly fullName: string | undefined;
    code: string | undefined;
    tenantId: number;
    faceId: string;
    photo: string | undefined;
    workerInfo: WorkerInfoDto;
    workingInfo: WorkingInfoDto;
    identificationType: IdentificationTypeDto;
    identificationTypeId: string;
    identificationNumber: string | undefined;
    contracts: ContractDto[] | undefined;
    retirementInfo: RetirementInfoDto;
    healthInfo: HealthInfoDto;
    afcInfo: AFCInfoDto;
    retirementRecordInfo: RetirementRecordInfoDto;
    voluntaryRetirementSavings: VoluntaryRetirementSavingDto[] | undefined;
    familyDependentInfo: FamilyDependentInfoDto;
    familyDependents: FamilyDependentDto[] | undefined;
    bankaryInfo: BankaryInfoDto;
    id: string;

    constructor(data?: IWorkerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
            this.code = _data["code"];
            this.tenantId = _data["tenantId"];
            this.faceId = _data["faceId"];
            this.photo = _data["photo"];
            this.workerInfo = _data["workerInfo"] ? WorkerInfoDto.fromJS(_data["workerInfo"]) : <any>undefined;
            this.workingInfo = _data["workingInfo"] ? WorkingInfoDto.fromJS(_data["workingInfo"]) : <any>undefined;
            this.identificationType = _data["identificationType"] ? IdentificationTypeDto.fromJS(_data["identificationType"]) : <any>undefined;
            this.identificationTypeId = _data["identificationTypeId"];
            this.identificationNumber = _data["identificationNumber"];
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts.push(ContractDto.fromJS(item));
            }
            this.retirementInfo = _data["retirementInfo"] ? RetirementInfoDto.fromJS(_data["retirementInfo"]) : <any>undefined;
            this.healthInfo = _data["healthInfo"] ? HealthInfoDto.fromJS(_data["healthInfo"]) : <any>undefined;
            this.afcInfo = _data["afcInfo"] ? AFCInfoDto.fromJS(_data["afcInfo"]) : <any>undefined;
            this.retirementRecordInfo = _data["retirementRecordInfo"] ? RetirementRecordInfoDto.fromJS(_data["retirementRecordInfo"]) : <any>undefined;
            if (Array.isArray(_data["voluntaryRetirementSavings"])) {
                this.voluntaryRetirementSavings = [] as any;
                for (let item of _data["voluntaryRetirementSavings"])
                    this.voluntaryRetirementSavings.push(VoluntaryRetirementSavingDto.fromJS(item));
            }
            this.familyDependentInfo = _data["familyDependentInfo"] ? FamilyDependentInfoDto.fromJS(_data["familyDependentInfo"]) : <any>undefined;
            if (Array.isArray(_data["familyDependents"])) {
                this.familyDependents = [] as any;
                for (let item of _data["familyDependents"])
                    this.familyDependents.push(FamilyDependentDto.fromJS(item));
            }
            this.bankaryInfo = _data["bankaryInfo"] ? BankaryInfoDto.fromJS(_data["bankaryInfo"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkerDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["code"] = this.code;
        data["tenantId"] = this.tenantId;
        data["faceId"] = this.faceId;
        data["photo"] = this.photo;
        data["workerInfo"] = this.workerInfo ? this.workerInfo.toJSON() : <any>undefined;
        data["workingInfo"] = this.workingInfo ? this.workingInfo.toJSON() : <any>undefined;
        data["identificationType"] = this.identificationType ? this.identificationType.toJSON() : <any>undefined;
        data["identificationTypeId"] = this.identificationTypeId;
        data["identificationNumber"] = this.identificationNumber;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        data["retirementInfo"] = this.retirementInfo ? this.retirementInfo.toJSON() : <any>undefined;
        data["healthInfo"] = this.healthInfo ? this.healthInfo.toJSON() : <any>undefined;
        data["afcInfo"] = this.afcInfo ? this.afcInfo.toJSON() : <any>undefined;
        data["retirementRecordInfo"] = this.retirementRecordInfo ? this.retirementRecordInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.voluntaryRetirementSavings)) {
            data["voluntaryRetirementSavings"] = [];
            for (let item of this.voluntaryRetirementSavings)
                data["voluntaryRetirementSavings"].push(item.toJSON());
        }
        data["familyDependentInfo"] = this.familyDependentInfo ? this.familyDependentInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.familyDependents)) {
            data["familyDependents"] = [];
            for (let item of this.familyDependents)
                data["familyDependents"].push(item.toJSON());
        }
        data["bankaryInfo"] = this.bankaryInfo ? this.bankaryInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkerDto {
        const json = this.toJSON();
        let result = new WorkerDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    code: string | undefined;
    tenantId: number;
    faceId: string;
    photo: string | undefined;
    workerInfo: WorkerInfoDto;
    workingInfo: WorkingInfoDto;
    identificationType: IdentificationTypeDto;
    identificationTypeId: string;
    identificationNumber: string | undefined;
    contracts: ContractDto[] | undefined;
    retirementInfo: RetirementInfoDto;
    healthInfo: HealthInfoDto;
    afcInfo: AFCInfoDto;
    retirementRecordInfo: RetirementRecordInfoDto;
    voluntaryRetirementSavings: VoluntaryRetirementSavingDto[] | undefined;
    familyDependentInfo: FamilyDependentInfoDto;
    familyDependents: FamilyDependentDto[] | undefined;
    bankaryInfo: BankaryInfoDto;
    id: string;
}

export class ScheduleDto implements IScheduleDto {
    worker: WorkerDto;
    workerId: string;
    workShift: WorkShiftDto;
    workShiftId: string | undefined;
    date: moment.Moment;
    absence: AbsenceDto;
    absenceId: string | undefined;
    id: string;

    constructor(data?: IScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.worker = _data["worker"] ? WorkerDto.fromJS(_data["worker"]) : <any>undefined;
            this.workerId = _data["workerId"];
            this.workShift = _data["workShift"] ? WorkShiftDto.fromJS(_data["workShift"]) : <any>undefined;
            this.workShiftId = _data["workShiftId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.absence = _data["absence"] ? AbsenceDto.fromJS(_data["absence"]) : <any>undefined;
            this.absenceId = _data["absenceId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        data["workerId"] = this.workerId;
        data["workShift"] = this.workShift ? this.workShift.toJSON() : <any>undefined;
        data["workShiftId"] = this.workShiftId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["absence"] = this.absence ? this.absence.toJSON() : <any>undefined;
        data["absenceId"] = this.absenceId;
        data["id"] = this.id;
        return data;
    }

    clone(): ScheduleDto {
        const json = this.toJSON();
        let result = new ScheduleDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleDto {
    worker: WorkerDto;
    workerId: string;
    workShift: WorkShiftDto;
    workShiftId: string | undefined;
    date: moment.Moment;
    absence: AbsenceDto;
    absenceId: string | undefined;
    id: string;
}

export class ScheduleDtoPagedResultDto implements IScheduleDtoPagedResultDto {
    totalCount: number;
    items: ScheduleDto[] | undefined;

    constructor(data?: IScheduleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScheduleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ScheduleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ScheduleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleDtoPagedResultDto {
    totalCount: number;
    items: ScheduleDto[] | undefined;
}

export class CreateScheduleDto implements ICreateScheduleDto {
    workerId: string;
    workShiftId: string | undefined;
    date: moment.Moment;
    absenceId: string | undefined;

    constructor(data?: ICreateScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workerId = _data["workerId"];
            this.workShiftId = _data["workShiftId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.absenceId = _data["absenceId"];
        }
    }

    static fromJS(data: any): CreateScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workerId"] = this.workerId;
        data["workShiftId"] = this.workShiftId;
        data["date"] = this.date ? this.date.format('YYYY-MM-DD') : <any>undefined;
        data["absenceId"] = this.absenceId;
        return data;
    }

    clone(): CreateScheduleDto {
        const json = this.toJSON();
        let result = new CreateScheduleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateScheduleDto {
    workerId: string;
    workShiftId: string | undefined;
    date: moment.Moment;
    absenceId: string | undefined;
}

export class UpdateScheduleDto implements IUpdateScheduleDto {
    workerId: string;
    workShiftId: string | undefined;
    date: moment.Moment;
    absenceId: string | undefined;
    id: string;

    constructor(data?: IUpdateScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workerId = _data["workerId"];
            this.workShiftId = _data["workShiftId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.absenceId = _data["absenceId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workerId"] = this.workerId;
        data["workShiftId"] = this.workShiftId;
        data["date"] = this.date ? this.date.format('YYYY-MM-DD') : <any>undefined;
        data["absenceId"] = this.absenceId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateScheduleDto {
        const json = this.toJSON();
        let result = new UpdateScheduleDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateScheduleDto {
    workerId: string;
    workShiftId: string | undefined;
    date: moment.Moment;
    absenceId: string | undefined;
    id: string;
}

export class SimpleScheduleDto implements ISimpleScheduleDto {
    worker: SimpleWorkerDto;
    workerId: string;
    workShift: WorkShiftDto;
    workShiftId: string | undefined;
    date: moment.Moment;
    absence: AbsenceDto;
    absenceId: string | undefined;
    id: string;

    constructor(data?: ISimpleScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.worker = _data["worker"] ? SimpleWorkerDto.fromJS(_data["worker"]) : <any>undefined;
            this.workerId = _data["workerId"];
            this.workShift = _data["workShift"] ? WorkShiftDto.fromJS(_data["workShift"]) : <any>undefined;
            this.workShiftId = _data["workShiftId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.absence = _data["absence"] ? AbsenceDto.fromJS(_data["absence"]) : <any>undefined;
            this.absenceId = _data["absenceId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["worker"] = this.worker ? this.worker.toJSON() : <any>undefined;
        data["workerId"] = this.workerId;
        data["workShift"] = this.workShift ? this.workShift.toJSON() : <any>undefined;
        data["workShiftId"] = this.workShiftId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["absence"] = this.absence ? this.absence.toJSON() : <any>undefined;
        data["absenceId"] = this.absenceId;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleScheduleDto {
        const json = this.toJSON();
        let result = new SimpleScheduleDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleScheduleDto {
    worker: SimpleWorkerDto;
    workerId: string;
    workShift: WorkShiftDto;
    workShiftId: string | undefined;
    date: moment.Moment;
    absence: AbsenceDto;
    absenceId: string | undefined;
    id: string;
}

export class WorkerScheduleDto implements IWorkerScheduleDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    readonly fullName: string | undefined;
    code: string | undefined;
    photo: string | undefined;
    identificationNumber: string | undefined;
    schedules: SimpleScheduleDto[] | undefined;
    id: string;

    constructor(data?: IWorkerScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
            this.code = _data["code"];
            this.photo = _data["photo"];
            this.identificationNumber = _data["identificationNumber"];
            if (Array.isArray(_data["schedules"])) {
                this.schedules = [] as any;
                for (let item of _data["schedules"])
                    this.schedules.push(SimpleScheduleDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkerScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["code"] = this.code;
        data["photo"] = this.photo;
        data["identificationNumber"] = this.identificationNumber;
        if (Array.isArray(this.schedules)) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): WorkerScheduleDto {
        const json = this.toJSON();
        let result = new WorkerScheduleDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerScheduleDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    code: string | undefined;
    photo: string | undefined;
    identificationNumber: string | undefined;
    schedules: SimpleScheduleDto[] | undefined;
    id: string;
}

export class WorkerScheduleDtoPagedResultDto implements IWorkerScheduleDtoPagedResultDto {
    totalCount: number;
    items: WorkerScheduleDto[] | undefined;

    constructor(data?: IWorkerScheduleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkerScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkerScheduleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerScheduleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkerScheduleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkerScheduleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerScheduleDtoPagedResultDto {
    totalCount: number;
    items: WorkerScheduleDto[] | undefined;
}

export class SimpleScheduleDtoListResultDto implements ISimpleScheduleDtoListResultDto {
    items: SimpleScheduleDto[] | undefined;

    constructor(data?: ISimpleScheduleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SimpleScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SimpleScheduleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleScheduleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SimpleScheduleDtoListResultDto {
        const json = this.toJSON();
        let result = new SimpleScheduleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleScheduleDtoListResultDto {
    items: SimpleScheduleDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = this.features[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    companyId: string | undefined;
    farmId: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.companyId = _data["companyId"];
            this.farmId = _data["farmId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["companyId"] = this.companyId;
        data["farmId"] = this.farmId;
        data["id"] = this.id;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    companyId: string | undefined;
    farmId: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    countryCode: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.countryCode = _data["countryCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["countryCode"] = this.countryCode;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    countryCode: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class SizeInfoDtoPagedResultDto implements ISizeInfoDtoPagedResultDto {
    totalCount: number;
    items: SizeInfoDto[] | undefined;

    constructor(data?: ISizeInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SizeInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SizeInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SizeInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SizeInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SizeInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISizeInfoDtoPagedResultDto {
    totalCount: number;
    items: SizeInfoDto[] | undefined;
}

export class CreateSizeInfoDto implements ICreateSizeInfoDto {
    shirtSize: string | undefined;
    pantSize: string | undefined;
    shoeSize: string | undefined;

    constructor(data?: ICreateSizeInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shirtSize = _data["shirtSize"];
            this.pantSize = _data["pantSize"];
            this.shoeSize = _data["shoeSize"];
        }
    }

    static fromJS(data: any): CreateSizeInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSizeInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shirtSize"] = this.shirtSize;
        data["pantSize"] = this.pantSize;
        data["shoeSize"] = this.shoeSize;
        return data;
    }

    clone(): CreateSizeInfoDto {
        const json = this.toJSON();
        let result = new CreateSizeInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSizeInfoDto {
    shirtSize: string | undefined;
    pantSize: string | undefined;
    shoeSize: string | undefined;
}

export class UpdateSizeInfoDto implements IUpdateSizeInfoDto {
    shirtSize: string | undefined;
    pantSize: string | undefined;
    shoeSize: string | undefined;
    id: string;

    constructor(data?: IUpdateSizeInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shirtSize = _data["shirtSize"];
            this.pantSize = _data["pantSize"];
            this.shoeSize = _data["shoeSize"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSizeInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSizeInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shirtSize"] = this.shirtSize;
        data["pantSize"] = this.pantSize;
        data["shoeSize"] = this.shoeSize;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateSizeInfoDto {
        const json = this.toJSON();
        let result = new UpdateSizeInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSizeInfoDto {
    shirtSize: string | undefined;
    pantSize: string | undefined;
    shoeSize: string | undefined;
    id: string;
}

export class VarietyDto implements IVarietyDto {
    name: string | undefined;
    businessName: string | undefined;
    speciesId: number;
    tags: TagDto[] | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IVarietyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.speciesId = _data["speciesId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): VarietyDto {
        data = typeof data === 'object' ? data : {};
        let result = new VarietyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["speciesId"] = this.speciesId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): VarietyDto {
        const json = this.toJSON();
        let result = new VarietyDto();
        result.init(json);
        return result;
    }
}

export interface IVarietyDto {
    name: string | undefined;
    businessName: string | undefined;
    speciesId: number;
    tags: TagDto[] | undefined;
    isDeleted: boolean;
    id: number;
}

export class SpecieDto implements ISpecieDto {
    name: string | undefined;
    businessName: string | undefined;
    code: string | undefined;
    equivalentBoxWeight: number;
    varieties: VarietyDto[] | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: ISpecieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.code = _data["code"];
            this.equivalentBoxWeight = _data["equivalentBoxWeight"];
            if (Array.isArray(_data["varieties"])) {
                this.varieties = [] as any;
                for (let item of _data["varieties"])
                    this.varieties.push(VarietyDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SpecieDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["code"] = this.code;
        data["equivalentBoxWeight"] = this.equivalentBoxWeight;
        if (Array.isArray(this.varieties)) {
            data["varieties"] = [];
            for (let item of this.varieties)
                data["varieties"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): SpecieDto {
        const json = this.toJSON();
        let result = new SpecieDto();
        result.init(json);
        return result;
    }
}

export interface ISpecieDto {
    name: string | undefined;
    businessName: string | undefined;
    code: string | undefined;
    equivalentBoxWeight: number;
    varieties: VarietyDto[] | undefined;
    isDeleted: boolean;
    id: number;
}

export class SpecieDtoPagedResultDto implements ISpecieDtoPagedResultDto {
    totalCount: number;
    items: SpecieDto[] | undefined;

    constructor(data?: ISpecieDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SpecieDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpecieDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecieDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SpecieDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SpecieDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISpecieDtoPagedResultDto {
    totalCount: number;
    items: SpecieDto[] | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class CreateSpecieDto implements ICreateSpecieDto {
    name: string | undefined;
    businessName: string | undefined;
    code: string | undefined;
    equivalentBoxWeight: number;
    id: number;

    constructor(data?: ICreateSpecieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.code = _data["code"];
            this.equivalentBoxWeight = _data["equivalentBoxWeight"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateSpecieDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSpecieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["code"] = this.code;
        data["equivalentBoxWeight"] = this.equivalentBoxWeight;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateSpecieDto {
        const json = this.toJSON();
        let result = new CreateSpecieDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSpecieDto {
    name: string | undefined;
    businessName: string | undefined;
    code: string | undefined;
    equivalentBoxWeight: number;
    id: number;
}

export class CreateSubFamilyDto implements ICreateSubFamilyDto {
    name: string;
    code: string;
    productFamilyId: string;
    id: string;

    constructor(data?: ICreateSubFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.productFamilyId = _data["productFamilyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateSubFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["productFamilyId"] = this.productFamilyId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateSubFamilyDto {
        const json = this.toJSON();
        let result = new CreateSubFamilyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSubFamilyDto {
    name: string;
    code: string;
    productFamilyId: string;
    id: string;
}

export class SubFamilyDto implements ISubFamilyDto {
    name: string;
    code: string;
    productFamilyId: string;
    products: ActiveIngredientProductDto[] | undefined;
    id: string;

    constructor(data?: ISubFamilyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.productFamilyId = _data["productFamilyId"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products.push(ActiveIngredientProductDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubFamilyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubFamilyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["productFamilyId"] = this.productFamilyId;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): SubFamilyDto {
        const json = this.toJSON();
        let result = new SubFamilyDto();
        result.init(json);
        return result;
    }
}

export interface ISubFamilyDto {
    name: string;
    code: string;
    productFamilyId: string;
    products: ActiveIngredientProductDto[] | undefined;
    id: string;
}

export class SubFamilyDtoPagedResultDto implements ISubFamilyDtoPagedResultDto {
    totalCount: number;
    items: SubFamilyDto[] | undefined;

    constructor(data?: ISubFamilyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SubFamilyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubFamilyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubFamilyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubFamilyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SubFamilyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISubFamilyDtoPagedResultDto {
    totalCount: number;
    items: SubFamilyDto[] | undefined;
}

export class CreateSupplierDto implements ICreateSupplierDto {
    rut: string;
    name: string;
    businessName: string;
    code: string;
    companiesId: string[] | undefined;
    currencyId: number;
    isProvider: boolean;
    isProducer: boolean;
    isRelatedCompany: boolean;
    isActive: boolean;
    address: CreateAddressDto;
    phone: string | undefined;
    webSite: string | undefined;
    email: string;
    wayPayId: number | undefined;
    termDays: number | undefined;
    noticeTypeId: number | undefined;
    noticeMessage: string | undefined;
    tagsArray: string[] | undefined;
    id: string;

    constructor(data?: ICreateSupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rut = _data["rut"];
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.code = _data["code"];
            if (Array.isArray(_data["companiesId"])) {
                this.companiesId = [] as any;
                for (let item of _data["companiesId"])
                    this.companiesId.push(item);
            }
            this.currencyId = _data["currencyId"];
            this.isProvider = _data["isProvider"];
            this.isProducer = _data["isProducer"];
            this.isRelatedCompany = _data["isRelatedCompany"];
            this.isActive = _data["isActive"];
            this.address = _data["address"] ? CreateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.phone = _data["phone"];
            this.webSite = _data["webSite"];
            this.email = _data["email"];
            this.wayPayId = _data["wayPayId"];
            this.termDays = _data["termDays"];
            this.noticeTypeId = _data["noticeTypeId"];
            this.noticeMessage = _data["noticeMessage"];
            if (Array.isArray(_data["tagsArray"])) {
                this.tagsArray = [] as any;
                for (let item of _data["tagsArray"])
                    this.tagsArray.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateSupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rut"] = this.rut;
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["code"] = this.code;
        if (Array.isArray(this.companiesId)) {
            data["companiesId"] = [];
            for (let item of this.companiesId)
                data["companiesId"].push(item);
        }
        data["currencyId"] = this.currencyId;
        data["isProvider"] = this.isProvider;
        data["isProducer"] = this.isProducer;
        data["isRelatedCompany"] = this.isRelatedCompany;
        data["isActive"] = this.isActive;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["webSite"] = this.webSite;
        data["email"] = this.email;
        data["wayPayId"] = this.wayPayId;
        data["termDays"] = this.termDays;
        data["noticeTypeId"] = this.noticeTypeId;
        data["noticeMessage"] = this.noticeMessage;
        if (Array.isArray(this.tagsArray)) {
            data["tagsArray"] = [];
            for (let item of this.tagsArray)
                data["tagsArray"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): CreateSupplierDto {
        const json = this.toJSON();
        let result = new CreateSupplierDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSupplierDto {
    rut: string;
    name: string;
    businessName: string;
    code: string;
    companiesId: string[] | undefined;
    currencyId: number;
    isProvider: boolean;
    isProducer: boolean;
    isRelatedCompany: boolean;
    isActive: boolean;
    address: CreateAddressDto;
    phone: string | undefined;
    webSite: string | undefined;
    email: string;
    wayPayId: number | undefined;
    termDays: number | undefined;
    noticeTypeId: number | undefined;
    noticeMessage: string | undefined;
    tagsArray: string[] | undefined;
    id: string;
}

export class UpdateSupplierDto implements IUpdateSupplierDto {
    rut: string;
    name: string;
    businessName: string;
    code: string;
    companiesId: string[] | undefined;
    currencyId: number;
    isProvider: boolean;
    isProducer: boolean;
    isRelatedCompany: boolean;
    isActive: boolean;
    address: UpdateAddressDto;
    phone: string | undefined;
    webSite: string | undefined;
    email: string;
    wayPayId: number | undefined;
    termDays: number | undefined;
    noticeTypeId: number | undefined;
    noticeMessage: string | undefined;
    tags: TagDto[] | undefined;
    isDeleted: boolean;
    id: string;

    constructor(data?: IUpdateSupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rut = _data["rut"];
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.code = _data["code"];
            if (Array.isArray(_data["companiesId"])) {
                this.companiesId = [] as any;
                for (let item of _data["companiesId"])
                    this.companiesId.push(item);
            }
            this.currencyId = _data["currencyId"];
            this.isProvider = _data["isProvider"];
            this.isProducer = _data["isProducer"];
            this.isRelatedCompany = _data["isRelatedCompany"];
            this.isActive = _data["isActive"];
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.phone = _data["phone"];
            this.webSite = _data["webSite"];
            this.email = _data["email"];
            this.wayPayId = _data["wayPayId"];
            this.termDays = _data["termDays"];
            this.noticeTypeId = _data["noticeTypeId"];
            this.noticeMessage = _data["noticeMessage"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rut"] = this.rut;
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["code"] = this.code;
        if (Array.isArray(this.companiesId)) {
            data["companiesId"] = [];
            for (let item of this.companiesId)
                data["companiesId"].push(item);
        }
        data["currencyId"] = this.currencyId;
        data["isProvider"] = this.isProvider;
        data["isProducer"] = this.isProducer;
        data["isRelatedCompany"] = this.isRelatedCompany;
        data["isActive"] = this.isActive;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["webSite"] = this.webSite;
        data["email"] = this.email;
        data["wayPayId"] = this.wayPayId;
        data["termDays"] = this.termDays;
        data["noticeTypeId"] = this.noticeTypeId;
        data["noticeMessage"] = this.noticeMessage;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateSupplierDto {
        const json = this.toJSON();
        let result = new UpdateSupplierDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSupplierDto {
    rut: string;
    name: string;
    businessName: string;
    code: string;
    companiesId: string[] | undefined;
    currencyId: number;
    isProvider: boolean;
    isProducer: boolean;
    isRelatedCompany: boolean;
    isActive: boolean;
    address: UpdateAddressDto;
    phone: string | undefined;
    webSite: string | undefined;
    email: string;
    wayPayId: number | undefined;
    termDays: number | undefined;
    noticeTypeId: number | undefined;
    noticeMessage: string | undefined;
    tags: TagDto[] | undefined;
    isDeleted: boolean;
    id: string;
}

export class SupplierDtoPagedResultDto implements ISupplierDtoPagedResultDto {
    totalCount: number;
    items: SupplierDto[] | undefined;

    constructor(data?: ISupplierDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SupplierDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupplierDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SupplierDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SupplierDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierDtoPagedResultDto {
    totalCount: number;
    items: SupplierDto[] | undefined;
}

export class CreateApproverDto implements ICreateApproverDto {
    userId: number;
    jobTitleName: string | undefined;
    approvalLimit: number;
    signatureimg: FileDto;
    isActive: boolean;
    id: string;

    constructor(data?: ICreateApproverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.jobTitleName = _data["jobTitleName"];
            this.approvalLimit = _data["approvalLimit"];
            this.signatureimg = _data["signatureimg"] ? FileDto.fromJS(_data["signatureimg"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateApproverDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApproverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["jobTitleName"] = this.jobTitleName;
        data["approvalLimit"] = this.approvalLimit;
        data["signatureimg"] = this.signatureimg ? this.signatureimg.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateApproverDto {
        const json = this.toJSON();
        let result = new CreateApproverDto();
        result.init(json);
        return result;
    }
}

export interface ICreateApproverDto {
    userId: number;
    jobTitleName: string | undefined;
    approvalLimit: number;
    signatureimg: FileDto;
    isActive: boolean;
    id: string;
}

export class ApproverDtoPagedResultDto implements IApproverDtoPagedResultDto {
    totalCount: number;
    items: ApproverDto[] | undefined;

    constructor(data?: IApproverDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApproverDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApproverDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApproverDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ApproverDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IApproverDtoPagedResultDto {
    totalCount: number;
    items: ApproverDto[] | undefined;
}

export class UpdateApproverDto implements IUpdateApproverDto {
    userId: number;
    jobTitleName: string | undefined;
    approvalLimit: number;
    signatureimg: FileDto;
    delegatedSignatureUserId: number | undefined;
    isActive: boolean;
    id: string;

    constructor(data?: IUpdateApproverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.jobTitleName = _data["jobTitleName"];
            this.approvalLimit = _data["approvalLimit"];
            this.signatureimg = _data["signatureimg"] ? FileDto.fromJS(_data["signatureimg"]) : <any>undefined;
            this.delegatedSignatureUserId = _data["delegatedSignatureUserId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateApproverDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApproverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["jobTitleName"] = this.jobTitleName;
        data["approvalLimit"] = this.approvalLimit;
        data["signatureimg"] = this.signatureimg ? this.signatureimg.toJSON() : <any>undefined;
        data["delegatedSignatureUserId"] = this.delegatedSignatureUserId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateApproverDto {
        const json = this.toJSON();
        let result = new UpdateApproverDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateApproverDto {
    userId: number;
    jobTitleName: string | undefined;
    approvalLimit: number;
    signatureimg: FileDto;
    delegatedSignatureUserId: number | undefined;
    isActive: boolean;
    id: string;
}

export class CreateSupplierFarmDto implements ICreateSupplierFarmDto {
    name: string;
    code: string;
    address: CreateAddressDto;
    phone: string | undefined;
    email: string | undefined;
    supplierId: string;
    paymentInformationIds: string[] | undefined;
    isActive: boolean;
    id: string;

    constructor(data?: ICreateSupplierFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"] ? CreateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.supplierId = _data["supplierId"];
            if (Array.isArray(_data["paymentInformationIds"])) {
                this.paymentInformationIds = [] as any;
                for (let item of _data["paymentInformationIds"])
                    this.paymentInformationIds.push(item);
            }
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateSupplierFarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSupplierFarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["supplierId"] = this.supplierId;
        if (Array.isArray(this.paymentInformationIds)) {
            data["paymentInformationIds"] = [];
            for (let item of this.paymentInformationIds)
                data["paymentInformationIds"].push(item);
        }
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateSupplierFarmDto {
        const json = this.toJSON();
        let result = new CreateSupplierFarmDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSupplierFarmDto {
    name: string;
    code: string;
    address: CreateAddressDto;
    phone: string | undefined;
    email: string | undefined;
    supplierId: string;
    paymentInformationIds: string[] | undefined;
    isActive: boolean;
    id: string;
}

export class SimplePaymentMethodDto implements ISimplePaymentMethodDto {
    name: string | undefined;
    localizationKey: string | undefined;
    id: number;

    constructor(data?: ISimplePaymentMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.localizationKey = _data["localizationKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimplePaymentMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePaymentMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["localizationKey"] = this.localizationKey;
        data["id"] = this.id;
        return data;
    }

    clone(): SimplePaymentMethodDto {
        const json = this.toJSON();
        let result = new SimplePaymentMethodDto();
        result.init(json);
        return result;
    }
}

export interface ISimplePaymentMethodDto {
    name: string | undefined;
    localizationKey: string | undefined;
    id: number;
}

export class BankDataDto implements IBankDataDto {
    isNational: boolean;
    countryId: number;
    countryName: string | undefined;
    bankId: number;
    bankName: string | undefined;
    bankAccountTypeId: number;
    bankAccountTypeName: string | undefined;
    accountHolder: string | undefined;
    accountNumber: string | undefined;
    swiftCode: string | undefined;
    email: string | undefined;
    id: string;

    constructor(data?: IBankDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isNational = _data["isNational"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.bankId = _data["bankId"];
            this.bankName = _data["bankName"];
            this.bankAccountTypeId = _data["bankAccountTypeId"];
            this.bankAccountTypeName = _data["bankAccountTypeName"];
            this.accountHolder = _data["accountHolder"];
            this.accountNumber = _data["accountNumber"];
            this.swiftCode = _data["swiftCode"];
            this.email = _data["email"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BankDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNational"] = this.isNational;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["bankId"] = this.bankId;
        data["bankName"] = this.bankName;
        data["bankAccountTypeId"] = this.bankAccountTypeId;
        data["bankAccountTypeName"] = this.bankAccountTypeName;
        data["accountHolder"] = this.accountHolder;
        data["accountNumber"] = this.accountNumber;
        data["swiftCode"] = this.swiftCode;
        data["email"] = this.email;
        data["id"] = this.id;
        return data;
    }

    clone(): BankDataDto {
        const json = this.toJSON();
        let result = new BankDataDto();
        result.init(json);
        return result;
    }
}

export interface IBankDataDto {
    isNational: boolean;
    countryId: number;
    countryName: string | undefined;
    bankId: number;
    bankName: string | undefined;
    bankAccountTypeId: number;
    bankAccountTypeName: string | undefined;
    accountHolder: string | undefined;
    accountNumber: string | undefined;
    swiftCode: string | undefined;
    email: string | undefined;
    id: string;
}

export class SimplePaymentInformationDto implements ISimplePaymentInformationDto {
    paymentMethodId: number;
    paymentMethod: SimplePaymentMethodDto;
    bankDataId: string | undefined;
    bankData: BankDataDto;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ISimplePaymentInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"];
            this.paymentMethod = _data["paymentMethod"] ? SimplePaymentMethodDto.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.bankDataId = _data["bankDataId"];
            this.bankData = _data["bankData"] ? BankDataDto.fromJS(_data["bankData"]) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimplePaymentInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePaymentInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["bankDataId"] = this.bankDataId;
        data["bankData"] = this.bankData ? this.bankData.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): SimplePaymentInformationDto {
        const json = this.toJSON();
        let result = new SimplePaymentInformationDto();
        result.init(json);
        return result;
    }
}

export interface ISimplePaymentInformationDto {
    paymentMethodId: number;
    paymentMethod: SimplePaymentMethodDto;
    bankDataId: string | undefined;
    bankData: BankDataDto;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class SupplierFarmDto implements ISupplierFarmDto {
    name: string | undefined;
    code: string | undefined;
    address: AddressDto;
    phone: string | undefined;
    email: string | undefined;
    supplierId: string;
    paymentInformations: SimplePaymentInformationDto[] | undefined;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ISupplierFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.supplierId = _data["supplierId"];
            if (Array.isArray(_data["paymentInformations"])) {
                this.paymentInformations = [] as any;
                for (let item of _data["paymentInformations"])
                    this.paymentInformations.push(SimplePaymentInformationDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SupplierFarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierFarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["supplierId"] = this.supplierId;
        if (Array.isArray(this.paymentInformations)) {
            data["paymentInformations"] = [];
            for (let item of this.paymentInformations)
                data["paymentInformations"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): SupplierFarmDto {
        const json = this.toJSON();
        let result = new SupplierFarmDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierFarmDto {
    name: string | undefined;
    code: string | undefined;
    address: AddressDto;
    phone: string | undefined;
    email: string | undefined;
    supplierId: string;
    paymentInformations: SimplePaymentInformationDto[] | undefined;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class SupplierFarmDtoPagedResultDto implements ISupplierFarmDtoPagedResultDto {
    totalCount: number;
    items: SupplierFarmDto[] | undefined;

    constructor(data?: ISupplierFarmDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SupplierFarmDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupplierFarmDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierFarmDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SupplierFarmDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SupplierFarmDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierFarmDtoPagedResultDto {
    totalCount: number;
    items: SupplierFarmDto[] | undefined;
}

export class UpdateSupplierFarmDto implements IUpdateSupplierFarmDto {
    name: string;
    code: string;
    address: UpdateAddressDto;
    phone: string | undefined;
    email: string | undefined;
    supplierId: string;
    paymentInformationIds: string[] | undefined;
    isActive: boolean;
    id: string;

    constructor(data?: IUpdateSupplierFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.supplierId = _data["supplierId"];
            if (Array.isArray(_data["paymentInformationIds"])) {
                this.paymentInformationIds = [] as any;
                for (let item of _data["paymentInformationIds"])
                    this.paymentInformationIds.push(item);
            }
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateSupplierFarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSupplierFarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["supplierId"] = this.supplierId;
        if (Array.isArray(this.paymentInformationIds)) {
            data["paymentInformationIds"] = [];
            for (let item of this.paymentInformationIds)
                data["paymentInformationIds"].push(item);
        }
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateSupplierFarmDto {
        const json = this.toJSON();
        let result = new UpdateSupplierFarmDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSupplierFarmDto {
    name: string;
    code: string;
    address: UpdateAddressDto;
    phone: string | undefined;
    email: string | undefined;
    supplierId: string;
    paymentInformationIds: string[] | undefined;
    isActive: boolean;
    id: string;
}

export class CreateBankDataDto implements ICreateBankDataDto {
    isNational: boolean;
    countryId: number;
    bankId: number;
    bankAccountTypeId: number;
    accountHolder: string;
    accountNumber: string;
    swiftCode: string | undefined;
    email: string;

    constructor(data?: ICreateBankDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isNational = _data["isNational"];
            this.countryId = _data["countryId"];
            this.bankId = _data["bankId"];
            this.bankAccountTypeId = _data["bankAccountTypeId"];
            this.accountHolder = _data["accountHolder"];
            this.accountNumber = _data["accountNumber"];
            this.swiftCode = _data["swiftCode"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CreateBankDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBankDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNational"] = this.isNational;
        data["countryId"] = this.countryId;
        data["bankId"] = this.bankId;
        data["bankAccountTypeId"] = this.bankAccountTypeId;
        data["accountHolder"] = this.accountHolder;
        data["accountNumber"] = this.accountNumber;
        data["swiftCode"] = this.swiftCode;
        data["email"] = this.email;
        return data;
    }

    clone(): CreateBankDataDto {
        const json = this.toJSON();
        let result = new CreateBankDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateBankDataDto {
    isNational: boolean;
    countryId: number;
    bankId: number;
    bankAccountTypeId: number;
    accountHolder: string;
    accountNumber: string;
    swiftCode: string | undefined;
    email: string;
}

export class CreatePaymentInformationDto implements ICreatePaymentInformationDto {
    paymentMethodId: number;
    bankData: CreateBankDataDto;
    supplierFarmIds: string[] | undefined;
    supplierId: string;
    isActive: boolean;

    constructor(data?: ICreatePaymentInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"];
            this.bankData = _data["bankData"] ? CreateBankDataDto.fromJS(_data["bankData"]) : <any>undefined;
            if (Array.isArray(_data["supplierFarmIds"])) {
                this.supplierFarmIds = [] as any;
                for (let item of _data["supplierFarmIds"])
                    this.supplierFarmIds.push(item);
            }
            this.supplierId = _data["supplierId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreatePaymentInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId;
        data["bankData"] = this.bankData ? this.bankData.toJSON() : <any>undefined;
        if (Array.isArray(this.supplierFarmIds)) {
            data["supplierFarmIds"] = [];
            for (let item of this.supplierFarmIds)
                data["supplierFarmIds"].push(item);
        }
        data["supplierId"] = this.supplierId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreatePaymentInformationDto {
        const json = this.toJSON();
        let result = new CreatePaymentInformationDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentInformationDto {
    paymentMethodId: number;
    bankData: CreateBankDataDto;
    supplierFarmIds: string[] | undefined;
    supplierId: string;
    isActive: boolean;
}

export class SimpleSupplierFarmDto implements ISimpleSupplierFarmDto {
    name: string | undefined;
    code: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ISimpleSupplierFarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleSupplierFarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleSupplierFarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleSupplierFarmDto {
        const json = this.toJSON();
        let result = new SimpleSupplierFarmDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleSupplierFarmDto {
    name: string | undefined;
    code: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class PaymentInformationDto implements IPaymentInformationDto {
    paymentMethodId: number;
    paymentMethod: SimplePaymentMethodDto;
    bankDataId: string | undefined;
    bankData: BankDataDto;
    farms: SimpleSupplierFarmDto[] | undefined;
    isActive: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IPaymentInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"];
            this.paymentMethod = _data["paymentMethod"] ? SimplePaymentMethodDto.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.bankDataId = _data["bankDataId"];
            this.bankData = _data["bankData"] ? BankDataDto.fromJS(_data["bankData"]) : <any>undefined;
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(SimpleSupplierFarmDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["bankDataId"] = this.bankDataId;
        data["bankData"] = this.bankData ? this.bankData.toJSON() : <any>undefined;
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): PaymentInformationDto {
        const json = this.toJSON();
        let result = new PaymentInformationDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentInformationDto {
    paymentMethodId: number;
    paymentMethod: SimplePaymentMethodDto;
    bankDataId: string | undefined;
    bankData: BankDataDto;
    farms: SimpleSupplierFarmDto[] | undefined;
    isActive: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class PaymentInformationDtoPagedResultDto implements IPaymentInformationDtoPagedResultDto {
    totalCount: number;
    items: PaymentInformationDto[] | undefined;

    constructor(data?: IPaymentInformationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PaymentInformationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentInformationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInformationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaymentInformationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentInformationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentInformationDtoPagedResultDto {
    totalCount: number;
    items: PaymentInformationDto[] | undefined;
}

export class UpdateBankDataDto implements IUpdateBankDataDto {
    isNational: boolean;
    countryId: number;
    bankId: number;
    bankAccountTypeId: number;
    accountHolder: string;
    accountNumber: string;
    swiftCode: string | undefined;
    email: string;
    id: string;

    constructor(data?: IUpdateBankDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isNational = _data["isNational"];
            this.countryId = _data["countryId"];
            this.bankId = _data["bankId"];
            this.bankAccountTypeId = _data["bankAccountTypeId"];
            this.accountHolder = _data["accountHolder"];
            this.accountNumber = _data["accountNumber"];
            this.swiftCode = _data["swiftCode"];
            this.email = _data["email"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateBankDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBankDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNational"] = this.isNational;
        data["countryId"] = this.countryId;
        data["bankId"] = this.bankId;
        data["bankAccountTypeId"] = this.bankAccountTypeId;
        data["accountHolder"] = this.accountHolder;
        data["accountNumber"] = this.accountNumber;
        data["swiftCode"] = this.swiftCode;
        data["email"] = this.email;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateBankDataDto {
        const json = this.toJSON();
        let result = new UpdateBankDataDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateBankDataDto {
    isNational: boolean;
    countryId: number;
    bankId: number;
    bankAccountTypeId: number;
    accountHolder: string;
    accountNumber: string;
    swiftCode: string | undefined;
    email: string;
    id: string;
}

export class UpdatePaymentInformationDto implements IUpdatePaymentInformationDto {
    paymentMethodId: number;
    bankData: UpdateBankDataDto;
    supplierFarmIds: string[] | undefined;
    supplierId: string;
    isActive: boolean;
    id: string;

    constructor(data?: IUpdatePaymentInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"];
            this.bankData = _data["bankData"] ? UpdateBankDataDto.fromJS(_data["bankData"]) : <any>undefined;
            if (Array.isArray(_data["supplierFarmIds"])) {
                this.supplierFarmIds = [] as any;
                for (let item of _data["supplierFarmIds"])
                    this.supplierFarmIds.push(item);
            }
            this.supplierId = _data["supplierId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePaymentInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId;
        data["bankData"] = this.bankData ? this.bankData.toJSON() : <any>undefined;
        if (Array.isArray(this.supplierFarmIds)) {
            data["supplierFarmIds"] = [];
            for (let item of this.supplierFarmIds)
                data["supplierFarmIds"].push(item);
        }
        data["supplierId"] = this.supplierId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePaymentInformationDto {
        const json = this.toJSON();
        let result = new UpdatePaymentInformationDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePaymentInformationDto {
    paymentMethodId: number;
    bankData: UpdateBankDataDto;
    supplierFarmIds: string[] | undefined;
    supplierId: string;
    isActive: boolean;
    id: string;
}

export class CreateTagDto implements ICreateTagDto {
    name: string | undefined;
    id: string;

    constructor(data?: ICreateTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateTagDto {
        const json = this.toJSON();
        let result = new CreateTagDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTagDto {
    name: string | undefined;
    id: string;
}

export class TagDtoPagedResultDto implements ITagDtoPagedResultDto {
    totalCount: number;
    items: TagDto[] | undefined;

    constructor(data?: ITagDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TagDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TagDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITagDtoPagedResultDto {
    totalCount: number;
    items: TagDto[] | undefined;
}

export class ApplicationLanguage implements IApplicationLanguage {
    tenantId: number | undefined;
    name: string;
    displayName: string;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IApplicationLanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguage {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): ApplicationLanguage {
        const json = this.toJSON();
        let result = new ApplicationLanguage();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguage {
    tenantId: number | undefined;
    name: string;
    displayName: string;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TenantDataDto implements ITenantDataDto {
    addressId: string;
    address: AddressDto;
    logo: string;
    phone: string;
    applicationLanguage: ApplicationLanguage;
    tenantId: number;
    mainProducts: MainProductDto[] | undefined;
    features: FeatureDto[] | undefined;
    modules: ModuleDto[] | undefined;
    paths: PathDto[] | undefined;
    id: string;

    constructor(data?: ITenantDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressId = _data["addressId"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.logo = _data["logo"];
            this.phone = _data["phone"];
            this.applicationLanguage = _data["applicationLanguage"] ? ApplicationLanguage.fromJS(_data["applicationLanguage"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["mainProducts"])) {
                this.mainProducts = [] as any;
                for (let item of _data["mainProducts"])
                    this.mainProducts.push(MainProductDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features.push(FeatureDto.fromJS(item));
            }
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules.push(ModuleDto.fromJS(item));
            }
            if (Array.isArray(_data["paths"])) {
                this.paths = [] as any;
                for (let item of _data["paths"])
                    this.paths.push(PathDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressId"] = this.addressId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["logo"] = this.logo;
        data["phone"] = this.phone;
        data["applicationLanguage"] = this.applicationLanguage ? this.applicationLanguage.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.mainProducts)) {
            data["mainProducts"] = [];
            for (let item of this.mainProducts)
                data["mainProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        if (Array.isArray(this.paths)) {
            data["paths"] = [];
            for (let item of this.paths)
                data["paths"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): TenantDataDto {
        const json = this.toJSON();
        let result = new TenantDataDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDataDto {
    addressId: string;
    address: AddressDto;
    logo: string;
    phone: string;
    applicationLanguage: ApplicationLanguage;
    tenantId: number;
    mainProducts: MainProductDto[] | undefined;
    features: FeatureDto[] | undefined;
    modules: ModuleDto[] | undefined;
    paths: PathDto[] | undefined;
    id: string;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    tenantData: TenantDataDto;
    companies: number;
    isDeleted: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.tenantData = _data["tenantData"] ? TenantDataDto.fromJS(_data["tenantData"]) : <any>undefined;
            this.companies = _data["companies"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["tenantData"] = this.tenantData ? this.tenantData.toJSON() : <any>undefined;
        data["companies"] = this.companies;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    tenantData: TenantDataDto;
    companies: number;
    isDeleted: boolean;
    id: number;
}

export class CreateTenantDataDto implements ICreateTenantDataDto {
    address: CreateAddressDto;
    fileLogo: FileDto;
    phone: string;
    applicationLanguageName: string | undefined;
    tenantId: number;
    mainProductsId: number[] | undefined;
    featuresId: string[] | undefined;
    modulesId: string[] | undefined;
    pathsId: string[] | undefined;
    id: string;

    constructor(data?: ICreateTenantDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"] ? CreateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.fileLogo = _data["fileLogo"] ? FileDto.fromJS(_data["fileLogo"]) : <any>undefined;
            this.phone = _data["phone"];
            this.applicationLanguageName = _data["applicationLanguageName"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["mainProductsId"])) {
                this.mainProductsId = [] as any;
                for (let item of _data["mainProductsId"])
                    this.mainProductsId.push(item);
            }
            if (Array.isArray(_data["featuresId"])) {
                this.featuresId = [] as any;
                for (let item of _data["featuresId"])
                    this.featuresId.push(item);
            }
            if (Array.isArray(_data["modulesId"])) {
                this.modulesId = [] as any;
                for (let item of _data["modulesId"])
                    this.modulesId.push(item);
            }
            if (Array.isArray(_data["pathsId"])) {
                this.pathsId = [] as any;
                for (let item of _data["pathsId"])
                    this.pathsId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateTenantDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["fileLogo"] = this.fileLogo ? this.fileLogo.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["applicationLanguageName"] = this.applicationLanguageName;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.mainProductsId)) {
            data["mainProductsId"] = [];
            for (let item of this.mainProductsId)
                data["mainProductsId"].push(item);
        }
        if (Array.isArray(this.featuresId)) {
            data["featuresId"] = [];
            for (let item of this.featuresId)
                data["featuresId"].push(item);
        }
        if (Array.isArray(this.modulesId)) {
            data["modulesId"] = [];
            for (let item of this.modulesId)
                data["modulesId"].push(item);
        }
        if (Array.isArray(this.pathsId)) {
            data["pathsId"] = [];
            for (let item of this.pathsId)
                data["pathsId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): CreateTenantDataDto {
        const json = this.toJSON();
        let result = new CreateTenantDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDataDto {
    address: CreateAddressDto;
    fileLogo: FileDto;
    phone: string;
    applicationLanguageName: string | undefined;
    tenantId: number;
    mainProductsId: number[] | undefined;
    featuresId: string[] | undefined;
    modulesId: string[] | undefined;
    pathsId: string[] | undefined;
    id: string;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    tenantData: CreateTenantDataDto;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tenantData = new CreateTenantDataDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.tenantData = _data["tenantData"] ? CreateTenantDataDto.fromJS(_data["tenantData"]) : new CreateTenantDataDto();
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["tenantData"] = this.tenantData ? this.tenantData.toJSON() : <any>undefined;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    tenantData: CreateTenantDataDto;
    connectionString: string | undefined;
    isActive: boolean;
}

export class UpdateTenantDataDto implements IUpdateTenantDataDto {
    address: UpdateAddressDto;
    addressId: string;
    fileLogo: FileDto;
    phone: string;
    applicationLanguageName: string | undefined;
    mainProductsId: number[] | undefined;
    featuresId: string[] | undefined;
    modulesId: string[] | undefined;
    pathsId: string[] | undefined;
    tenantId: number;
    id: string;

    constructor(data?: IUpdateTenantDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"] ? UpdateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.addressId = _data["addressId"];
            this.fileLogo = _data["fileLogo"] ? FileDto.fromJS(_data["fileLogo"]) : <any>undefined;
            this.phone = _data["phone"];
            this.applicationLanguageName = _data["applicationLanguageName"];
            if (Array.isArray(_data["mainProductsId"])) {
                this.mainProductsId = [] as any;
                for (let item of _data["mainProductsId"])
                    this.mainProductsId.push(item);
            }
            if (Array.isArray(_data["featuresId"])) {
                this.featuresId = [] as any;
                for (let item of _data["featuresId"])
                    this.featuresId.push(item);
            }
            if (Array.isArray(_data["modulesId"])) {
                this.modulesId = [] as any;
                for (let item of _data["modulesId"])
                    this.modulesId.push(item);
            }
            if (Array.isArray(_data["pathsId"])) {
                this.pathsId = [] as any;
                for (let item of _data["pathsId"])
                    this.pathsId.push(item);
            }
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateTenantDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["addressId"] = this.addressId;
        data["fileLogo"] = this.fileLogo ? this.fileLogo.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["applicationLanguageName"] = this.applicationLanguageName;
        if (Array.isArray(this.mainProductsId)) {
            data["mainProductsId"] = [];
            for (let item of this.mainProductsId)
                data["mainProductsId"].push(item);
        }
        if (Array.isArray(this.featuresId)) {
            data["featuresId"] = [];
            for (let item of this.featuresId)
                data["featuresId"].push(item);
        }
        if (Array.isArray(this.modulesId)) {
            data["modulesId"] = [];
            for (let item of this.modulesId)
                data["modulesId"].push(item);
        }
        if (Array.isArray(this.pathsId)) {
            data["pathsId"] = [];
            for (let item of this.pathsId)
                data["pathsId"].push(item);
        }
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateTenantDataDto {
        const json = this.toJSON();
        let result = new UpdateTenantDataDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantDataDto {
    address: UpdateAddressDto;
    addressId: string;
    fileLogo: FileDto;
    phone: string;
    applicationLanguageName: string | undefined;
    mainProductsId: number[] | undefined;
    featuresId: string[] | undefined;
    modulesId: string[] | undefined;
    pathsId: string[] | undefined;
    tenantId: number;
    id: string;
}

export class UpdateTenantDto implements IUpdateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    tenantData: UpdateTenantDataDto;
    connectionString: string | undefined;
    isActive: boolean;
    id: number;

    constructor(data?: IUpdateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tenantData = new UpdateTenantDataDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.tenantData = _data["tenantData"] ? UpdateTenantDataDto.fromJS(_data["tenantData"]) : new UpdateTenantDataDto();
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["tenantData"] = this.tenantData ? this.tenantData.toJSON() : <any>undefined;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateTenantDto {
        const json = this.toJSON();
        let result = new UpdateTenantDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    tenantData: UpdateTenantDataDto;
    connectionString: string | undefined;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class UpdateTenantFeaturesDto implements IUpdateTenantFeaturesDto {
    featuresId: string[] | undefined;
    modulesId: string[] | undefined;
    pathsId: string[] | undefined;
    id: string;

    constructor(data?: IUpdateTenantFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featuresId"])) {
                this.featuresId = [] as any;
                for (let item of _data["featuresId"])
                    this.featuresId.push(item);
            }
            if (Array.isArray(_data["modulesId"])) {
                this.modulesId = [] as any;
                for (let item of _data["modulesId"])
                    this.modulesId.push(item);
            }
            if (Array.isArray(_data["pathsId"])) {
                this.pathsId = [] as any;
                for (let item of _data["pathsId"])
                    this.pathsId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featuresId)) {
            data["featuresId"] = [];
            for (let item of this.featuresId)
                data["featuresId"].push(item);
        }
        if (Array.isArray(this.modulesId)) {
            data["modulesId"] = [];
            for (let item of this.modulesId)
                data["modulesId"].push(item);
        }
        if (Array.isArray(this.pathsId)) {
            data["pathsId"] = [];
            for (let item of this.pathsId)
                data["pathsId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateTenantFeaturesDto {
        const json = this.toJSON();
        let result = new UpdateTenantFeaturesDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantFeaturesDto {
    featuresId: string[] | undefined;
    modulesId: string[] | undefined;
    pathsId: string[] | undefined;
    id: string;
}

export class TenantFilterDto implements ITenantFilterDto {
    tenancyName: string | undefined;
    id: number;

    constructor(data?: ITenantFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantFilterDto {
        const json = this.toJSON();
        let result = new TenantFilterDto();
        result.init(json);
        return result;
    }
}

export interface ITenantFilterDto {
    tenancyName: string | undefined;
    id: number;
}

export class TenantFilterDtoPagedResultDto implements ITenantFilterDtoPagedResultDto {
    totalCount: number;
    items: TenantFilterDto[] | undefined;

    constructor(data?: ITenantFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TenantFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantFilterDtoPagedResultDto {
    totalCount: number;
    items: TenantFilterDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    isWeb: boolean;
    clientName: string;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.isWeb = _data["isWeb"];
            this.clientName = _data["clientName"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["isWeb"] = this.isWeb;
        data["clientName"] = this.clientName;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    isWeb: boolean;
    clientName: string;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class TransportDtoPagedResultDto implements ITransportDtoPagedResultDto {
    totalCount: number;
    items: TransportDto[] | undefined;

    constructor(data?: ITransportDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TransportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TransportDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITransportDtoPagedResultDto {
    totalCount: number;
    items: TransportDto[] | undefined;
}

export class CreateTransportDto implements ICreateTransportDto {
    name: string;
    description: string | undefined;
    plateNumber: string;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    transportTypeId: number;
    transportClassificationId: number;
    companyId: string;
    farmsId: string[] | undefined;

    constructor(data?: ICreateTransportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.plateNumber = _data["plateNumber"];
            this.driverName = _data["driverName"];
            this.driverIdNumber = _data["driverIdNumber"];
            this.transportTypeId = _data["transportTypeId"];
            this.transportClassificationId = _data["transportClassificationId"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
        }
    }

    static fromJS(data: any): CreateTransportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["plateNumber"] = this.plateNumber;
        data["driverName"] = this.driverName;
        data["driverIdNumber"] = this.driverIdNumber;
        data["transportTypeId"] = this.transportTypeId;
        data["transportClassificationId"] = this.transportClassificationId;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        return data;
    }

    clone(): CreateTransportDto {
        const json = this.toJSON();
        let result = new CreateTransportDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTransportDto {
    name: string;
    description: string | undefined;
    plateNumber: string;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    transportTypeId: number;
    transportClassificationId: number;
    companyId: string;
    farmsId: string[] | undefined;
}

export class UpdateTransportDto implements IUpdateTransportDto {
    name: string;
    description: string | undefined;
    plateNumber: string;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    transportTypeId: number;
    transportClassificationId: number;
    companyId: string;
    farmsId: string[] | undefined;
    id: string;

    constructor(data?: IUpdateTransportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.plateNumber = _data["plateNumber"];
            this.driverName = _data["driverName"];
            this.driverIdNumber = _data["driverIdNumber"];
            this.transportTypeId = _data["transportTypeId"];
            this.transportClassificationId = _data["transportClassificationId"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateTransportDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["plateNumber"] = this.plateNumber;
        data["driverName"] = this.driverName;
        data["driverIdNumber"] = this.driverIdNumber;
        data["transportTypeId"] = this.transportTypeId;
        data["transportClassificationId"] = this.transportClassificationId;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateTransportDto {
        const json = this.toJSON();
        let result = new UpdateTransportDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTransportDto {
    name: string;
    description: string | undefined;
    plateNumber: string;
    driverName: string | undefined;
    driverIdNumber: string | undefined;
    transportTypeId: number;
    transportClassificationId: number;
    companyId: string;
    farmsId: string[] | undefined;
    id: string;
}

export class TransportClassificationDtoPagedResultDto implements ITransportClassificationDtoPagedResultDto {
    totalCount: number;
    items: TransportClassificationDto[] | undefined;

    constructor(data?: ITransportClassificationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TransportClassificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportClassificationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportClassificationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportClassificationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TransportClassificationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITransportClassificationDtoPagedResultDto {
    totalCount: number;
    items: TransportClassificationDto[] | undefined;
}

export class TransportTypeDtoPagedResultDto implements ITransportTypeDtoPagedResultDto {
    totalCount: number;
    items: TransportTypeDto[] | undefined;

    constructor(data?: ITransportTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TransportTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransportTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TransportTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TransportTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITransportTypeDtoPagedResultDto {
    totalCount: number;
    items: TransportTypeDto[] | undefined;
}

export class CreateSignatureInfoDto implements ICreateSignatureInfoDto {
    frontImage: FileDto;
    backImage: FileDto;
    signatureImage: FileDto;
    workerId: string | undefined;
    userId: number | undefined;

    constructor(data?: ICreateSignatureInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.frontImage = _data["frontImage"] ? FileDto.fromJS(_data["frontImage"]) : <any>undefined;
            this.backImage = _data["backImage"] ? FileDto.fromJS(_data["backImage"]) : <any>undefined;
            this.signatureImage = _data["signatureImage"] ? FileDto.fromJS(_data["signatureImage"]) : <any>undefined;
            this.workerId = _data["workerId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreateSignatureInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSignatureInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frontImage"] = this.frontImage ? this.frontImage.toJSON() : <any>undefined;
        data["backImage"] = this.backImage ? this.backImage.toJSON() : <any>undefined;
        data["signatureImage"] = this.signatureImage ? this.signatureImage.toJSON() : <any>undefined;
        data["workerId"] = this.workerId;
        data["userId"] = this.userId;
        return data;
    }

    clone(): CreateSignatureInfoDto {
        const json = this.toJSON();
        let result = new CreateSignatureInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSignatureInfoDto {
    frontImage: FileDto;
    backImage: FileDto;
    signatureImage: FileDto;
    workerId: string | undefined;
    userId: number | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    filePhoto: FileDto;
    mainProductsId: number[] | undefined;
    appProductsId: number[] | undefined;
    companiesId: string[] | undefined;
    farmsId: string[] | undefined;
    languageName: string;
    signatureInfo: CreateSignatureInfoDto;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.filePhoto = _data["filePhoto"] ? FileDto.fromJS(_data["filePhoto"]) : <any>undefined;
            if (Array.isArray(_data["mainProductsId"])) {
                this.mainProductsId = [] as any;
                for (let item of _data["mainProductsId"])
                    this.mainProductsId.push(item);
            }
            if (Array.isArray(_data["appProductsId"])) {
                this.appProductsId = [] as any;
                for (let item of _data["appProductsId"])
                    this.appProductsId.push(item);
            }
            if (Array.isArray(_data["companiesId"])) {
                this.companiesId = [] as any;
                for (let item of _data["companiesId"])
                    this.companiesId.push(item);
            }
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            this.languageName = _data["languageName"];
            this.signatureInfo = _data["signatureInfo"] ? CreateSignatureInfoDto.fromJS(_data["signatureInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["filePhoto"] = this.filePhoto ? this.filePhoto.toJSON() : <any>undefined;
        if (Array.isArray(this.mainProductsId)) {
            data["mainProductsId"] = [];
            for (let item of this.mainProductsId)
                data["mainProductsId"].push(item);
        }
        if (Array.isArray(this.appProductsId)) {
            data["appProductsId"] = [];
            for (let item of this.appProductsId)
                data["appProductsId"].push(item);
        }
        if (Array.isArray(this.companiesId)) {
            data["companiesId"] = [];
            for (let item of this.companiesId)
                data["companiesId"].push(item);
        }
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        data["languageName"] = this.languageName;
        data["signatureInfo"] = this.signatureInfo ? this.signatureInfo.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    filePhoto: FileDto;
    mainProductsId: number[] | undefined;
    appProductsId: number[] | undefined;
    companiesId: string[] | undefined;
    farmsId: string[] | undefined;
    languageName: string;
    signatureInfo: CreateSignatureInfoDto;
}

export class UpdateUserDto implements IUpdateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    mainProductsId: number[] | undefined;
    appProductsId: number[] | undefined;
    companyId: string | undefined;
    companiesId: string[] | undefined;
    farmsId: string[] | undefined;
    filePhoto: FileDto;
    signatureInfo: SignatureInfoDto;
    id: number;

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            if (Array.isArray(_data["mainProductsId"])) {
                this.mainProductsId = [] as any;
                for (let item of _data["mainProductsId"])
                    this.mainProductsId.push(item);
            }
            if (Array.isArray(_data["appProductsId"])) {
                this.appProductsId = [] as any;
                for (let item of _data["appProductsId"])
                    this.appProductsId.push(item);
            }
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["companiesId"])) {
                this.companiesId = [] as any;
                for (let item of _data["companiesId"])
                    this.companiesId.push(item);
            }
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            this.filePhoto = _data["filePhoto"] ? FileDto.fromJS(_data["filePhoto"]) : <any>undefined;
            this.signatureInfo = _data["signatureInfo"] ? SignatureInfoDto.fromJS(_data["signatureInfo"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.mainProductsId)) {
            data["mainProductsId"] = [];
            for (let item of this.mainProductsId)
                data["mainProductsId"].push(item);
        }
        if (Array.isArray(this.appProductsId)) {
            data["appProductsId"] = [];
            for (let item of this.appProductsId)
                data["appProductsId"].push(item);
        }
        data["companyId"] = this.companyId;
        if (Array.isArray(this.companiesId)) {
            data["companiesId"] = [];
            for (let item of this.companiesId)
                data["companiesId"].push(item);
        }
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        data["filePhoto"] = this.filePhoto ? this.filePhoto.toJSON() : <any>undefined;
        data["signatureInfo"] = this.signatureInfo ? this.signatureInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateUserDto {
        const json = this.toJSON();
        let result = new UpdateUserDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    mainProductsId: number[] | undefined;
    appProductsId: number[] | undefined;
    companyId: string | undefined;
    companiesId: string[] | undefined;
    farmsId: string[] | undefined;
    filePhoto: FileDto;
    signatureInfo: SignatureInfoDto;
    id: number;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class ValidateEmailDto implements IValidateEmailDto {
    email: string;

    constructor(data?: IValidateEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ValidateEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }

    clone(): ValidateEmailDto {
        const json = this.toJSON();
        let result = new ValidateEmailDto();
        result.init(json);
        return result;
    }
}

export interface IValidateEmailDto {
    email: string;
}

export class ValidatePasswordDto implements IValidatePasswordDto {
    password: string;

    constructor(data?: IValidatePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ValidatePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        return data;
    }

    clone(): ValidatePasswordDto {
        const json = this.toJSON();
        let result = new ValidatePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IValidatePasswordDto {
    password: string;
}

export class ResetUserPasswordDto implements IResetUserPasswordDto {
    userId: number;
    newPassword: string;
    passwordResetCode: string;

    constructor(data?: IResetUserPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
        }
    }

    static fromJS(data: any): ResetUserPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetUserPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        return data;
    }

    clone(): ResetUserPasswordDto {
        const json = this.toJSON();
        let result = new ResetUserPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetUserPasswordDto {
    userId: number;
    newPassword: string;
    passwordResetCode: string;
}

export class UserMainInfoDto implements IUserMainInfoDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    languageName: string | undefined;
    id: number;

    constructor(data?: IUserMainInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.languageName = _data["languageName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserMainInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserMainInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["languageName"] = this.languageName;
        data["id"] = this.id;
        return data;
    }

    clone(): UserMainInfoDto {
        const json = this.toJSON();
        let result = new UserMainInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserMainInfoDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    languageName: string | undefined;
    id: number;
}

export class UserRolesDto implements IUserRolesDto {
    roleNames: string[] | undefined;
    id: number;

    constructor(data?: IUserRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UserRolesDto {
        const json = this.toJSON();
        let result = new UserRolesDto();
        result.init(json);
        return result;
    }
}

export interface IUserRolesDto {
    roleNames: string[] | undefined;
    id: number;
}

export class UserPhotoDto implements IUserPhotoDto {
    photography: string | undefined;
    filePhoto: FileDto;
    id: number;

    constructor(data?: IUserPhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.photography = _data["photography"];
            this.filePhoto = _data["filePhoto"] ? FileDto.fromJS(_data["filePhoto"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPhotoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photography"] = this.photography;
        data["filePhoto"] = this.filePhoto ? this.filePhoto.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UserPhotoDto {
        const json = this.toJSON();
        let result = new UserPhotoDto();
        result.init(json);
        return result;
    }
}

export interface IUserPhotoDto {
    photography: string | undefined;
    filePhoto: FileDto;
    id: number;
}

export class UserProductsDto implements IUserProductsDto {
    mainProducts: MainProductDto[] | undefined;
    appProducts: AppProductDto[] | undefined;
    mainProductsId: number[] | undefined;
    appProductsId: number[] | undefined;
    id: number;

    constructor(data?: IUserProductsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["mainProducts"])) {
                this.mainProducts = [] as any;
                for (let item of _data["mainProducts"])
                    this.mainProducts.push(MainProductDto.fromJS(item));
            }
            if (Array.isArray(_data["appProducts"])) {
                this.appProducts = [] as any;
                for (let item of _data["appProducts"])
                    this.appProducts.push(AppProductDto.fromJS(item));
            }
            if (Array.isArray(_data["mainProductsId"])) {
                this.mainProductsId = [] as any;
                for (let item of _data["mainProductsId"])
                    this.mainProductsId.push(item);
            }
            if (Array.isArray(_data["appProductsId"])) {
                this.appProductsId = [] as any;
                for (let item of _data["appProductsId"])
                    this.appProductsId.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserProductsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProductsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.mainProducts)) {
            data["mainProducts"] = [];
            for (let item of this.mainProducts)
                data["mainProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.appProducts)) {
            data["appProducts"] = [];
            for (let item of this.appProducts)
                data["appProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.mainProductsId)) {
            data["mainProductsId"] = [];
            for (let item of this.mainProductsId)
                data["mainProductsId"].push(item);
        }
        if (Array.isArray(this.appProductsId)) {
            data["appProductsId"] = [];
            for (let item of this.appProductsId)
                data["appProductsId"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UserProductsDto {
        const json = this.toJSON();
        let result = new UserProductsDto();
        result.init(json);
        return result;
    }
}

export interface IUserProductsDto {
    mainProducts: MainProductDto[] | undefined;
    appProducts: AppProductDto[] | undefined;
    mainProductsId: number[] | undefined;
    appProductsId: number[] | undefined;
    id: number;
}

export class UserAllowedResourcesDto implements IUserAllowedResourcesDto {
    companiesId: string[] | undefined;
    farmsId: string[] | undefined;
    companies: CompanyUserDto[] | undefined;
    farms: FarmDto[] | undefined;
    id: number;

    constructor(data?: IUserAllowedResourcesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["companiesId"])) {
                this.companiesId = [] as any;
                for (let item of _data["companiesId"])
                    this.companiesId.push(item);
            }
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies.push(CompanyUserDto.fromJS(item));
            }
            if (Array.isArray(_data["farms"])) {
                this.farms = [] as any;
                for (let item of _data["farms"])
                    this.farms.push(FarmDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserAllowedResourcesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAllowedResourcesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.companiesId)) {
            data["companiesId"] = [];
            for (let item of this.companiesId)
                data["companiesId"].push(item);
        }
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item.toJSON());
        }
        if (Array.isArray(this.farms)) {
            data["farms"] = [];
            for (let item of this.farms)
                data["farms"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UserAllowedResourcesDto {
        const json = this.toJSON();
        let result = new UserAllowedResourcesDto();
        result.init(json);
        return result;
    }
}

export interface IUserAllowedResourcesDto {
    companiesId: string[] | undefined;
    farmsId: string[] | undefined;
    companies: CompanyUserDto[] | undefined;
    farms: FarmDto[] | undefined;
    id: number;
}

export class UserFilterDto implements IUserFilterDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    id: number;

    constructor(data?: IUserFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data;
    }

    clone(): UserFilterDto {
        const json = this.toJSON();
        let result = new UserFilterDto();
        result.init(json);
        return result;
    }
}

export interface IUserFilterDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    id: number;
}

export class UserFilterDtoPagedResultDto implements IUserFilterDtoPagedResultDto {
    totalCount: number;
    items: UserFilterDto[] | undefined;

    constructor(data?: IUserFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserFilterDtoPagedResultDto {
    totalCount: number;
    items: UserFilterDto[] | undefined;
}

export class CreateVarietyDto implements ICreateVarietyDto {
    name: string | undefined;
    businessName: string | undefined;
    tagsArray: string[] | undefined;
    speciesId: number;
    id: number;

    constructor(data?: ICreateVarietyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            if (Array.isArray(_data["tagsArray"])) {
                this.tagsArray = [] as any;
                for (let item of _data["tagsArray"])
                    this.tagsArray.push(item);
            }
            this.speciesId = _data["speciesId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateVarietyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVarietyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        if (Array.isArray(this.tagsArray)) {
            data["tagsArray"] = [];
            for (let item of this.tagsArray)
                data["tagsArray"].push(item);
        }
        data["speciesId"] = this.speciesId;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateVarietyDto {
        const json = this.toJSON();
        let result = new CreateVarietyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateVarietyDto {
    name: string | undefined;
    businessName: string | undefined;
    tagsArray: string[] | undefined;
    speciesId: number;
    id: number;
}

export class UpdateVarietyDto implements IUpdateVarietyDto {
    name: string | undefined;
    businessName: string | undefined;
    speciesId: number;
    tags: TagDto[] | undefined;
    id: number;

    constructor(data?: IUpdateVarietyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.businessName = _data["businessName"];
            this.speciesId = _data["speciesId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags.push(TagDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateVarietyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVarietyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["businessName"] = this.businessName;
        data["speciesId"] = this.speciesId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateVarietyDto {
        const json = this.toJSON();
        let result = new UpdateVarietyDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateVarietyDto {
    name: string | undefined;
    businessName: string | undefined;
    speciesId: number;
    tags: TagDto[] | undefined;
    id: number;
}

export class VarietyDtoPagedResultDto implements IVarietyDtoPagedResultDto {
    totalCount: number;
    items: VarietyDto[] | undefined;

    constructor(data?: IVarietyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(VarietyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VarietyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VarietyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): VarietyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new VarietyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IVarietyDtoPagedResultDto {
    totalCount: number;
    items: VarietyDto[] | undefined;
}

export class CreateVoluntaryRetirementSavingDto implements ICreateVoluntaryRetirementSavingDto {
    paymentConceptId: number;
    institutionTypeId: number;
    retirementInstitutionId: number;
    paymentMethodId: number;
    taxReduction: boolean;
    paymentTypeId: number;
    docNumber: string | undefined;
    amount: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    workerId: string;

    constructor(data?: ICreateVoluntaryRetirementSavingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentConceptId = _data["paymentConceptId"];
            this.institutionTypeId = _data["institutionTypeId"];
            this.retirementInstitutionId = _data["retirementInstitutionId"];
            this.paymentMethodId = _data["paymentMethodId"];
            this.taxReduction = _data["taxReduction"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.docNumber = _data["docNumber"];
            this.amount = _data["amount"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.workerId = _data["workerId"];
        }
    }

    static fromJS(data: any): CreateVoluntaryRetirementSavingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVoluntaryRetirementSavingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentConceptId"] = this.paymentConceptId;
        data["institutionTypeId"] = this.institutionTypeId;
        data["retirementInstitutionId"] = this.retirementInstitutionId;
        data["paymentMethodId"] = this.paymentMethodId;
        data["taxReduction"] = this.taxReduction;
        data["paymentTypeId"] = this.paymentTypeId;
        data["docNumber"] = this.docNumber;
        data["amount"] = this.amount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["workerId"] = this.workerId;
        return data;
    }

    clone(): CreateVoluntaryRetirementSavingDto {
        const json = this.toJSON();
        let result = new CreateVoluntaryRetirementSavingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateVoluntaryRetirementSavingDto {
    paymentConceptId: number;
    institutionTypeId: number;
    retirementInstitutionId: number;
    paymentMethodId: number;
    taxReduction: boolean;
    paymentTypeId: number;
    docNumber: string | undefined;
    amount: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    workerId: string;
}

export class VoluntaryRetirementSavingDtoPagedResultDto implements IVoluntaryRetirementSavingDtoPagedResultDto {
    totalCount: number;
    items: VoluntaryRetirementSavingDto[] | undefined;

    constructor(data?: IVoluntaryRetirementSavingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(VoluntaryRetirementSavingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VoluntaryRetirementSavingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VoluntaryRetirementSavingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): VoluntaryRetirementSavingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new VoluntaryRetirementSavingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IVoluntaryRetirementSavingDtoPagedResultDto {
    totalCount: number;
    items: VoluntaryRetirementSavingDto[] | undefined;
}

export class CreateWarehouseDto implements ICreateWarehouseDto {
    name: string | undefined;
    code: string | undefined;
    dimension: number;
    characteristies: string | undefined;
    description: string | undefined;
    isActive: boolean;
    farmId: string;
    address: CreateAddressDto;
    id: string;

    constructor(data?: ICreateWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.dimension = _data["dimension"];
            this.characteristies = _data["characteristies"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.farmId = _data["farmId"];
            this.address = _data["address"] ? CreateAddressDto.fromJS(_data["address"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateWarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["dimension"] = this.dimension;
        data["characteristies"] = this.characteristies;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["farmId"] = this.farmId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateWarehouseDto {
        const json = this.toJSON();
        let result = new CreateWarehouseDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWarehouseDto {
    name: string | undefined;
    code: string | undefined;
    dimension: number;
    characteristies: string | undefined;
    description: string | undefined;
    isActive: boolean;
    farmId: string;
    address: CreateAddressDto;
    id: string;
}

export class WarehouseDto implements IWarehouseDto {
    name: string | undefined;
    code: string | undefined;
    dimension: number;
    characteristies: string | undefined;
    description: string | undefined;
    isActive: boolean;
    farmId: string;
    address: AddressDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: IWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.dimension = _data["dimension"];
            this.characteristies = _data["characteristies"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.farmId = _data["farmId"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["dimension"] = this.dimension;
        data["characteristies"] = this.characteristies;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["farmId"] = this.farmId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): WarehouseDto {
        const json = this.toJSON();
        let result = new WarehouseDto();
        result.init(json);
        return result;
    }
}

export interface IWarehouseDto {
    name: string | undefined;
    code: string | undefined;
    dimension: number;
    characteristies: string | undefined;
    description: string | undefined;
    isActive: boolean;
    farmId: string;
    address: AddressDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class UpdateWarehouseDto implements IUpdateWarehouseDto {
    name: string | undefined;
    dimension: number;
    characteristies: string | undefined;
    description: string | undefined;
    farmId: string;
    isActive: boolean;
    id: string;

    constructor(data?: IUpdateWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dimension = _data["dimension"];
            this.characteristies = _data["characteristies"];
            this.description = _data["description"];
            this.farmId = _data["farmId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dimension"] = this.dimension;
        data["characteristies"] = this.characteristies;
        data["description"] = this.description;
        data["farmId"] = this.farmId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWarehouseDto {
        const json = this.toJSON();
        let result = new UpdateWarehouseDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWarehouseDto {
    name: string | undefined;
    dimension: number;
    characteristies: string | undefined;
    description: string | undefined;
    farmId: string;
    isActive: boolean;
    id: string;
}

export class UpdateWarehouseAddres implements IUpdateWarehouseAddres {
    addres: UpdateAddressDto;
    id: string;

    constructor(data?: IUpdateWarehouseAddres) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addres = _data["addres"] ? UpdateAddressDto.fromJS(_data["addres"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWarehouseAddres {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWarehouseAddres();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addres"] = this.addres ? this.addres.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWarehouseAddres {
        const json = this.toJSON();
        let result = new UpdateWarehouseAddres();
        result.init(json);
        return result;
    }
}

export interface IUpdateWarehouseAddres {
    addres: UpdateAddressDto;
    id: string;
}

export class WarehouseDtoPagedResultDto implements IWarehouseDtoPagedResultDto {
    totalCount: number;
    items: WarehouseDto[] | undefined;

    constructor(data?: IWarehouseDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WarehouseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WarehouseDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WarehouseDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WarehouseDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWarehouseDtoPagedResultDto {
    totalCount: number;
    items: WarehouseDto[] | undefined;
}

export class PagedWarehouseResultRequestDto implements IPagedWarehouseResultRequestDto {
    keyword: string | undefined;
    isActive: boolean | undefined;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IPagedWarehouseResultRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.isActive = _data["isActive"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagedWarehouseResultRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedWarehouseResultRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["isActive"] = this.isActive;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }

    clone(): PagedWarehouseResultRequestDto {
        const json = this.toJSON();
        let result = new PagedWarehouseResultRequestDto();
        result.init(json);
        return result;
    }
}

export interface IPagedWarehouseResultRequestDto {
    keyword: string | undefined;
    isActive: boolean | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class SimpleWarehouseDto implements ISimpleWarehouseDto {
    name: string | undefined;
    code: string | undefined;
    dimension: number;
    farmId: string;
    address: AddressDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;

    constructor(data?: ISimpleWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.dimension = _data["dimension"];
            this.farmId = _data["farmId"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SimpleWarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleWarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["dimension"] = this.dimension;
        data["farmId"] = this.farmId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }

    clone(): SimpleWarehouseDto {
        const json = this.toJSON();
        let result = new SimpleWarehouseDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleWarehouseDto {
    name: string | undefined;
    code: string | undefined;
    dimension: number;
    farmId: string;
    address: AddressDto;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class SimpleWarehouseDtoPagedResultDto implements ISimpleWarehouseDtoPagedResultDto {
    totalCount: number;
    items: SimpleWarehouseDto[] | undefined;

    constructor(data?: ISimpleWarehouseDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SimpleWarehouseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SimpleWarehouseDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleWarehouseDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SimpleWarehouseDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SimpleWarehouseDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleWarehouseDtoPagedResultDto {
    totalCount: number;
    items: SimpleWarehouseDto[] | undefined;
}

export class CreateWayPayAccountTypeDto implements ICreateWayPayAccountTypeDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: ICreateWayPayAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.localizationKey = _data["localizationKey"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateWayPayAccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWayPayAccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["localizationKey"] = this.localizationKey;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): CreateWayPayAccountTypeDto {
        const json = this.toJSON();
        let result = new CreateWayPayAccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWayPayAccountTypeDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class WayPayDto implements IWayPayDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IWayPayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.localizationKey = _data["localizationKey"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WayPayDto {
        data = typeof data === 'object' ? data : {};
        let result = new WayPayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["localizationKey"] = this.localizationKey;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): WayPayDto {
        const json = this.toJSON();
        let result = new WayPayDto();
        result.init(json);
        return result;
    }
}

export interface IWayPayDto {
    name: string | undefined;
    localizationKey: string | undefined;
    isDeleted: boolean;
    id: number;
}

export class WayPayDtoPagedResultDto implements IWayPayDtoPagedResultDto {
    totalCount: number;
    items: WayPayDto[] | undefined;

    constructor(data?: IWayPayDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WayPayDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WayPayDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WayPayDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WayPayDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WayPayDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWayPayDtoPagedResultDto {
    totalCount: number;
    items: WayPayDto[] | undefined;
}

export class CreateWorkDayInfoDto implements ICreateWorkDayInfoDto {
    weekDayId: number;
    workShiftsId: string[] | undefined;

    constructor(data?: ICreateWorkDayInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weekDayId = _data["weekDayId"];
            if (Array.isArray(_data["workShiftsId"])) {
                this.workShiftsId = [] as any;
                for (let item of _data["workShiftsId"])
                    this.workShiftsId.push(item);
            }
        }
    }

    static fromJS(data: any): CreateWorkDayInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkDayInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weekDayId"] = this.weekDayId;
        if (Array.isArray(this.workShiftsId)) {
            data["workShiftsId"] = [];
            for (let item of this.workShiftsId)
                data["workShiftsId"].push(item);
        }
        return data;
    }

    clone(): CreateWorkDayInfoDto {
        const json = this.toJSON();
        let result = new CreateWorkDayInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkDayInfoDto {
    weekDayId: number;
    workShiftsId: string[] | undefined;
}

export class CreateWorkDayDto implements ICreateWorkDayDto {
    name: string;
    description: string | undefined;
    startTolerance: number;
    endTolerance: number;
    workDayTypeId: number;
    compensateOverTime: boolean;
    overTime: boolean;
    workDayRoundTypeId: number | undefined;
    workDayInfos: CreateWorkDayInfoDto[] | undefined;
    farmId: string;
    daysOff: number[] | undefined;

    constructor(data?: ICreateWorkDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.startTolerance = _data["startTolerance"];
            this.endTolerance = _data["endTolerance"];
            this.workDayTypeId = _data["workDayTypeId"];
            this.compensateOverTime = _data["compensateOverTime"];
            this.overTime = _data["overTime"];
            this.workDayRoundTypeId = _data["workDayRoundTypeId"];
            if (Array.isArray(_data["workDayInfos"])) {
                this.workDayInfos = [] as any;
                for (let item of _data["workDayInfos"])
                    this.workDayInfos.push(CreateWorkDayInfoDto.fromJS(item));
            }
            this.farmId = _data["farmId"];
            if (Array.isArray(_data["daysOff"])) {
                this.daysOff = [] as any;
                for (let item of _data["daysOff"])
                    this.daysOff.push(item);
            }
        }
    }

    static fromJS(data: any): CreateWorkDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startTolerance"] = this.startTolerance;
        data["endTolerance"] = this.endTolerance;
        data["workDayTypeId"] = this.workDayTypeId;
        data["compensateOverTime"] = this.compensateOverTime;
        data["overTime"] = this.overTime;
        data["workDayRoundTypeId"] = this.workDayRoundTypeId;
        if (Array.isArray(this.workDayInfos)) {
            data["workDayInfos"] = [];
            for (let item of this.workDayInfos)
                data["workDayInfos"].push(item.toJSON());
        }
        data["farmId"] = this.farmId;
        if (Array.isArray(this.daysOff)) {
            data["daysOff"] = [];
            for (let item of this.daysOff)
                data["daysOff"].push(item);
        }
        return data;
    }

    clone(): CreateWorkDayDto {
        const json = this.toJSON();
        let result = new CreateWorkDayDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkDayDto {
    name: string;
    description: string | undefined;
    startTolerance: number;
    endTolerance: number;
    workDayTypeId: number;
    compensateOverTime: boolean;
    overTime: boolean;
    workDayRoundTypeId: number | undefined;
    workDayInfos: CreateWorkDayInfoDto[] | undefined;
    farmId: string;
    daysOff: number[] | undefined;
}

export class WorkDayDtoPagedResultDto implements IWorkDayDtoPagedResultDto {
    totalCount: number;
    items: WorkDayDto[] | undefined;

    constructor(data?: IWorkDayDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkDayDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkDayDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkDayDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkDayDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayDtoPagedResultDto {
    totalCount: number;
    items: WorkDayDto[] | undefined;
}

export class UpdateWorkDayDto implements IUpdateWorkDayDto {
    name: string;
    description: string | undefined;
    startTolerance: number;
    endTolerance: number;
    workDayTypeId: number;
    compensateOverTime: boolean;
    overTime: boolean;
    workDayRoundTypeId: number | undefined;
    daysOff: number[] | undefined;
    id: string;

    constructor(data?: IUpdateWorkDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.startTolerance = _data["startTolerance"];
            this.endTolerance = _data["endTolerance"];
            this.workDayTypeId = _data["workDayTypeId"];
            this.compensateOverTime = _data["compensateOverTime"];
            this.overTime = _data["overTime"];
            this.workDayRoundTypeId = _data["workDayRoundTypeId"];
            if (Array.isArray(_data["daysOff"])) {
                this.daysOff = [] as any;
                for (let item of _data["daysOff"])
                    this.daysOff.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startTolerance"] = this.startTolerance;
        data["endTolerance"] = this.endTolerance;
        data["workDayTypeId"] = this.workDayTypeId;
        data["compensateOverTime"] = this.compensateOverTime;
        data["overTime"] = this.overTime;
        data["workDayRoundTypeId"] = this.workDayRoundTypeId;
        if (Array.isArray(this.daysOff)) {
            data["daysOff"] = [];
            for (let item of this.daysOff)
                data["daysOff"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkDayDto {
        const json = this.toJSON();
        let result = new UpdateWorkDayDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkDayDto {
    name: string;
    description: string | undefined;
    startTolerance: number;
    endTolerance: number;
    workDayTypeId: number;
    compensateOverTime: boolean;
    overTime: boolean;
    workDayRoundTypeId: number | undefined;
    daysOff: number[] | undefined;
    id: string;
}

export class WorkDayRoundTypeDto implements IWorkDayRoundTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    isDeleted: boolean;
    id: number;

    constructor(data?: IWorkDayRoundTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkDayRoundTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayRoundTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkDayRoundTypeDto {
        const json = this.toJSON();
        let result = new WorkDayRoundTypeDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayRoundTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
    isDeleted: boolean;
    id: number;
}

export class WorkDayRoundTypeDtoPagedResultDto implements IWorkDayRoundTypeDtoPagedResultDto {
    totalCount: number;
    items: WorkDayRoundTypeDto[] | undefined;

    constructor(data?: IWorkDayRoundTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkDayRoundTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkDayRoundTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayRoundTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkDayRoundTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkDayRoundTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayRoundTypeDtoPagedResultDto {
    totalCount: number;
    items: WorkDayRoundTypeDto[] | undefined;
}

export class CreateWorkDayRoundTypeDto implements ICreateWorkDayRoundTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;

    constructor(data?: ICreateWorkDayRoundTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
        }
    }

    static fromJS(data: any): CreateWorkDayRoundTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkDayRoundTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        return data;
    }

    clone(): CreateWorkDayRoundTypeDto {
        const json = this.toJSON();
        let result = new CreateWorkDayRoundTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkDayRoundTypeDto {
    name: string;
    description: string | undefined;
    langKey: string;
}

export class WorkDayTypeDto implements IWorkDayTypeDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    langKey: string;
    isDeleted: boolean;
    id: number;

    constructor(data?: IWorkDayTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkDayTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkDayTypeDto {
        const json = this.toJSON();
        let result = new WorkDayTypeDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayTypeDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    langKey: string;
    isDeleted: boolean;
    id: number;
}

export class WorkDayTypeDtoPagedResultDto implements IWorkDayTypeDtoPagedResultDto {
    totalCount: number;
    items: WorkDayTypeDto[] | undefined;

    constructor(data?: IWorkDayTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkDayTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkDayTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkDayTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkDayTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayTypeDtoPagedResultDto {
    totalCount: number;
    items: WorkDayTypeDto[] | undefined;
}

export class WorkDayTypeFilterDto implements IWorkDayTypeFilterDto {
    name: string;
    id: number;

    constructor(data?: IWorkDayTypeFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkDayTypeFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayTypeFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkDayTypeFilterDto {
        const json = this.toJSON();
        let result = new WorkDayTypeFilterDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayTypeFilterDto {
    name: string;
    id: number;
}

export class WorkDayTypeFilterDtoPagedResultDto implements IWorkDayTypeFilterDtoPagedResultDto {
    totalCount: number;
    items: WorkDayTypeFilterDto[] | undefined;

    constructor(data?: IWorkDayTypeFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkDayTypeFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkDayTypeFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkDayTypeFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkDayTypeFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkDayTypeFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkDayTypeFilterDtoPagedResultDto {
    totalCount: number;
    items: WorkDayTypeFilterDto[] | undefined;
}

export class CreateWorkDayTypeDto implements ICreateWorkDayTypeDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    langKey: string;

    constructor(data?: ICreateWorkDayTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.langKey = _data["langKey"];
        }
    }

    static fromJS(data: any): CreateWorkDayTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkDayTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["langKey"] = this.langKey;
        return data;
    }

    clone(): CreateWorkDayTypeDto {
        const json = this.toJSON();
        let result = new CreateWorkDayTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkDayTypeDto {
    name: string;
    code: string | undefined;
    description: string | undefined;
    langKey: string;
}

export class WorkerDtoPagedResultDto implements IWorkerDtoPagedResultDto {
    totalCount: number;
    items: WorkerDto[] | undefined;

    constructor(data?: IWorkerDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkerDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkerDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkerDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerDtoPagedResultDto {
    totalCount: number;
    items: WorkerDto[] | undefined;
}

export class SimpleWorkerDtoPagedResultDto implements ISimpleWorkerDtoPagedResultDto {
    totalCount: number;
    items: SimpleWorkerDto[] | undefined;

    constructor(data?: ISimpleWorkerDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SimpleWorkerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SimpleWorkerDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleWorkerDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SimpleWorkerDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SimpleWorkerDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleWorkerDtoPagedResultDto {
    totalCount: number;
    items: SimpleWorkerDto[] | undefined;
}

export class SimpleWorkerDtoListResultDto implements ISimpleWorkerDtoListResultDto {
    items: SimpleWorkerDto[] | undefined;

    constructor(data?: ISimpleWorkerDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SimpleWorkerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SimpleWorkerDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleWorkerDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SimpleWorkerDtoListResultDto {
        const json = this.toJSON();
        let result = new SimpleWorkerDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleWorkerDtoListResultDto {
    items: SimpleWorkerDto[] | undefined;
}

export class CreateWorkerInfoDto implements ICreateWorkerInfoDto {
    internalCode: string | undefined;
    countryId: number;
    birthday: moment.Moment;
    genreId: string;
    maritalStatusId: string | undefined;
    academicInfo: CreateAcademicInfoDto;
    sizeInfo: CreateSizeInfoDto;
    contactInfo: CreateContactInfoDto;
    driverLicenseInfo: CreateDriverLicenseInfoDto;

    constructor(data?: ICreateWorkerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalCode = _data["internalCode"];
            this.countryId = _data["countryId"];
            this.birthday = _data["birthday"] ? moment(_data["birthday"].toString()) : <any>undefined;
            this.genreId = _data["genreId"];
            this.maritalStatusId = _data["maritalStatusId"];
            this.academicInfo = _data["academicInfo"] ? CreateAcademicInfoDto.fromJS(_data["academicInfo"]) : <any>undefined;
            this.sizeInfo = _data["sizeInfo"] ? CreateSizeInfoDto.fromJS(_data["sizeInfo"]) : <any>undefined;
            this.contactInfo = _data["contactInfo"] ? CreateContactInfoDto.fromJS(_data["contactInfo"]) : <any>undefined;
            this.driverLicenseInfo = _data["driverLicenseInfo"] ? CreateDriverLicenseInfoDto.fromJS(_data["driverLicenseInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateWorkerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalCode"] = this.internalCode;
        data["countryId"] = this.countryId;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["genreId"] = this.genreId;
        data["maritalStatusId"] = this.maritalStatusId;
        data["academicInfo"] = this.academicInfo ? this.academicInfo.toJSON() : <any>undefined;
        data["sizeInfo"] = this.sizeInfo ? this.sizeInfo.toJSON() : <any>undefined;
        data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
        data["driverLicenseInfo"] = this.driverLicenseInfo ? this.driverLicenseInfo.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateWorkerInfoDto {
        const json = this.toJSON();
        let result = new CreateWorkerInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkerInfoDto {
    internalCode: string | undefined;
    countryId: number;
    birthday: moment.Moment;
    genreId: string;
    maritalStatusId: string | undefined;
    academicInfo: CreateAcademicInfoDto;
    sizeInfo: CreateSizeInfoDto;
    contactInfo: CreateContactInfoDto;
    driverLicenseInfo: CreateDriverLicenseInfoDto;
}

export class CreateWorkingInfoDto implements ICreateWorkingInfoDto {
    workPhone: string | undefined;
    jobTitleId: string;
    departmentId: string | undefined;
    costCenterId: string;
    isActive: boolean;
    farmsId: string[] | undefined;
    admissionDate: moment.Moment | undefined;
    paymentTypeId: number | undefined;
    transportId: string | undefined;

    constructor(data?: ICreateWorkingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workPhone = _data["workPhone"];
            this.jobTitleId = _data["jobTitleId"];
            this.departmentId = _data["departmentId"];
            this.costCenterId = _data["costCenterId"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.paymentTypeId = _data["paymentTypeId"];
            this.transportId = _data["transportId"];
        }
    }

    static fromJS(data: any): CreateWorkingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workPhone"] = this.workPhone;
        data["jobTitleId"] = this.jobTitleId;
        data["departmentId"] = this.departmentId;
        data["costCenterId"] = this.costCenterId;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["paymentTypeId"] = this.paymentTypeId;
        data["transportId"] = this.transportId;
        return data;
    }

    clone(): CreateWorkingInfoDto {
        const json = this.toJSON();
        let result = new CreateWorkingInfoDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkingInfoDto {
    workPhone: string | undefined;
    jobTitleId: string;
    departmentId: string | undefined;
    costCenterId: string;
    isActive: boolean;
    farmsId: string[] | undefined;
    admissionDate: moment.Moment | undefined;
    paymentTypeId: number | undefined;
    transportId: string | undefined;
}

export class CreateWorkerDto implements ICreateWorkerDto {
    name: string;
    middleName: string | undefined;
    surName: string;
    lastName: string;
    code: string;
    workerInfo: CreateWorkerInfoDto;
    workingInfo: CreateWorkingInfoDto;
    identificationTypeId: string;
    identificationNumber: string;
    filePhoto: FileDto;
    contracts: CreateContractDto[] | undefined;
    retirementInfo: CreateRetirementInfoDto;
    healthInfo: CreateHealthInfoDto;
    afcInfo: CreateAFCInfoDto;
    retirementRecordInfo: CreateRetirementRecordInfoDto;
    voluntaryRetirementSavings: CreateVoluntaryRetirementSavingDto[] | undefined;
    familyDependentInfo: CreateFamilyDependentInfoDto;
    familyDependents: CreateFamilyDependentDto[] | undefined;
    bankaryInfo: CreateBankaryInfoDto;
    signatureInfo: CreateSignatureInfoDto;

    constructor(data?: ICreateWorkerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            this.code = _data["code"];
            this.workerInfo = _data["workerInfo"] ? CreateWorkerInfoDto.fromJS(_data["workerInfo"]) : <any>undefined;
            this.workingInfo = _data["workingInfo"] ? CreateWorkingInfoDto.fromJS(_data["workingInfo"]) : <any>undefined;
            this.identificationTypeId = _data["identificationTypeId"];
            this.identificationNumber = _data["identificationNumber"];
            this.filePhoto = _data["filePhoto"] ? FileDto.fromJS(_data["filePhoto"]) : <any>undefined;
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts.push(CreateContractDto.fromJS(item));
            }
            this.retirementInfo = _data["retirementInfo"] ? CreateRetirementInfoDto.fromJS(_data["retirementInfo"]) : <any>undefined;
            this.healthInfo = _data["healthInfo"] ? CreateHealthInfoDto.fromJS(_data["healthInfo"]) : <any>undefined;
            this.afcInfo = _data["afcInfo"] ? CreateAFCInfoDto.fromJS(_data["afcInfo"]) : <any>undefined;
            this.retirementRecordInfo = _data["retirementRecordInfo"] ? CreateRetirementRecordInfoDto.fromJS(_data["retirementRecordInfo"]) : <any>undefined;
            if (Array.isArray(_data["voluntaryRetirementSavings"])) {
                this.voluntaryRetirementSavings = [] as any;
                for (let item of _data["voluntaryRetirementSavings"])
                    this.voluntaryRetirementSavings.push(CreateVoluntaryRetirementSavingDto.fromJS(item));
            }
            this.familyDependentInfo = _data["familyDependentInfo"] ? CreateFamilyDependentInfoDto.fromJS(_data["familyDependentInfo"]) : <any>undefined;
            if (Array.isArray(_data["familyDependents"])) {
                this.familyDependents = [] as any;
                for (let item of _data["familyDependents"])
                    this.familyDependents.push(CreateFamilyDependentDto.fromJS(item));
            }
            this.bankaryInfo = _data["bankaryInfo"] ? CreateBankaryInfoDto.fromJS(_data["bankaryInfo"]) : <any>undefined;
            this.signatureInfo = _data["signatureInfo"] ? CreateSignatureInfoDto.fromJS(_data["signatureInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateWorkerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["code"] = this.code;
        data["workerInfo"] = this.workerInfo ? this.workerInfo.toJSON() : <any>undefined;
        data["workingInfo"] = this.workingInfo ? this.workingInfo.toJSON() : <any>undefined;
        data["identificationTypeId"] = this.identificationTypeId;
        data["identificationNumber"] = this.identificationNumber;
        data["filePhoto"] = this.filePhoto ? this.filePhoto.toJSON() : <any>undefined;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        data["retirementInfo"] = this.retirementInfo ? this.retirementInfo.toJSON() : <any>undefined;
        data["healthInfo"] = this.healthInfo ? this.healthInfo.toJSON() : <any>undefined;
        data["afcInfo"] = this.afcInfo ? this.afcInfo.toJSON() : <any>undefined;
        data["retirementRecordInfo"] = this.retirementRecordInfo ? this.retirementRecordInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.voluntaryRetirementSavings)) {
            data["voluntaryRetirementSavings"] = [];
            for (let item of this.voluntaryRetirementSavings)
                data["voluntaryRetirementSavings"].push(item.toJSON());
        }
        data["familyDependentInfo"] = this.familyDependentInfo ? this.familyDependentInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.familyDependents)) {
            data["familyDependents"] = [];
            for (let item of this.familyDependents)
                data["familyDependents"].push(item.toJSON());
        }
        data["bankaryInfo"] = this.bankaryInfo ? this.bankaryInfo.toJSON() : <any>undefined;
        data["signatureInfo"] = this.signatureInfo ? this.signatureInfo.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateWorkerDto {
        const json = this.toJSON();
        let result = new CreateWorkerDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkerDto {
    name: string;
    middleName: string | undefined;
    surName: string;
    lastName: string;
    code: string;
    workerInfo: CreateWorkerInfoDto;
    workingInfo: CreateWorkingInfoDto;
    identificationTypeId: string;
    identificationNumber: string;
    filePhoto: FileDto;
    contracts: CreateContractDto[] | undefined;
    retirementInfo: CreateRetirementInfoDto;
    healthInfo: CreateHealthInfoDto;
    afcInfo: CreateAFCInfoDto;
    retirementRecordInfo: CreateRetirementRecordInfoDto;
    voluntaryRetirementSavings: CreateVoluntaryRetirementSavingDto[] | undefined;
    familyDependentInfo: CreateFamilyDependentInfoDto;
    familyDependents: CreateFamilyDependentDto[] | undefined;
    bankaryInfo: CreateBankaryInfoDto;
    signatureInfo: CreateSignatureInfoDto;
}

export class UpdateWorkerMainDataDto implements IUpdateWorkerMainDataDto {
    name: string;
    middleName: string | undefined;
    surName: string;
    lastName: string;
    code: string | undefined;
    id: string;

    constructor(data?: IUpdateWorkerMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            this.code = _data["code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkerMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkerMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["code"] = this.code;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkerMainDataDto {
        const json = this.toJSON();
        let result = new UpdateWorkerMainDataDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkerMainDataDto {
    name: string;
    middleName: string | undefined;
    surName: string;
    lastName: string;
    code: string | undefined;
    id: string;
}

export class UpdateWorkerInfoDto implements IUpdateWorkerInfoDto {
    countryId: number;
    birthday: moment.Moment;
    genreId: string;
    maritalStatusId: string;
    academicInfo: UpdateAcademicInfoDto;
    id: string;

    constructor(data?: IUpdateWorkerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            this.birthday = _data["birthday"] ? moment(_data["birthday"].toString()) : <any>undefined;
            this.genreId = _data["genreId"];
            this.maritalStatusId = _data["maritalStatusId"];
            this.academicInfo = _data["academicInfo"] ? UpdateAcademicInfoDto.fromJS(_data["academicInfo"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["genreId"] = this.genreId;
        data["maritalStatusId"] = this.maritalStatusId;
        data["academicInfo"] = this.academicInfo ? this.academicInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkerInfoDto {
        const json = this.toJSON();
        let result = new UpdateWorkerInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkerInfoDto {
    countryId: number;
    birthday: moment.Moment;
    genreId: string;
    maritalStatusId: string;
    academicInfo: UpdateAcademicInfoDto;
    id: string;
}

export class UpdatePersonalDataDto implements IUpdatePersonalDataDto {
    identificationTypeId: string;
    identificationNumber: string | undefined;
    workerInfo: UpdateWorkerInfoDto;
    id: string;

    constructor(data?: IUpdatePersonalDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identificationTypeId = _data["identificationTypeId"];
            this.identificationNumber = _data["identificationNumber"];
            this.workerInfo = _data["workerInfo"] ? UpdateWorkerInfoDto.fromJS(_data["workerInfo"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatePersonalDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonalDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identificationTypeId"] = this.identificationTypeId;
        data["identificationNumber"] = this.identificationNumber;
        data["workerInfo"] = this.workerInfo ? this.workerInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdatePersonalDataDto {
        const json = this.toJSON();
        let result = new UpdatePersonalDataDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePersonalDataDto {
    identificationTypeId: string;
    identificationNumber: string | undefined;
    workerInfo: UpdateWorkerInfoDto;
    id: string;
}

export class UpdateWorkerFamilyDependentDto implements IUpdateWorkerFamilyDependentDto {
    familyDependents: FamilyDependentDto[] | undefined;
    id: string;

    constructor(data?: IUpdateWorkerFamilyDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["familyDependents"])) {
                this.familyDependents = [] as any;
                for (let item of _data["familyDependents"])
                    this.familyDependents.push(FamilyDependentDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkerFamilyDependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkerFamilyDependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.familyDependents)) {
            data["familyDependents"] = [];
            for (let item of this.familyDependents)
                data["familyDependents"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkerFamilyDependentDto {
        const json = this.toJSON();
        let result = new UpdateWorkerFamilyDependentDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkerFamilyDependentDto {
    familyDependents: FamilyDependentDto[] | undefined;
    id: string;
}

export class UpdateWorkerVoluntaryRetirementSavingDto implements IUpdateWorkerVoluntaryRetirementSavingDto {
    voluntaryRetirementSavings: VoluntaryRetirementSavingDto[] | undefined;
    id: string;

    constructor(data?: IUpdateWorkerVoluntaryRetirementSavingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["voluntaryRetirementSavings"])) {
                this.voluntaryRetirementSavings = [] as any;
                for (let item of _data["voluntaryRetirementSavings"])
                    this.voluntaryRetirementSavings.push(VoluntaryRetirementSavingDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkerVoluntaryRetirementSavingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkerVoluntaryRetirementSavingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.voluntaryRetirementSavings)) {
            data["voluntaryRetirementSavings"] = [];
            for (let item of this.voluntaryRetirementSavings)
                data["voluntaryRetirementSavings"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkerVoluntaryRetirementSavingDto {
        const json = this.toJSON();
        let result = new UpdateWorkerVoluntaryRetirementSavingDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkerVoluntaryRetirementSavingDto {
    voluntaryRetirementSavings: VoluntaryRetirementSavingDto[] | undefined;
    id: string;
}

export class UpdateWorkerPhotoDto implements IUpdateWorkerPhotoDto {
    identificationNumber: string;
    filePhoto: FileDto;
    id: string;

    constructor(data?: IUpdateWorkerPhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identificationNumber = _data["identificationNumber"];
            this.filePhoto = _data["filePhoto"] ? FileDto.fromJS(_data["filePhoto"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkerPhotoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkerPhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identificationNumber"] = this.identificationNumber;
        data["filePhoto"] = this.filePhoto ? this.filePhoto.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkerPhotoDto {
        const json = this.toJSON();
        let result = new UpdateWorkerPhotoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkerPhotoDto {
    identificationNumber: string;
    filePhoto: FileDto;
    id: string;
}

export class WorkerFilterDto implements IWorkerFilterDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    readonly fullName: string | undefined;
    identificationNumber: string | undefined;
    id: string;

    constructor(data?: IWorkerFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
            this.identificationNumber = _data["identificationNumber"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkerFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["identificationNumber"] = this.identificationNumber;
        data["id"] = this.id;
        return data;
    }

    clone(): WorkerFilterDto {
        const json = this.toJSON();
        let result = new WorkerFilterDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerFilterDto {
    name: string | undefined;
    middleName: string | undefined;
    surName: string | undefined;
    lastName: string | undefined;
    fullName: string | undefined;
    identificationNumber: string | undefined;
    id: string;
}

export class WorkerFilterDtoPagedResultDto implements IWorkerFilterDtoPagedResultDto {
    totalCount: number;
    items: WorkerFilterDto[] | undefined;

    constructor(data?: IWorkerFilterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkerFilterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkerFilterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerFilterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkerFilterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkerFilterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerFilterDtoPagedResultDto {
    totalCount: number;
    items: WorkerFilterDto[] | undefined;
}

export class UpdateWorkingInfoDto implements IUpdateWorkingInfoDto {
    workPhone: string | undefined;
    jobTitleId: string;
    admissionDate: moment.Moment | undefined;
    paymentTypeId: number | undefined;
    transportId: string | undefined;
    id: string;

    constructor(data?: IUpdateWorkingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workPhone = _data["workPhone"];
            this.jobTitleId = _data["jobTitleId"];
            this.admissionDate = _data["admissionDate"] ? moment(_data["admissionDate"].toString()) : <any>undefined;
            this.paymentTypeId = _data["paymentTypeId"];
            this.transportId = _data["transportId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workPhone"] = this.workPhone;
        data["jobTitleId"] = this.jobTitleId;
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["paymentTypeId"] = this.paymentTypeId;
        data["transportId"] = this.transportId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkingInfoDto {
        const json = this.toJSON();
        let result = new UpdateWorkingInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkingInfoDto {
    workPhone: string | undefined;
    jobTitleId: string;
    admissionDate: moment.Moment | undefined;
    paymentTypeId: number | undefined;
    transportId: string | undefined;
    id: string;
}

export class UpdateWorkerDto implements IUpdateWorkerDto {
    name: string;
    middleName: string;
    surName: string;
    lastName: string;
    workerInfo: UpdateWorkerInfoDto;
    workingInfo: UpdateWorkingInfoDto;
    identificationTypeId: string;
    identificationNumber: string;
    filePhoto: FileDto;
    id: string;

    constructor(data?: IUpdateWorkerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.middleName = _data["middleName"];
            this.surName = _data["surName"];
            this.lastName = _data["lastName"];
            this.workerInfo = _data["workerInfo"] ? UpdateWorkerInfoDto.fromJS(_data["workerInfo"]) : <any>undefined;
            this.workingInfo = _data["workingInfo"] ? UpdateWorkingInfoDto.fromJS(_data["workingInfo"]) : <any>undefined;
            this.identificationTypeId = _data["identificationTypeId"];
            this.identificationNumber = _data["identificationNumber"];
            this.filePhoto = _data["filePhoto"] ? FileDto.fromJS(_data["filePhoto"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkerDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["middleName"] = this.middleName;
        data["surName"] = this.surName;
        data["lastName"] = this.lastName;
        data["workerInfo"] = this.workerInfo ? this.workerInfo.toJSON() : <any>undefined;
        data["workingInfo"] = this.workingInfo ? this.workingInfo.toJSON() : <any>undefined;
        data["identificationTypeId"] = this.identificationTypeId;
        data["identificationNumber"] = this.identificationNumber;
        data["filePhoto"] = this.filePhoto ? this.filePhoto.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkerDto {
        const json = this.toJSON();
        let result = new UpdateWorkerDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkerDto {
    name: string;
    middleName: string;
    surName: string;
    lastName: string;
    workerInfo: UpdateWorkerInfoDto;
    workingInfo: UpdateWorkingInfoDto;
    identificationTypeId: string;
    identificationNumber: string;
    filePhoto: FileDto;
    id: string;
}

export class WorkerInfoDtoPagedResultDto implements IWorkerInfoDtoPagedResultDto {
    totalCount: number;
    items: WorkerInfoDto[] | undefined;

    constructor(data?: IWorkerInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkerInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkerInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkerInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkerInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkerInfoDtoPagedResultDto {
    totalCount: number;
    items: WorkerInfoDto[] | undefined;
}

export class UpdateOrganizationalInfoDto implements IUpdateOrganizationalInfoDto {
    farmsId: string[] | undefined;
    departmentId: string | undefined;
    costCenterId: string;
    id: string;

    constructor(data?: IUpdateOrganizationalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            this.departmentId = _data["departmentId"];
            this.costCenterId = _data["costCenterId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateOrganizationalInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        data["departmentId"] = this.departmentId;
        data["costCenterId"] = this.costCenterId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateOrganizationalInfoDto {
        const json = this.toJSON();
        let result = new UpdateOrganizationalInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationalInfoDto {
    farmsId: string[] | undefined;
    departmentId: string | undefined;
    costCenterId: string;
    id: string;
}

export class WorkingInfoDtoPagedResultDto implements IWorkingInfoDtoPagedResultDto {
    totalCount: number;
    items: WorkingInfoDto[] | undefined;

    constructor(data?: IWorkingInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkingInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkingInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkingInfoDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkingInfoDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkingInfoDtoPagedResultDto {
    totalCount: number;
    items: WorkingInfoDto[] | undefined;
}

export class WorkShiftDtoPagedResultDto implements IWorkShiftDtoPagedResultDto {
    totalCount: number;
    items: WorkShiftDto[] | undefined;

    constructor(data?: IWorkShiftDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WorkShiftDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkShiftDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkShiftDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): WorkShiftDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WorkShiftDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWorkShiftDtoPagedResultDto {
    totalCount: number;
    items: WorkShiftDto[] | undefined;
}

export class CreateWorkShiftDto implements ICreateWorkShiftDto {
    name: string;
    color: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    farmsId: string[] | undefined;
    breaks: CreateBreakDto[] | undefined;

    constructor(data?: ICreateWorkShiftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.color = _data["color"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            if (Array.isArray(_data["breaks"])) {
                this.breaks = [] as any;
                for (let item of _data["breaks"])
                    this.breaks.push(CreateBreakDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkShiftDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkShiftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["color"] = this.color;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        if (Array.isArray(this.breaks)) {
            data["breaks"] = [];
            for (let item of this.breaks)
                data["breaks"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateWorkShiftDto {
        const json = this.toJSON();
        let result = new CreateWorkShiftDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkShiftDto {
    name: string;
    color: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    farmsId: string[] | undefined;
    breaks: CreateBreakDto[] | undefined;
}

export class UpdateWorkShiftDto implements IUpdateWorkShiftDto {
    name: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    farmsId: string[];
    color: string | undefined;
    breaks: BreakDto[] | undefined;
    id: string;

    constructor(data?: IUpdateWorkShiftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.farmsId = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["farmsId"])) {
                this.farmsId = [] as any;
                for (let item of _data["farmsId"])
                    this.farmsId.push(item);
            }
            this.color = _data["color"];
            if (Array.isArray(_data["breaks"])) {
                this.breaks = [] as any;
                for (let item of _data["breaks"])
                    this.breaks.push(BreakDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWorkShiftDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkShiftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.farmsId)) {
            data["farmsId"] = [];
            for (let item of this.farmsId)
                data["farmsId"].push(item);
        }
        data["color"] = this.color;
        if (Array.isArray(this.breaks)) {
            data["breaks"] = [];
            for (let item of this.breaks)
                data["breaks"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateWorkShiftDto {
        const json = this.toJSON();
        let result = new UpdateWorkShiftDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkShiftDto {
    name: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    farmsId: string[];
    color: string | undefined;
    breaks: BreakDto[] | undefined;
    id: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}